<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Extreme.Numerics.Generic.Net40</name>
    </assembly>
    <members>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1">
            <summary>
            Implements the BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
            <typeparam name="T">The element type of the arrays.</typeparam>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RealOneNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Takes the sum of the absolute values.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DZNRM2 := sqrt( x**H*x )
            </pre>
            </para>
            </summary>
            <remarks>
            <h4> Further Details:</h4>
            <para>
             -- This version written on 25-October-1982.</para>
            <para>
            <pre>
            Modified on 14-October-1993 to inline the call to ZLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Finds the index of element having max.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            absolute value.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 1/15/85.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Constant times a vector plus a vector.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Copies a vector, x, to a vector, y.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 4/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateDotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Forms the dot product of a vector.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Forms the dot product of two vectors.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},`0,`0)">
            <summary>
            <para>
            A plane rotation, where the cos and sin (c and s) are real
            and the vectors cx and cy are complex.</para>
            </summary>
            <param name="n">
            <pre>
             On entry, N specifies the order of the vectors cx and cy.
             N must be at least zero.
            </pre>
            </param>
            <param name="cx">
            <pre>
            CX is COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCX ) ).
             Before entry, the incremented array CX must contain the n
             element vector cx. On exit, CX is overwritten by the updated
             vector cx.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             CX. INCX must not be zero.
            </pre>
            </param>
            <param name="cy">
            <pre>
            CY is COMPLEX*16 array, dimension at least
             ( 1 + ( N - 1 )*abs( INCY ) ).
             Before entry, the incremented array CY must contain the n
             element vector cy. On exit, CY is overwritten by the updated
             vector cy.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             CY. INCY must not be zero.
            </pre>
            </param>
            <param name="c">
            <pre>
             On entry, C specifies the cosine, cos.
            </pre>
            </param>
            <param name="s">
            <pre>
             On entry, S specifies the sine, sin.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Scales a vector by a constant.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
            </summary>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="kl">
            <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
            </param>
            <param name="ku">
            <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>   or   op( X ) = X<sup>H</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
            </summary>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>H</sup>.
            </pre>
            </param>
            <param name="transb">
            <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>H</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,   or
               y := alpha*A<sup>H</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
            </summary>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>H</sup>*x + beta*y.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ConjugateRankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the rank 1 operation
               A := alpha*x*y**H + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
            </summary>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
            </summary>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandHermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian band matrix, with k super-diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the hermitian matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a hermitian band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars, A is an hermitian matrix and  B and
            C are m by n matrices.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE  specifies whether  the  hermitian matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  hermitian  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    hermitian matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    hermitian matrix is to be referenced.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  hermitian matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  hermitian matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  hermitian
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Note that the imaginary parts  of the diagonal elements need
             not be set, they are assumed to be zero.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n hermitian matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n hermitian matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the hermitian matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the hermitian matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the hermitian rank 2k operations
               C := alpha*A*B<sup>H</sup> + conjg( alpha )*B*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*B + conjg( alpha )*B<sup>H</sup>*A + beta*C,
            where  alpha and beta  are scalars with  beta  real,  C is an  n by n
            hermitian matrix and  A and B  are  n by k matrices in the first case
            and  k by n  matrices in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>H</sup>          +
                                           conjg( alpha )*B*A<sup>H</sup> +
                                           beta*C.
                TRANS = 'C' or 'c'    C := alpha*A<sup>H</sup>*B          +
                                           conjg( alpha )*B<sup>H</sup>*A +
                                           beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is COMPLEX*16 .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
             Unchanged on exit.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION .
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the hermitian rank k operations
               C := alpha*A*A<sup>H</sup> + beta*C,
            or
               C := alpha*A<sup>H</sup>*A + beta*C,
            where  alpha and beta  are  real scalars,  C is an  n by n  hermitian
            matrix and  A  is an  n by k  matrix in the  first case and a  k by n
            matrix in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>H</sup> + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>H</sup>*A + beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'C' or 'c',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION .
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  hermitian matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  hermitian matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set,  they are assumed to be zero,  and on exit they
             are set to zero.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            -- Modified 8-Nov-93 to set C(J,J) to DBLE( C(J,J) ) when BETA = 1.
               Ed Anderson, Cray Research Inc.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the matrix-vector operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n hermitian matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on.
             Note that the imaginary parts of the diagonal elements need
             not be set and are assumed to be zero.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the hermitian rank 1 operation
               A := alpha*x*x**H + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n hermitian matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedHermitianRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs the hermitian rank 2 operation
               A := alpha*x*y**H + conjg( alpha )*y*x**H + A,
            where alpha is a scalar, x and y are n element vectors and A is an
            n by n hermitian matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the hermitian matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
             Note that the imaginary parts of the diagonal elements need
             not be set, they are assumed to be zero, and on exit they
             are set to zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(Extreme.Mathematics.Complex{`0}@,Extreme.Mathematics.Complex{`0},`0@,Extreme.Mathematics.Complex{`0}@)">
            <summary>
            <para>
            Determines a complex Givens rotation.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Scales a vector by a constant.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Interchanges two vectors.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where  alpha and beta are scalars, A is a symmetric matrix and  B and
            C are m by n matrices.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is n  otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the  calling (sub) program. When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'    C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                           beta*C.
                TRANS = 'T' or 't'    C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                           beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrices  A and B.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars,  C is an  n by n symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't',  K  specifies  the number of rows of the
             matrix A.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is COMPLEX*16 array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A )
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, k ), where k is m
             when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is (input/output) COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,   or   x := A<sup>H</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>H</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is (input/output) COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>   or   op( A ) = A<sup>H</sup>.</para>
            </summary>
            <param name="side">
            <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>H</sup>.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The matrix X is overwritten on B.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,   or   A<sup>H</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>H</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is COMPLEX*16 array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Copies the specified elements of a complex matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies which part of the matrix should be copied.</param>
            <param name="m">The number of rows of the matrices.</param>
            <param name="n">The number of columns of the matrices.</param>
            <param name="a">A complex array that contains the data for the source matrix.</param>
            <param name="b">A complex array that contains the data for the destination matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Computes the norm of a general rectangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="m">The number of rows of the matrix.</param>
            <param name="n">The number of columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANGE</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Computes the norm of a triangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix is upper or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the diagonal
            elements are all equal to one.</param>
            <param name="m">The number of rows of the matrix.</param>
            <param name="n">The number of columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANTR</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Computes the norm of a symmetric matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANSY</c>.</remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HermitianMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Computes the norm of a Hermitian matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> that specifies the type of norm to compute.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            matrix elements are stored in the upper or lower triangle.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <returns>The norm of the matrix.</returns>
            <remarks>This method corresponds to the LAPACK routine <c>?LANHE</c>.</remarks>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Name">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Platform">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.OneNorm(System.Int32,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Takes the sum of the absolute values.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Constant times a vector plus a vector.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            uses unrolled loops for increments equal to one.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ComplexOneNorm(Extreme.Mathematics.Complex{`0})">
            <summary>
            <para>
            Computes the sum of the absolute values of a complex number
            </para>
            </summary>
            <remarks>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.DotProduct(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Forms the dot product of two vectors.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            uses unrolled loops for increments equal to one.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandMultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n band matrix, with kl sub-diagonals and ku super-diagonals.</para>
            </summary>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="kl">
            <pre>
             On entry, KL specifies the number of sub-diagonals of the
             matrix A. KL must satisfy  0 .le. KL.
            </pre>
            </param>
            <param name="ku">
            <pre>
             On entry, KU specifies the number of super-diagonals of the
             matrix A. KU must satisfy  0 .le. KU.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading ( kl + ku + 1 ) by n part of the
             array A must contain the matrix of coefficients, supplied
             column by column, with the leading diagonal of the matrix in
             row ( ku + 1 ) of the array, the first super-diagonal
             starting at position 2 in row ku, the first sub-diagonal
             starting at position 1 in row ( ku + 2 ), and so on.
             Elements in the array A that do not correspond to elements
             in the band matrix (such as the top left ku by ku triangle)
             are not referenced.
             The following program segment will transfer a band matrix
             from conventional full matrix storage to band storage:
                   DO 20, J = 1, N
                      K = KU + 1 - J
                      DO 10, I = MAX( 1, J - KU ), MIN( M, J + KL )
                         A( K + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( kl + ku + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*op( A )*op( B ) + beta*C,
            where  op( X ) is one of
               op( X ) = X   or   op( X ) = X<sup>T</sup>,
            alpha and beta are scalars, and A, B and C are matrices, with op( A )
            an m by k matrix,  op( B )  a  k by n matrix and  C an m by n matrix.</para>
            </summary>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n',  op( A ) = A.
                TRANSA = 'T' or 't',  op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c',  op( A ) = A<sup>T</sup>.
            </pre>
            </param>
            <param name="transb">
            <pre>
             On entry, TRANSB specifies the form of op( B ) to be used in
             the matrix multiplication as follows:
                TRANSB = 'N' or 'n',  op( B ) = B.
                TRANSB = 'T' or 't',  op( B ) = B<sup>T</sup>.
                TRANSB = 'C' or 'c',  op( B ) = B<sup>T</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies  the number  of rows  of the  matrix
             op( A )  and of the  matrix  C.  M  must  be at least  zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N  specifies the number  of columns of the matrix
             op( B ) and the number of columns of the matrix C. N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry,  K  specifies  the number of columns of the matrix
             op( A ) and the number of rows of the matrix op( B ). K must
             be at least  zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANSA = 'N' or 'n',  and is  m  otherwise.
             Before entry with  TRANSA = 'N' or 'n',  the leading  m by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by m  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. When  TRANSA = 'N' or 'n' then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             n  when  TRANSB = 'N' or 'n',  and is  k  otherwise.
             Before entry with  TRANSB = 'N' or 'n',  the leading  k by n
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  n by k  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in the calling (sub) program. When  TRANSB = 'N' or 'n' then
             LDB must be at least  max( 1, k ), otherwise  LDB must be at
             least  max( 1, n ).
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n  matrix
             ( alpha*op( A )*op( B ) + beta*C ).
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               y := alpha*A*x + beta*y,   or   y := alpha*A<sup>T</sup>*x + beta*y,
            where alpha and beta are scalars, x and y are vectors and A is an
            m by n matrix.</para>
            </summary>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   y := alpha*A*x + beta*y.
                TRANS = 'T' or 't'   y := alpha*A<sup>T</sup>*x + beta*y.
                TRANS = 'C' or 'c'   y := alpha*A<sup>T</sup>*x + beta*y.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( m - 1 )*abs( INCX ) ) otherwise.
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( m - 1 )*abs( INCY ) ) when TRANS = 'N' or 'n'
             and at least
             ( 1 + ( n - 1 )*abs( INCY ) ) otherwise.
             Before entry with BETA non-zero, the incremented array Y
             must contain the vector y. On exit, Y is overwritten by the
             updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.RankUpdate(System.Int32,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs the rank 1 operation
               A := alpha*x*y**T + A,
            where alpha is a scalar, x is an m element vector, y is an n element
            vector and A is an m by n matrix.</para>
            </summary>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of the matrix A.
             M must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( m - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the m
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry, the leading m by n part of the array A must
             contain the matrix of coefficients. On exit, A is
             overwritten by the updated matrix.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TwoNorm(System.Int32,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            <pre>
            Returns the euclidean norm of a vector via the function
            name, so that
               DNRM2 := sqrt( x'*x )
            </pre>
            </para>
            </summary>
            <remarks>
            <h4> Further Details:</h4>
            <para>
             -- This version written on 25-October-1982.</para>
            <para>
            <pre>
            Modified on 14-October-1993 to inline the call to DLASSQ.
            Sven Hammarling, Nag Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Rotate(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},`0,`0)">
            <summary>
            <para>
            Applies a plane rotation.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateGivensRotation(`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Construct givens plane rotation.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.ApplyModifiedGivensRotation(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},`0[])">
            <summary>
            <para>
            THE MODIFIED GIVENS TRANSFORMATION, H, TO THE 2 BY N MATRIX
               (DX<sup>T</sup>) , WHERE **T INDICATES TRANSPOSE.</para>
            </summary>
            <param name="n">
            <pre>
            number of elements in input vector(s)
            </pre>
            </param>
            <param name="dx">
            <pre>
            Dimension N
            T precision vector with N elements
            </pre>
            <pre>
            storage spacing between elements of DX
            </pre>
            </param>
            <param name="dy">
            <pre>
            Dimension N
            T precision vector with N elements
            </pre>
            <pre>
            storage spacing between elements of DY
            </pre>
            </param>
            <param name="dparam">
            <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            THE ELEMENTS OF DX ARE IN
               (DY<sup>T</sup>)
               DX(LX+I*INCX), I = 0 TO N-1, WHERE LX = 1 IF INCX  >=  0, ELSE
               LX = (-INCX)*N, AND SIMILARLY FOR SY USING LY AND INCY.
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               SEE DROTMG FOR A DESCRIPTION OF DATA STORAGE IN DPARAM.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.CreateModifiedGivensRotation(`0@,`0@,`0@,`0,`0[])">
            <summary>
            <para>
            THE MODIFIED GIVENS TRANSFORMATION MATRIX H WHICH ZEROS
               THE SECOND COMPONENT OF THE 2-VECTOR  (DSQRT(DD1)*DX1,DSQRT(DD2)*>    DY2)**T.</para>
            </summary>
            <param name="dd1">
            <pre>
            </pre>
            </param>
            <param name="dd2">
            <pre>
            </pre>
            </param>
            <param name="dx1">
            <pre>
            </pre>
            </param>
            <param name="dy1">
            <pre>
            </pre>
            </param>
            <param name="dparam">
            <pre>
            Dimension 5
            AM(1)=DFLAG
            RAM(2)=DH11
            ARAM(3)=DH21
            PARAM(4)=DH12
            DPARAM(5)=DH22
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
               WITH DPARAM(1)=DFLAG, H HAS ONE OF THE FOLLOWING FORMS.
               DFLAG=-1.D0     DFLAG=0.D0        DFLAG=1.D0     DFLAG=-2.D0
                 (DH11  DH12)    (1.D0  DH12)    (DH11  1.D0)    (1.D0  0.D0)
               H=(          )    (          )    (          )    (          )
                 (DH21  DH22),   (DH21  1.D0),   (-1.D0 DH22),   (0.D0  1.D0).
               LOCATIONS 2-4 OF DPARAM CONTAIN DH11, DH21, DH12, AND DH22
               RESPECTIVELY. (VALUES OF 1.D0, -1.D0, OR 0.D0 IMPLIED BY THE
               VALUE OF DPARAM(1) ARE NOT STORED IN DPARAM.)
               THE VALUES OF GAMSQ AND RGAMSQ SET IN THE DATA STATEMENT MAY BE
               INEXACT.  THIS IS OK AS THEY ARE ONLY USED FOR TESTING THE SIZE
               OF DD1 AND DD2.  ALL ACTUAL SCALING OF DATA IS DONE USING GAM.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric band matrix, with k super-diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the band matrix A is being supplied as
             follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    being supplied.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    being supplied.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry, K specifies the number of super-diagonals of the
             matrix A. K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer the upper
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the symmetric matrix, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer the lower
             triangular part of a symmetric band matrix from conventional
             full matrix storage to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the
             vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of DIMENSION at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the
             vector y. On exit, Y is overwritten by the updated vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MultiplyInPlace(System.Int32,`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Scales a vector by a constant.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            uses unrolled loops for increment equal to one.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs the matrix-vector operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedSymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an
            n by n symmetric matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the matrix A is supplied in the packed
             array AP as follows:
                UPLO = 'U' or 'u'   The upper triangular part of A is
                                    supplied in AP.
                UPLO = 'L' or 'l'   The lower triangular part of A is
                                    supplied in AP.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 1, 2 )
             and a( 2, 2 ) respectively, and so on. On exit, the array
             AP is overwritten by the upper triangular part of the
             updated matrix.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular part of the symmetric matrix
             packed sequentially, column by column, so that AP( 1 )
             contains a( 1, 1 ), AP( 2 ) and AP( 3 ) contain a( 2, 1 )
             and a( 3, 1 ) respectively, and so on. On exit, the array
             AP is overwritten by the lower triangular part of the
             updated matrix.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Swap(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Two vectors.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            uses unrolled loops for increments equal one.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               C := alpha*A*B + beta*C,
            or
               C := alpha*B*A + beta*C,
            where alpha and beta are scalars,  A is a symmetric matrix and  B and
            C are  m by n matrices.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE  specifies whether  the  symmetric matrix  A
             appears on the  left or right  in the  operation as follows:
                SIDE = 'L' or 'l'   C := alpha*A*B + beta*C,
                SIDE = 'R' or 'r'   C := alpha*B*A + beta*C,
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of  the  symmetric  matrix   A  is  to  be
             referenced as follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of the
                                    symmetric matrix is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of the
                                    symmetric matrix is to be referenced.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry,  M  specifies the number of rows of the matrix  C.
             M  must be at least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of the matrix C.
             N  must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             m  when  SIDE = 'L' or 'l'  and is  n otherwise.
             Before entry  with  SIDE = 'L' or 'l',  the  m by m  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading m by m upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  m by m  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
             Before entry  with  SIDE = 'R' or 'r',  the  n by n  part of
             the array  A  must contain the  symmetric matrix,  such that
             when  UPLO = 'U' or 'u', the leading n by n upper triangular
             part of the array  A  must contain the upper triangular part
             of the  symmetric matrix and the  strictly  lower triangular
             part of  A  is not referenced,  and when  UPLO = 'L' or 'l',
             the leading  n by n  lower triangular part  of the  array  A
             must  contain  the  lower triangular part  of the  symmetric
             matrix and the  strictly upper triangular part of  A  is not
             referenced.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA must be at least  max( 1, m ), otherwise  LDA must be at
             least  max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry, the leading  m by n part of the array  B  must
             contain the matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry,  BETA  specifies the scalar  beta.  When  BETA  is
             supplied as zero then C need not be set on input.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry, the leading  m by n  part of the array  C must
             contain the matrix  C,  except when  beta  is zero, in which
             case C need not be set on entry.
             On exit, the array  C  is overwritten by the  m by n updated
             matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMultiplyAndAddInPlace(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs the matrix-vector  operation
               y := alpha*A*x + beta*y,
            where alpha and beta are scalars, x and y are n element vectors and
            A is an n by n symmetric matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta. When BETA is
             supplied as zero then Y need not be set on input.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y. On exit, Y is overwritten by the updated
             vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs the symmetric rank 1 operation
               A := alpha*x*x**T + A,
            where alpha is a real scalar, x is an n element vector and A is an
            n by n symmetric matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,System.Int32,`0,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs the symmetric rank 2 operation
               A := alpha*x*y**T + alpha*y*x**T + A,
            where alpha is a scalar, x and y are n element vectors and A is an n
            by n symmetric matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the upper or lower
             triangular part of the array A is to be referenced as
             follows:
                UPLO = 'U' or 'u'   Only the upper triangular part of A
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the lower triangular part of A
                                    is to be referenced.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <param name="y">
            <pre>
            Y is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCY ) ).
             Before entry, the incremented array Y must contain the n
             element vector y.
            </pre>
            <pre>
             On entry, INCY specifies the increment for the elements of
             Y. INCY must not be zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular part of the symmetric matrix and the strictly
             lower triangular part of A is not referenced. On exit, the
             upper triangular part of the array A is overwritten by the
             upper triangular part of the updated matrix.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular part of the symmetric matrix and the strictly
             upper triangular part of A is not referenced. On exit, the
             lower triangular part of the array A is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs one of the symmetric rank 2k operations
               C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A and B  are  n by k  matrices  in the  first  case  and  k by n
            matrices in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*B<sup>T</sup> + alpha*B*A<sup>T</sup> +
                                          beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*B + alpha*B<sup>T</sup>*A +
                                          beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns  of the  matrices  A and B,  and on  entry  with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrices  A and B.  K must be at least  zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, kb ), where kb is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  B  must contain the matrix  B,  otherwise
             the leading  k by n  part of the array  B  must contain  the
             matrix B.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDB must be at least  max( 1, n ), otherwise  LDB must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricRankUpdate(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs one of the symmetric rank k operations
               C := alpha*A*A<sup>T</sup> + beta*C,
            or
               C := alpha*A<sup>T</sup>*A + beta*C,
            where  alpha and beta  are scalars, C is an  n by n  symmetric matrix
            and  A  is an  n by k  matrix in the first case and a  k by n  matrix
            in the second case.</para>
            </summary>
            <param name="uplo">
            <pre>
             On  entry,   UPLO  specifies  whether  the  upper  or  lower
             triangular  part  of the  array  C  is to be  referenced  as
             follows:
                UPLO = 'U' or 'u'   Only the  upper triangular part of  C
                                    is to be referenced.
                UPLO = 'L' or 'l'   Only the  lower triangular part of  C
                                    is to be referenced.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry,  TRANS  specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   C := alpha*A*A<sup>T</sup> + beta*C.
                TRANS = 'T' or 't'   C := alpha*A<sup>T</sup>*A + beta*C.
                TRANS = 'C' or 'c'   C := alpha*A<sup>T</sup>*A + beta*C.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry,  N specifies the order of the matrix C.  N must be
             at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with  TRANS = 'N' or 'n',  K  specifies  the number
             of  columns   of  the   matrix   A,   and  on   entry   with
             TRANS = 'T' or 't' or 'C' or 'c',  K  specifies  the  number
             of rows of the matrix  A.  K must be at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry, ALPHA specifies the scalar alpha.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, ka ), where ka is
             k  when  TRANS = 'N' or 'n',  and is  n  otherwise.
             Before entry with  TRANS = 'N' or 'n',  the  leading  n by k
             part of the array  A  must contain the matrix  A,  otherwise
             the leading  k by n  part of the array  A  must contain  the
             matrix A.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in  the  calling  (sub)  program.   When  TRANS = 'N' or 'n'
             then  LDA must be at least  max( 1, n ), otherwise  LDA must
             be at least  max( 1, k ).
            </pre>
            </param>
            <param name="beta">
            <pre>
            BETA is DOUBLE PRECISION.
             On entry, BETA specifies the scalar beta.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is DOUBLE PRECISION array of DIMENSION ( LDC, n ).
             Before entry  with  UPLO = 'U' or 'u',  the leading  n by n
             upper triangular part of the array C must contain the upper
             triangular part  of the  symmetric matrix  and the strictly
             lower triangular part of C is not referenced.  On exit, the
             upper triangular part of the array  C is overwritten by the
             upper triangular part of the updated matrix.
             Before entry  with  UPLO = 'L' or 'l',  the leading  n by n
             lower triangular part of the array C must contain the lower
             triangular part  of the  symmetric matrix  and the strictly
             upper triangular part of C is not referenced.  On exit, the
             lower triangular part of the array  C is overwritten by the
             lower triangular part of the updated matrix.
            </pre>
            <pre>
             On entry, LDC specifies the first dimension of C as declared
             in  the  calling  (sub)  program.   LDC  must  be  at  least
             max( 1, n ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular band matrix, with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.BandTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular band matrix, with ( k + 1 )
            diagonals.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="k">
            <pre>
             On entry with UPLO = 'U' or 'u', K specifies the number of
             super-diagonals of the matrix A.
             On entry with UPLO = 'L' or 'l', K specifies the number of
             sub-diagonals of the matrix A.
             K must satisfy  0 .le. K.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with UPLO = 'U' or 'u', the leading ( k + 1 )
             by n part of the array A must contain the upper triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row
             ( k + 1 ) of the array, the first super-diagonal starting at
             position 2 in row k, and so on. The top left k by k triangle
             of the array A is not referenced.
             The following program segment will transfer an upper
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = K + 1 - J
                      DO 10, I = MAX( 1, J - K ), J
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Before entry with UPLO = 'L' or 'l', the leading ( k + 1 )
             by n part of the array A must contain the lower triangular
             band part of the matrix of coefficients, supplied column by
             column, with the leading diagonal of the matrix in row 1 of
             the array, the first sub-diagonal starting at position 1 in
             row 2, and so on. The bottom right k by k triangle of the
             array A is not referenced.
             The following program segment will transfer a lower
             triangular band matrix from conventional full matrix storage
             to band storage:
                   DO 20, J = 1, N
                      M = 1 - J
                      DO 10, I = J, MIN( N, J + K )
                         A( M + I, J ) = matrix( I, J )
                10    CONTINUE
                20 CONTINUE
             Note that when DIAG = 'U' or 'u' the elements of the array A
             corresponding to the diagonal elements of the matrix are not
             referenced, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             ( k + 1 ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.PackedTriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix, supplied in packed form.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="ap">
            <pre>
            AP is DOUBLE PRECISION array of DIMENSION at least
             ( ( n*( n + 1 ) )/2 ).
             Before entry with  UPLO = 'U' or 'u', the array AP must
             contain the upper triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 1, 2 ) and a( 2, 2 )
             respectively, and so on.
             Before entry with UPLO = 'L' or 'l', the array AP must
             contain the lower triangular matrix packed sequentially,
             column by column, so that AP( 1 ) contains a( 1, 1 ),
             AP( 2 ) and AP( 3 ) contain a( 2, 1 ) and a( 3, 1 )
             respectively, and so on.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced, but are assumed to be unity.
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Performs one of the matrix-matrix operations
               B := alpha*op( A )*B,   or   B := alpha*B*op( A ),
            where  alpha  is a scalar,  B  is an m by n matrix,  A  is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
            </summary>
            <param name="side">
            <pre>
             On entry,  SIDE specifies whether  op( A ) multiplies B from
             the left or right as follows:
                SIDE = 'L' or 'l'   B := alpha*op( A )*B.
                SIDE = 'R' or 'r'   B := alpha*B*op( A ).
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ), where k is m
            when  SIDE = 'L' or 'l'  and is  n  when  SIDE = 'R' or 'r'.
            Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
            upper triangular part of the array  A must contain the upper
            triangular matrix  and the strictly lower triangular part of
            A is not referenced.
            Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
            lower triangular part of the array  A must contain the lower
            triangular matrix  and the strictly upper triangular part of
            A is not referenced.
            Note that when  DIAG = 'U' or 'u',  the diagonal elements of
            A  are not referenced either,  but are assumed to be  unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain the matrix  B,  and  on exit  is overwritten  by the
             transformed matrix.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMultiplyInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Performs one of the matrix-vector operations
               x := A*x,   or   x := A<sup>T</sup>*x,
            where x is an n element vector and  A is an n by n unit, or non-unit,
            upper or lower triangular matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the operation to be performed as
             follows:
                TRANS = 'N' or 'n'   x := A*x.
                TRANS = 'T' or 't'   x := A<sup>T</sup>*x.
                TRANS = 'C' or 'c'   x := A<sup>T</sup>*x.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element vector x. On exit, X is overwritten with the
             tranformed vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 2 LinearAlgebra routine.
            The vector and matrix arguments are not referenced when N = 0, or M = 0
            -- Written on 22-October-1986.
               Jack Dongarra, Argonne National Lab.
               Jeremy Du Croz, Nag Central Office.
               Sven Hammarling, Nag Central Office.
               Richard Hanson, Sandia National Labs.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Solves one of the matrix equations
               op( A )*X = alpha*B,   or   X*op( A ) = alpha*B,
            where alpha is a scalar, X and B are m by n matrices, A is a unit, or
            non-unit,  upper or lower triangular matrix  and  op( A )  is one  of
               op( A ) = A   or   op( A ) = A<sup>T</sup>.</para>
            </summary>
            <param name="side">
            <pre>
             On entry, SIDE specifies whether op( A ) appears on the left
             or right of X as follows:
                SIDE = 'L' or 'l'   op( A )*X = alpha*B.
                SIDE = 'R' or 'r'   X*op( A ) = alpha*B.
            </pre>
            </param>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix A is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="transa">
            <pre>
             On entry, TRANSA specifies the form of op( A ) to be used in
             the matrix multiplication as follows:
                TRANSA = 'N' or 'n'   op( A ) = A.
                TRANSA = 'T' or 't'   op( A ) = A<sup>T</sup>.
                TRANSA = 'C' or 'c'   op( A ) = A<sup>T</sup>.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit triangular
             as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="m">
            <pre>
             On entry, M specifies the number of rows of B. M must be at
             least zero.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the number of columns of B.  N must be
             at least zero.
            </pre>
            </param>
            <param name="alpha">
            <pre>
            ALPHA is DOUBLE PRECISION.
             On entry,  ALPHA specifies the scalar  alpha. When  alpha is
             zero then  A is not referenced and  B need not be set before
             entry.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, k ),
             where k is m when SIDE = 'L' or 'l'
               and k is n when SIDE = 'R' or 'r'.
             Before entry  with  UPLO = 'U' or 'u',  the  leading  k by k
             upper triangular part of the array  A must contain the upper
             triangular matrix  and the strictly lower triangular part of
             A is not referenced.
             Before entry  with  UPLO = 'L' or 'l',  the  leading  k by k
             lower triangular part of the array  A must contain the lower
             triangular matrix  and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u',  the diagonal elements of
             A  are not referenced either,  but are assumed to be  unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program.  When  SIDE = 'L' or 'l'  then
             LDA  must be at least  max( 1, m ),  when  SIDE = 'R' or 'r'
             then LDA must be at least max( 1, n ).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is DOUBLE PRECISION array of DIMENSION ( LDB, n ).
             Before entry,  the leading  m by n part of the array  B must
             contain  the  right-hand  side  matrix  B,  and  on exit  is
             overwritten by the solution matrix  X.
            </pre>
            <pre>
             On entry, LDB specifies the first dimension of B as declared
             in  the  calling  (sub)  program.   LDB  must  be  at  least
             max( 1, m ).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The matrix X is overwritten on B.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            Level 3 LinearAlgebra routine.
            -- Written on 8-February-1989.
               Jack Dongarra, Argonne National Laboratory.
               Iain Duff, AERE Harwell.
               Jeremy Du Croz, Numerical Algorithms Group Ltd.
               Sven Hammarling, Numerical Algorithms Group Ltd.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularSolveInPlace(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Solves one of the systems of equations
               A*x = b,   or   A<sup>T</sup>*x = b,
            where b and x are n element vectors and A is an n by n unit, or
            non-unit, upper or lower triangular matrix.</para>
            </summary>
            <param name="uplo">
            <pre>
             On entry, UPLO specifies whether the matrix is an upper or
             lower triangular matrix as follows:
                UPLO = 'U' or 'u'   A is an upper triangular matrix.
                UPLO = 'L' or 'l'   A is a lower triangular matrix.
            </pre>
            </param>
            <param name="trans">
            <pre>
             On entry, TRANS specifies the equations to be solved as
             follows:
                TRANS = 'N' or 'n'   A*x = b.
                TRANS = 'T' or 't'   A<sup>T</sup>*x = b.
                TRANS = 'C' or 'c'   A<sup>T</sup>*x = b.
            </pre>
            </param>
            <param name="diag">
            <pre>
             On entry, DIAG specifies whether or not A is unit
             triangular as follows:
                DIAG = 'U' or 'u'   A is assumed to be unit triangular.
                DIAG = 'N' or 'n'   A is not assumed to be unit
                                    triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
             On entry, N specifies the order of the matrix A.
             N must be at least zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is DOUBLE PRECISION array of DIMENSION ( LDA, n ).
             Before entry with  UPLO = 'U' or 'u', the leading n by n
             upper triangular part of the array A must contain the upper
             triangular matrix and the strictly lower triangular part of
             A is not referenced.
             Before entry with UPLO = 'L' or 'l', the leading n by n
             lower triangular part of the array A must contain the lower
             triangular matrix and the strictly upper triangular part of
             A is not referenced.
             Note that when  DIAG = 'U' or 'u', the diagonal elements of
             A are not referenced either, but are assumed to be unity.
            </pre>
            <pre>
             On entry, LDA specifies the first dimension of A as declared
             in the calling (sub) program. LDA must be at least
             max( 1, n ).
            </pre>
            </param>
            <param name="x">
            <pre>
            X is DOUBLE PRECISION array of dimension at least
             ( 1 + ( n - 1 )*abs( INCX ) ).
             Before entry, the incremented array X must contain the n
             element right-hand side vector b. On exit, X is overwritten
             with the solution vector x.
            </pre>
            <pre>
             On entry, INCX specifies the increment for the elements of
             X. INCX must not be zero.
            2 LinearAlgebra routine.
            itten on 22-October-1986.
            ack Dongarra, Argonne National Lab.
            Jeremy Du Croz, Nag Central Office.
            Sven Hammarling, Nag Central Office.
            Richard Hanson, Sandia National Labs.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            No test for singularity or near-singularity is included in this
            routine. Such tests must be performed before calling this routine.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.AbsoluteMaxIndex(System.Int32,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Finds the index of element having max.</para>
            </summary>
            <remarks>
            <para>
            <pre>
            absolute value.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            jack dongarra, linpack, 3/11/78.
            modified 3/93 to return if incx .le. 0.
            modified 12/3/93, array(1) declarations changed to array(*)
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,M).
            </pre>
            </param>
            <remarks>
            This method corresponds to the LAPACK routine <c>DLACPY</c>.
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANGE as described
            above.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            DLANGE is set to zero.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            DLANGE is set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The m by n matrix A.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(M,1).
            </pre>
            </param>
            <remarks>
            <pre>
            DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            <para>This method corresponds to the LAPACK routine <c>DLANGE</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANTR as described
            above.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </pre>
            </param>
            <param name="diag">
            <pre>
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &lt;= N.  When M = 0, DLANTR is set to zero.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &lt;= M.  When N = 0, DLANTR is set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(M,1).
            </pre>
            </param>
            <remarks>
            <pre>
            DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            <para>This method corresponds to the LAPACK routine <c>DLANTR</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies the value to be returned in DLANSY as described
            above.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
            set to zero.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(N,1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </pre>
            </para> 
            <para>This method corresponds to the LAPACK routine <c>DLANSY</c>.</para>
            </remarks>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.MaxDegreeOfParallelism">
            <summary>
            Gets or sets the maximum degree of parallelism enabled by the instance.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericLinearAlgebraOperations`1.HasSharedDegreeOfParallelism">
            <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1">
            <summary>
            Specifies the methods that must be implemented by a
            class to support complex T-precision LAPACK routines
            for general matrices.
            </summary>
            <remarks>
            <para>The Linear Algebra PACKage (LAPACK) is the de facto
            standard for more complex linear algebra problems. It complements
            the Basic Linear Algebra Subroutines (BLAS), which defines standards
            for low level vector and matrix operations.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
             ZGETRF computes an LU decomposition of a general M-by-N matrix A
             using partial pivoting with row interchanges.
             <para>
             The decomposition has the form</para>
             <para><center>A = P * L * U</center></para>
             <para>where P is a permutation matrix, L is lower triangular with unit
             diagonal elements (lower trapezoidal if m > n), and U is upper
             triangular (upper trapezoidal if m &lt; n).
             </para>
             <para>
             This is the right-looking Level 3 BLAS version of the algorithm.
             </para>
             </summary>
             <param name="m">An integer specifying the number of rows
             of the matrix <paramref name="a"/>. Must be greater than
             or equal to zero.</param>
             <param name="n">An integer specifying the number of
             columns of the matrix <paramref name="a"/>. Must be
             greater than or equal to zero.
             </param>
             <param name="a">complex T-precision array specifying the
             <paramref name="m"/>-by-<paramref name="n"/> matrix
             to be factored. On exit, the factors L and U from the
             decomposition A = P*L*U; the unit diagonal elements of
             L are not stored.</param>
             <param name="ipiv">Integer array of length
             min(<paramref name="m"/>,<paramref name="n"/>) that
             will hold the pivot indexes. Row <i>i</i> of the
             matrix was interchanged with row
             <paramref name="ipiv"/>[<i>i</i>].</param>
             <param name="info">Reference to an integer containing a
             result code. Zero indicates success. Greater than zero
             indicates U(i,i) is exactly zero. The decomposition
             has been completed, but the factor U is exactly
             singular, and division by zero will occur if it is used
             to solve a system of equations.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
             ZGETRS solves a system of linear equations
                A * X = B  or  A' * X = B
             with a general N-by-N matrix A using the LU decomposition computed
             by ZGETRF.
            
             Arguments
             =========
            
             TRANS   (input) CHARACTER*1
             Specifies the form of the system of equations:
                = 'N':  A * X = B  (No transpose)
                = TransposeOperation.Transpose:  A'* X = B  (Transpose)
                = 'C':  A'* X = B  (Conjugate transpose = Transpose)
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             NRHS    (input) INTEGER
             The number of right hand sides, i.e., the number of columns
             of the matrix B.  NRHS >= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             B       (input/output) ZOUBLE PRECISION array, dimension (LDB,NRHS)
             On entry, the right hand side matrix B.
             On exit, the solution matrix X.
            
             LDB     (input) INTEGER
             The leading dimension of the array B.  LDB >= Max(1,N).
            
             <paramref name="info"/>    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            
             =====================================================================
            
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
             ZGETRI computes the inverse of a matrix using the LU decomposition
             computed by ZGETRF.
            
             This method inverts U and then computes inv(A) by solving the system
             inv(A)*L = inv(U) for inv(A).
            
             Arguments
             =========
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the factors L and U from the decomposition
             A = P*L*U as computed by ZGETRF.
             On exit, if <paramref name="info"/> = 0, the inverse of the original matrix A.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             IPIV    (input) INTEGER array, dimension (N)
             The pivot indexes from ZGETRF; for 1&lt; =i&lt; =N, row i of the
             matrix was interchanged with row IPIVi.
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if <paramref name="info"/> =0, then WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK >= Max(1,N).
             For optimal performance LWORK >= N*NB, where NB is
             the optimal blocksize returned by ILAENV.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             <paramref name="info"/>    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
             > 0:  if <paramref name="info"/> = i, U(i,i) is exactly zero; the matrix is
             singular and its inverse could not be computed.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
            <summary>
             ZGECON estimates the reciprocal of the condition number of a general
             real matrix A, inthis. either the 1-norm or the infinity-norm, using
             the LU decomposition computed by ZGETRF.
            
             An estimate is obtained for norm(inv(A)), and the reciprocal of the
             condition number is computed as
                RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            
             Arguments
             =========
            
             NORM    (input) CHARACTER*1
             Specifies whether the 1-norm condition number or the
             infinity-norm condition number is required:
                = '1' or 'O':  1-norm;
                = 'I':         Infinity-norm.
            
             N       (input) INTEGER
             The elementOrder of the matrix A.  N >= 0.
            
             A       (input) ZOUBLE PRECISION array, dimension (LDA,N)
             The factors L and U from the decomposition A = P*L*U
             as computed by ZGETRF.
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= Max(1,N).
            
             ANORM   (input) ZOUBLE PRECISION
             If NORM = '1' or 'O', the 1-norm of the original matrix A.
             If NORM = 'I', the infinity-norm of the original matrix A.
            
             RCOND   (output) ZOUBLE PRECISION
             The reciprocal of the condition number of the matrix A,
             computed as RCOND = 1/(norm(A) * norm(inv(A))).
            
             WORK    (workspace) ZOUBLE PRECISION array, dimension (4*N)
            
             IWORK   (workspace) INTEGER array, dimension (N)
            
             <paramref name="info"/>    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            
            
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
             ZGEQRF computes a QR decomposition of a real M-by-N matrix A:
             A = Q * R.
            
             Arguments
             =========
            
             M       (input) INTEGER
             The number of rows of the matrix A.  M >= 0.
            
             N       (input) INTEGER
             The number of columns of the matrix A.  N >= 0.
            
             A       (input/output) ZOUBLE PRECISION array, dimension (LDA,N)
             On entry, the M-by-N matrix A.
             On exit, the elements on and above the diagonal of the array
             contain the min(M,N)-by-N upper trapezoidal matrix R (R is
             upper triangular if m >= n); the elements below the diagonal,
             with the array TAU, represent the orthogonal matrix Q as a
             product of min(m,n) elementary reflectors (see Further
             Zetails).
            
             LDA     (input) INTEGER
             The leading dimension of the array A.  LDA >= max(1,M).
            
             TAU     (output) ZOUBLE PRECISION array, dimension (min(M,N))
             The scalar factors of the elementary reflectors (see Further
             Zetails).
            
             WORK    (workspace/output) ZOUBLE PRECISION array, dimension (LWORK)
             On exit, if <paramref name="info"/> = 0, WORK(1) returns the optimal LWORK.
            
             LWORK   (input) INTEGER
             The dimension of the array WORK.  LWORK >= max(1,N).
             For optimum performance LWORK >= N*NB, where NB is
             the optimal blocksize.
            
             If LWORK = -1, then a workspace query is assumed; the routine
             only calculates the optimal size of the WORK array, returns
             this value as the first entry of the WORK array, and no error
             message related to LWORK is issued by XERBLA.
            
             <paramref name="info"/>    (output) INTEGER
                = 0:  successful exit
             &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            
             Further Zetails
             ===============
            
             The matrix Q is represented as a product of elementary reflectors
            
                Q = H(1) H(2) . . . H(k), where k = min(m,n).
            
             Each H(i) has the form
            
                H(i) = I - tau * v * v'
            
             where tau is a real scalar, and v is a real vector with
             v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit inthis. A(i+1:m,i),
             and tau inthis. TAU(i).
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q<sup>H</sup> * C       C * Q<sup>H</sup>
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <pre>
            = 'L': apply Q or Q<sup>H</sup> from the Left;
            = 'R': apply Q or Q<sup>H</sup> from the Right.
            </pre>
            </param>
            <param name="trans">
            <pre>
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q<sup>H</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix C. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix C. N >= 0.
            </pre>
            </param>
            <param name="k">
            <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </pre>
            <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </pre>
            </param>
            <param name="tau">
            <pre>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </pre>
            </param>
            <param name="c">
            <pre>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>H</sup>*C or C*Q<sup>H</sup> or C*Q.
            </pre>
            <pre>
            The leading dimension of the array C. LDC >= max(1,M).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            . . H(k)
            as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            Solves a complex triangular system of equations.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="trans">A <see cref="T:Extreme.Mathematics.TransposeOperation"/> value that indicates if the matrix should be transposed or not.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="nrhs">The number of right hand sides.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="b">A complex array that contains the components of the right-hand side(s).</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            Computes the inverse of a complex triangular matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0@,System.Int32@)">
            <summary>
            Approximates the reciprocal of the condition number of a complex triangular matrix.
            </summary>
            <param name="norm">A <see cref="T:Extreme.Mathematics.MatrixNorm"/> value that specifies which norm to use in the expression for the condition number.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix is upper
            or lower triangular.</param>
            <param name="diag">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that indicates whether the matrix is unit diagonal.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            Factors a symmetric positive definite matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            Computes the inverse of a factored hermitian matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            Solves a hermitian system of equations.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="nrhs">The number of right hand sides.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="b">A complex array that contains the components of the right-hand side(s).</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
            <summary>
            Estimates the reciprocal of the condition number of a factored hermitian matrix.
            </summary>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that indicates whether the matrix components
            are stored in the upper or lower triangular part.</param>
            <param name="n">The number of rows and columns of the matrix.</param>
            <param name="a">A complex array that contains the elements of the matrix.</param>
            <param name="aNorm">The norm of the matrix.</param>
            <param name="rcond">On return, an estimate for the reciprocal of the condition number of the matrix.</param>
            <param name="info">On return, indicates error conditions.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The form of the
            factorization is
               A = U*D*U<sup>H</sup>  or  A = L*D*L<sup>H</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            If UPLO = 'U', then A = U*D*U<sup>H</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>H</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="b">
            <pre>
            B is complex array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U<sup>H</sup> or A = L*D*L<sup>H</sup> computed by
            ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if <paramref name="info"/> = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U<sup>H</sup> or
            A = L*D*L<sup>H</sup> computed by ZHETRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>H</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>H</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is complex array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
            </summary>
            <param name="jobz">
            <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>H</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>H</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V<sup>H</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>H</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>H</sup> are computed.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the input matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the input matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V<sup>H</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="s">
            <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </pre>
            </param>
            <param name="u">
            <pre>
            U is COMPLEX*16 array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </pre>
            <pre>
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU >= M.
            </pre>
            </param>
            <param name="vt">
            <pre>
            VT is COMPLEX*16 array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N unitary matrix V<sup>H</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>H</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
            <pre>
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit.
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value.
            > 0:  The updating process of DBDSDC did not converge.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>H</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.HermitianEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
            </summary>
            <param name="jobz">
            <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
            </param>
            <param name="uplo">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if <paramref name="info"/> = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            Dimension (N)
            If <paramref name="info"/> = 0, the eigenvalues in ascending order.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if <paramref name="info"/> = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns <paramref name="info"/>/(N+1) through
                  mod(<paramref name="info"/>,N+1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
             Modified description of <paramref name="info"/>. Sven, 16 Feb 05.
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N complex non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </pre>
            </param>
            <param name="jobvr">
            <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A. N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            W is COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues.
            </pre>
            </param>
            <param name="vl">
            <pre>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </pre>
            <pre>
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </pre>
            </param>
            <param name="vr">
            <pre>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </pre>
            <pre>
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value.
            > 0:  if <paramref name="info"/> = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A<sup>T</sup> * X = B,  or  A<sup>H</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if <paramref name="info"/> = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>H</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>H</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> computed by ZPBTRF.</para>
            </summary>
            <param name="uplo">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup> *U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U<sup>H</sup>*U or A = L*L<sup>H</sup> computed by
            ZPBTRF.</para>
            </summary>
            <param name="uplo">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>H</sup>*U or A = L*L<sup>H</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            </remarks>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Name">
            <summary>
            Gets the name of the implementation.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.Platform">
            <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGETRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by DGETRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DGETRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUInvert(System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by DGETRF.</para>
            </summary>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if <paramref name="info"/> = 0, the inverse of the original matrix A.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices from DGETRF; for 1&lt;=i&lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGETRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            real matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by DGETRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGECON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v<sup>T</sup>
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGEQRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </pre>
            <pre>
            The leading dimension of the array A. LDA >= max(1,M).
            </pre>
            </param>
            <param name="jpvt">
            <pre>
            Dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit.
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v<sup>T</sup>
            where tau is a real/complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGEQP3</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.QROrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q<sup>T</sup> * C       C * Q<sup>T</sup>
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <pre>
            = 'L': apply Q or Q<sup>T</sup> from the Left;
            = 'R': apply Q or Q<sup>T</sup> from the Right.
            </pre>
            </param>
            <param name="trans">
            <pre>
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q<sup>T</sup>.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the matrix C. M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix C. N >= 0.
            </pre>
            </param>
            <param name="k">
            <pre>
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </pre>
            <pre>
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </pre>
            </param>
            <param name="tau">
            <pre>
            Dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </pre>
            </param>
            <param name="c">
            <pre>
            Dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q<sup>T</sup>*C or C*Q<sup>T</sup> or C*Q.
            </pre>
            <pre>
            The leading dimension of the array C. LDC >= max(1,M).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            . . H(k)
            as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DORMQR</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The form of the
            factorization is
               A = U*D*U<sup>T</sup>  or  A = L*D*L<sup>T</sup>
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            If UPLO = 'U', then A = U*D*U<sup>T</sup>, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L<sup>T</sup>, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U<sup>T</sup> or
            A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DSYTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by
            DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if <paramref name="info"/> = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DSYTRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U<sup>T</sup> or A = L*D*L<sup>T</sup> computed by DSYTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U<sup>T</sup>;
            = 'L':  Lower triangular, form is A = L*D*L<sup>T</sup>.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the Level 3 BLAS version of the algorithm.
            </pre>
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if <paramref name="info"/> = 0, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            A check is made to verify that A is nonsingular.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTRTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTRCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            The 1-norm (or infinity-norm) of the symmetric matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPOCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if <paramref name="info"/> = 0, the factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>T</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>T</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPOTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric positive definite
            matrix A using the Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>
            computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by
            DPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DPOTRI</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPOTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup>, as computed by DPOTRF.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DPOTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SingularValueDecompose(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.</para>
            </summary>
            <param name="jobz">
            <pre>
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V<sup>T</sup> are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V<sup>T</sup> are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    on the array A and all rows of V<sup>T</sup> are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V<sup>T</sup> are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V<sup>T</sup> are computed.
            </pre>
            </param>
            <param name="m">
            <pre>
            The number of rows of the input matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the input matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V<sup>T</sup> (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,M).
            </pre>
            </param>
            <param name="s">
            <pre>
            Dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </pre>
            </param>
            <param name="u">
            <pre>
            Dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </pre>
            <pre>
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &lt; N, LDU >= M.
            </pre>
            </param>
            <param name="vt">
            <pre>
            Dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N orthogonal matrix V<sup>T</sup>;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V<sup>T</sup> (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &lt; N, or JOBZ = 'N', VT is not referenced.
            </pre>
            <pre>
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit.
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value.
            > 0:  DBDSDC did not converge, updating process failed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                 A = U * SIGMA * transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V<sup>T</sup>, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <pre>
            The number of rows of the matrix A.  M >= 0.
            </pre>
            </param>
            <param name="n">
            <pre>
            The number of columns of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&lt;=i&lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (min(M,N))
            The pivot indices; for 1 &lt;= i &lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0: successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0: if <paramref name="info"/> = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>?GBTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A<sup>T</sup> * X = B
            with a general band matrix A using the LU factorization computed
            by DGBTRF.</para>
            </summary>
            <param name="trans">
            <pre>
            Specifies the form of the system of equations.
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup>* X = B  (Transpose)
            = 'C':  A<sup>T</sup>* X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>DGBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by DGBTRF.</para>
            </summary>
            <param name="norm">
            <pre>
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kl">
            <pre>
            The number of subdiagonals within the band of A.  KL >= 0.
            </pre>
            </param>
            <param name="ku">
            <pre>
            The number of superdiagonals within the band of A.  KU >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </pre>
            </param>
            <param name="ipiv">
            <pre>
            Dimension (N)
            The pivot indices; for 1 &lt;= i &lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </pre>
            </param>
            <param name="anorm">
            <pre>
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0: if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DGBCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandTriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A<sup>T</sup> * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </pre>
            </param>
            <param name="trans">
            <pre>
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A<sup>T</sup> * X = B  (Transpose)
            = 'C':  A<sup>H</sup> * X = B  (Conjugate transpose = Transpose)
            </pre>
            </param>
            <param name="diag">
            <pre>
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if <paramref name="info"/> = 0, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            A check is made to verify that A is nonsingular.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DTBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&lt;=i&lt;=min(n,j+kd).
            On exit, if <paramref name="info"/> = 0, the triangular factor U or L from the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band
            matrix A, in the same storage format as A.
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The factorization has the form
               A = U<sup>T</sup> * U,  if UPLO = 'U', or
               A = L  * L<sup>T</sup>,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </pre>
            </para>
            <h4> Further Details:</h4>
            <para>
            <pre>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPBTRF</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="nrhs">
            <pre>
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="b">
            <pre>
            Dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </pre>
            <pre>
            The leading dimension of the array B.  LDB >= max(1,N).
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>This method corresponds to the LAPACK routine <c>?PBTRS</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U<sup>T</sup>*U or A = L*L<sup>T</sup> computed by DPBTRF.</para>
            </summary>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="kd">
            <pre>
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </pre>
            </param>
            <param name="ab">
            <pre>
            Dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U<sup>T</sup>*U or A = L*L<sup>T</sup> of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&lt;=i&lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&lt;=i&lt;=min(n,j+kd).
            </pre>
            <pre>
            The leading dimension of the array AB.  LDAB >= KD+1.
            </pre>
            </param>
            <param name="aNorm">
            <pre>
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </pre>
            </param>
            <param name="rcond">
            <pre>
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>DPBCON</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.SymmetricEigenvalueDecompose(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
            </summary>
            <param name="jobz">
            <pre>
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </pre>
            </param>
            <param name="storedTriangle">
            <pre>
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A.  N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if <paramref name="info"/> = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="w">
            <pre>
            Dimension (N)
            If <paramref name="info"/> = 0, the eigenvalues in ascending order.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value
            > 0:  if <paramref name="info"/> = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if <paramref name="info"/> = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the sub-matrix
                  lying in rows and columns <paramref name="info"/>/(N+1) through
                  mod(<paramref name="info"/>,N+1).
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, DSYEVD needs N**2 more
            workspace than DSYEVX.
            </pre>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of <paramref name="info"/>. Sven, 16 Feb 05. \n
            </para>
            <para>This method corresponds to the LAPACK routine <c>DSYEVD</c>.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1.EigenvalueDecompose(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N real non-symmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <pre>
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </pre>
            </param>
            <param name="jobvr">
            <pre>
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </pre>
            </param>
            <param name="n">
            <pre>
            The order of the matrix A. N >= 0.
            </pre>
            </param>
            <param name="a">
            <pre>
            Dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </pre>
            <pre>
            The leading dimension of the array A.  LDA >= max(1,N).
            </pre>
            </param>
            <param name="wr">
            <pre>
            Dimension (N)
            </pre>
            </param>
            <param name="wi">
            <pre>
            Dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </pre>
            </param>
            <param name="vl">
            <pre>
            Dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </pre>
            <pre>
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </pre>
            </param>
            <param name="vr">
            <pre>
            Dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </pre>
            <pre>
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </pre>
            </param>
            <param name="info">
            <pre>
            <paramref name="info"/> is INTEGER
            = 0:  successful exit
            &lt; 0:  if <paramref name="info"/> = -i, the i-th argument had an illegal value.
            > 0:  if <paramref name="info"/> = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**T * A = lambda(j) * u(j)**T
            where u(j)**T denotes the transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </pre>
            </para>
            <para>This method corresponds to the LAPACK routine <c>?GEEV</c>.</para>
            </remarks>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1">
            <summary>
            Implements the sparse BLAS (Basic Linear Algebra Subroutines) for
            generic element types.
            </summary>
            <typeparam name="T">The element type of the arrays.</typeparam>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Name">
            <summary>
            Gets the name of the implementation.
            </summary>
        </member>
        <member name="P:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.Platform">
            <summary>
            Gets the processor architecture supported by the implementation.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.#ctor">
            <summary>
            Constructs a new <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.ManagedSparseLinearAlgebraOperations"/> object.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array2D{`0})">
            <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
            <param name="transA"></param>
            <param name="m">The number of rows in the matrix A.</param>
            <param name="n">The number of columns in the matrix C.</param>
            <param name="k">The number of columns in the matric A.</param>
            <param name="alpha">The multiplier for the matrix product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that specifies the structural properties
            of the matrix A</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
            <param name="a">A <see cref="T:System.Double"/> array that contains the values of the elements of the
            matrix A.</param>
            <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a"/>.</param>
            <param name="aPointerB">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> of the first element of each column.</param>
            <param name="aPointerE">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> past the last element of each column.</param>
            <param name="b">A <see cref="T:System.Double"/> array that contains the components of the dense matrix.</param>
            <param name="beta">Multiplier for the matrix C.</param>
            <param name="c">A <see cref="T:System.Double"/> array that contains the components of the (dense) result matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0})">
            <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Multiplies a matrix in compressed sparse column format with a dense matrix.
            </summary>
            <param name="transA"></param>
            <param name="m">The number of rows in the matrix A.</param>
            <param name="n">The number of columns in the matrix C.</param>
            <param name="k">The number of columns in the matric A.</param>
            <param name="alpha">The multiplier for the matrix product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that specifies the structural properties
            of the matrix A</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/> value that specifies whether the
            upper or lower triangular part of the matrix is used.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/> value that specifies whether the
            diagonal of the sparse matrix contains all 1's.</param>
            <param name="a">A <see cref="T:System.Double"/> array that contains the values of the elements of the
            matrix A.</param>
            <param name="aRows">An integer array that contains the row indexes corresponding to the values in
            <paramref name="a"/>.</param>
            <param name="aPointerB">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> of the first element of each column.</param>
            <param name="aPointerE">An integer array that specifies the index into <paramref name="a"/> and
            <paramref name="aRows"/> past the last element of each column.</param>
            <param name="b">A <see cref="T:System.Double"/> array that contains the components of the dense matrix.</param>
            <param name="beta">Multiplier for the matrix C.</param>
            <param name="c">A <see cref="T:System.Double"/> array that contains the components of the (dense) result matrix.</param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <inheritdoc/>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,`0,Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,`0[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            
            </summary>
            <param name="transA"></param>
            <param name="m"></param>
            <param name="n"></param>
            <param name="alpha"></param>
            <param name="structure"></param>
            <param name="storedTriangle"></param>
            <param name="matrixDiagonal"></param>
            <param name="a"></param>
            <param name="aRows"></param>
            <param name="aPointerB"></param>
            <param name="aPointerE"></param>
            <param name="b"></param>
            <param name="c"></param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.MultiplyAndAddInPlace(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Multiplies a dense vector by a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="k">The number of columns in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="beta">The scalar used to multiply <paramref name="y"/>.
            </param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.GenericSparseLinearAlgebraOperations`1.TriangularSolve(Extreme.Mathematics.TransposeOperation,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.MatrixStructure,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.Complex{`0}[],System.Int32[],System.Int32[],System.Int32[],Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            Solves for a dense vector for a sparse matrix in Compressed Sparse Column (CSC) format.
            </summary>
            <param name="transA">Specifies the operation to be
            performed on the matrix <paramref name="a"/>.</param>
            <param name="m">The number of rows in the matrix <paramref name="a"/>.</param>
            <param name="alpha">The scalar used to multiply the
            matrix-vector product.</param>
            <param name="structure">A <see cref="T:Extreme.Mathematics.MatrixStructure"/> value that
            specifies the structure of the matrix.</param>
            <param name="storedTriangle">A <see cref="T:Extreme.Mathematics.MatrixTriangle"/>
            value that specifies whether the matrix is upper or lower triangular.</param>
            <param name="matrixDiagonal">A <see cref="T:Extreme.Mathematics.MatrixDiagonal"/>
            value that indicates whether the diagonal elements
            are all 1 or not.</param>
            <param name="a">Reference to the first element in a
            one-dimensional array that contains the elements of the
            matrix.</param>
            <param name="aRows">Integer array that contains the 1-based row indices of the corresponding elements
            of <paramref name="a"/>.</param>
            <param name="aPointerB">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="aPointerE">Integer array of length <paramref name="m"/> containing the 1-based
            indices into <paramref name="a"/> of the first component of each column.</param>
            <param name="x">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="x"/>.</param>
            <param name="y">A reference to a one-dimensional array
            containing the elements of the vector <paramref name="y"/>.
            The elements of <paramref name="y"/> are overwritten with
            the result.
            </param>
        </member>
        <member name="T:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1">
            <summary>
            Implements a subset of the LAPACK linear algebra package
            for generic element types.
            </summary>
            <typeparam name="T">The element type of the arrays.</typeparam>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zdrscl(System.Int32,`0,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Multiplies an n-element complex vector x by the real scalar
            1/a.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of components of the vector x.
            </code>
            </param>
            <param name="sa">
            <code>
            SA is DOUBLE PRECISION
            The scalar a which is used to divide each component of x.
            SA must be >= 0, or the subroutine will divide by zero.
            </code>
            </param>
            <param name="sx">
            <code>
            SX is COMPLEX*16 array, dimension
                           (1+(N-1)*abs(INCX))
            The n-element vector x.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector SX.
            > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1&amp;lt; i&amp;lt;= n
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlacn2(System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},`0@,System.Int32@,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Estimates the 1-norm of a square, complex matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (N)
            On the final return, V = A*W,  where  EST = norm(V)/norm(W)
            (W is not returned).
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (N)
            On an intermediate return, X should be overwritten by
                  A * X,   if KASE=1,
                  A**H * X,  if KASE=2,
            where A**H is the conjugate transpose of A, and ZLACN2 must be
            re-called with all the other parameters unchanged.
            </code>
            </param>
            <param name="est">
            <code>
            EST is DOUBLE PRECISION
            On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
            unchanged from the previous call to ZLACN2.
            On exit, EST is an estimate (a lower bound) for norm(A).
            </code>
            </param>
            <param name="kase">
            <code>
            KASE is INTEGER
            On the initial call to ZLACN2, KASE should be 0.
            On an intermediate return, KASE will be 1 or 2, indicating
            whether X should be overwritten by A * X  or A**H * X.
            On the final return from ZLACN2, KASE will again be 0.
            </code>
            </param>
            <param name="isave">
            <code>
            ISAVE is INTEGER array, dimension (3)
            ISAVE is used to save variables between calls to ZLACN2
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Reverse communication is used for evaluating matrix-vector products.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Originally named CONEST, dated March 16, 1988.
            Last modified:  April, 1999
            This is a thread safe version of ZLACON, which uses the array ISAVE
            in place of a SAVE statement, as follows:
               ZLACON     ZLACN2
                JUMP     ISAVE(1)
                J        ISAVE(2)
                ITER     ISAVE(3)
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Nick Higham, University of Manchester
            </para>
            <h4> References:</h4>
            <para>
             N.J. Higham, "FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation",
             ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zladiv(Extreme.Mathematics.Complex{`0},Extreme.Mathematics.Complex{`0})">
            <summary>
            <para>
            := X / Y, where X and Y are complex.</para>
            </summary>
            <param name="x">
            <code>
            X is COMPLEX*16
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX*16
            The complex scalars X and Y.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The computation of X / Y
            will not overflow on an intermediary step unless the results
            overflows.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlatbs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},`0@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b     (No transpose)
            = 'T':  Solve A**T * x = s*b  (Transpose)
            = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of subdiagonals or superdiagonals in the
            triangular matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first KD+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is DOUBLE PRECISION array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine ZTBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, ZTBSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine ZTBSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T *x = b  or
            A**H *x = b.  The basic algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call ZTBSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaswp(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Performs a series of row interchanges on the matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the matrix of column dimension N to which the row
            interchanges will be applied.
            On exit, the permuted matrix.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            </code>
            </param>
            <param name="k1">
            <code>
            K1 is INTEGER
            The first element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="k2">
            <code>
            K2 is INTEGER
            The last element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (K2*abs(INCX))
            The vector of pivot indices.  Only the elements in positions
            K1 through K2 of IPIV are accessed.
            IPIV(K) = L implies rows K and L are to be interchanged.
            </code>
            </param>
            <param name="incx">
            <code>
            INCX is INTEGER
            The increment between successive values of IPIV.  If IPIV
            is negative, the pivots are applied in reverse order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            One row interchange is initiated for each of rows K1 through K2 of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by
             R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlacgv(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Conjugates a complex vector of length N.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vector X.  N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension
                           (1+(N-1)*abs(INCX))
            On entry, the vector of length N to be conjugated.
            On exit, X is overwritten with conjg(X).
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive elements of X.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlatrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},`0@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b,
            with scaling to prevent overflow.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b     (No transpose)
            = 'T':  Solve A**T * x = s*b  (Transpose)
            = 'C':  Solve A**H * x = s*b  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max (1,N).
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            The scaling factor s for the triangular system
               A * x = s*b,  A**T * x = s*b,  or  A**H * x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is DOUBLE PRECISION array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, A**H denotes the
            conjugate transpose of A, x and b are n-element vectors, and s is a
            scaling factor, usually less than or equal to 1, chosen so that the
            components of x will be less than the overflow threshold.  If the
            unscaled problem will not cause overflow, the Level 2 BLAS routine
            ZTRSV is called. If the matrix A is singular (A(j,j) = 0 for some j),
            then s is set to 0 and a non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, ZTRSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine ZTRSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T *x = b  or
            A**H *x = b.  The basic algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]' * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]' * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call ZTRSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlarf(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Applies a complex elementary reflector H to a complex M-by-N
            matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.
            </code>
            <code>
            INCV is INTEGER
            The increment between elements of v. INCV &amp;lt;> 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the
            form
                  H = I - tau * v * v**H
            where tau is a complex scalar and v is a complex vector.
            If tau = 0, then H is taken to be the unit matrix.
            To apply H**H, supply conjg(tau) instead
            tau.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlarfg(System.Int32,Extreme.Mathematics.Complex{`0}@,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0}@)">
            <summary>
            <para>
            Generates a complex elementary reflector H of order n, such
            that
                  H**H * ( alpha ) = ( beta ),   H**H * H = I.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the elementary reflector.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is COMPLEX*16
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.
            </code>
            <code>
            INCX is INTEGER
            The increment between elements of X. INCX > 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16
            The value tau.
            </code>
            </param>
            <remarks>
            <para>
            <code>
                         (   x   )   (   0  )
            where alpha and beta are scalars, with beta real, and x is an
            (n-1)-element complex vector. H is represented in the form
                  H = I - tau * ( 1 ) * ( 1 v**H ) ,
                                ( v )
            where tau is a complex scalar and v is a complex (n-1)-element
            vector. Note that H is not hermitian.
            If the elements of x are all zero and alpha is real, then tau = 0
            and H is taken to be the unit matrix.
            Otherwise  1 &amp;lt;= real(tau) &amp;lt;= 2  and  abs(tau-1) &amp;lt;= 1 .
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlahr2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Reduces the first NB columns of A complex general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K &amp;lt; N.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,NB)
            The upper triangular matrix T.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T.  LDT >= NB.
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX*16 array, dimension (LDY,NB)
            The n-by-nb matrix Y.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= N.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            reduction is performed by an unitary similarity transformation
            Q**H * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**H, and also the matrix Y = A * V * T.
            This is an auxiliary routine called by ZGEHRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of nb elementary reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
            A(i+k+1:n,i), and tau in TAU(i).
            The elements of the vectors v together form the (n-k+1)-by-nb matrix
            V which is needed, with T and Y, to apply the transformation to the
            unreduced part of the matrix, using an update of the form:
            A := (I - V*T*V**H) * (A - Y*V**H).
            The contents of A on exit are illustrated by the following example
            with n = 7, k = 3 and nb = 2:
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( h   h   a   a   a )
               ( v1  h   a   a   a )
               ( v1  v2  a   a   a )
               ( v1  v2  a   a   a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This subroutine is a slight modification of LAPACK-3.0's DLAHRD
            incorporating improvements proposed by Quintana-Orti and Van de
            Gejin. Note that the entries of A(1:K,2:NB) differ from those
            returned by the original LAPACK-3.0's DLAHRD routine. (This
            subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
            </code>
            </para>
            <h4> References:</h4>
            <para>
             Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
             performance of reduction to Hessenberg form," ACM Transactions on
             Mathematical Software, 32(2):180-194, June 2006.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlarfb(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Applies a complex block reflector H or its transpose H**H to a
            complex M-by-N matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply H or H**H from the Left
            = 'R': apply H or H**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply H (No transpose)
            = 'C': apply H**H (Conjugate transpose)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Indicates how H is formed from a product of elementary
            reflectors
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Indicates how the vectors which define the elementary
            reflectors are stored:
            = 'C': Columnwise
            = 'R': Rowwise
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the matrix T (= the number of elementary
            reflectors whose product defines the block reflector).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension
                                  (LDV,K) if STOREV = 'C'
                                  (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                  (LDV,N) if STOREV = 'R' and SIDE = 'R'
            See Further Details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
            if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
            if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,K)
            The triangular K-by-K matrix T in the representation of the
            block reflector.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by H*C or H**H*C or C*H or C*H**H.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (LDWORK,K)
            </code>
            <code>
            LDWORK is INTEGER
            The leading dimension of the array WORK.
            If SIDE = 'L', LDWORK >= max(1,N);
            if SIDE = 'R', LDWORK >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored; the corresponding
            array elements are modified but restored on exit. The rest of the
            array is not used.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlahqr(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Is an auxiliary routine called by CHSEQR to update the
               eigenvalues and Schur decomposition already computed by CHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that H is already upper triangular in rows and
            columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless ILO = 1).
            ZLAHQR works primarily with the Hessenberg submatrix in rows
            and columns ILO to IHI, but applies transformations to all of
            H if WANTT is .TRUE..
            1 &amp;lt;= ILO &amp;lt;= max(1,IHI); IHI &amp;lt;= N.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
            On entry, the upper Hessenberg matrix H.
            On exit, if INFO is zero and if WANTT is .TRUE., then H
            is upper triangular in rows and columns ILO:IHI.  If INFO
            is zero and if WANTT is .FALSE., then the contents of H
            are unspecified on exit.  The output state of H in case
            INF is positive is below under the description of INFO.
            </code>
            <code>
            LDH is INTEGER
            The leading dimension of the array H. LDH >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (N)
            The computed eigenvalues ILO to IHI are stored in the
            corresponding elements of W. If WANTT is .TRUE., the
            eigenvalues are stored in the same order as on the diagonal
            of the Schur form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE..
            1 &amp;lt;= ILOZ &amp;lt;= ILO; IHI &amp;lt;= IHIZ &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,N)
            If WANTZ is .TRUE., on entry Z must contain the current
            matrix Z of transformations accumulated by CHSEQR, and on
            exit Z has been updated; transformations are applied only to
            the submatrix Z(ILOZ:IHIZ,ILO:IHI).
            If WANTZ is .FALSE., Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z. LDZ >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
             =   0: successful exit
            .GT. 0: if INFO = i, ZLAHQR failed to compute all the
                    eigenvalues ILO to IHI in a total of 30 iterations
                    per eigenvalue; elements i+1:ihi of W contain
                    those eigenvalues which have been successfully
                    computed.
                    If INFO .GT. 0 and WANTT is .FALSE., then on exit,
                    the remaining unconverged eigenvalues are the
                    eigenvalues of the upper Hessenberg matrix
                    rows and columns ILO thorugh INFO of the final,
                    output value of H.
                    If INFO .GT. 0 and WANTT is .TRUE., then on exit
            (*)       (initial value of H)*U  = U*(final value of H)
                    where U is an orthognal matrix.    The final
                    value of H is upper Hessenberg and triangular in
                    rows and columns INFO+1 through IHI.
                    If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                        (final value of Z)  = (initial value of Z)*U
                    where U is the orthogonal matrix in (*)
                    (regardless of the value of WANTT.)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            <code>
            02-96 Based on modifications by
            David Day, Sandia National Laboratory, USA
            12-04 Further modifications by
            Ralph Byers, University of Kansas, USA
            This is a modified version of ZLAHQR from LAPACK version 3.0.
            It is (1) more robust against overflow and underflow and
            (2) adopts the more conservative Ahues &amp; Tisseur stopping
            criterion (LAWN 122, 1997).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaset(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Mathematics.Complex{`0},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Initializes a 2-D array A to BETA on the diagonal and
            ALPHA on the offdiagonals.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set. The lower triangle
                        is unchanged.
            = 'L':      Lower triangular part is set. The upper triangle
                        is unchanged.
            Otherwise:  All of the matrix A is set.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            On entry, M specifies the number of rows of A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            On entry, N specifies the number of columns of A.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is COMPLEX*16
            All the offdiagonal array elements are set to ALPHA.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is COMPLEX*16
            All the diagonal array elements are set to BETA.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, A(i,j) = ALPHA, 1 &amp;lt;= i &amp;lt;= m, 1 &amp;lt;= j &amp;lt;= n, i.ne.j;
                     A(i,i) = BETA , 1 &amp;lt;= i &amp;lt;= min(m,n)
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlartg(Extreme.Mathematics.Complex{`0},Extreme.Mathematics.Complex{`0},`0@,Extreme.Mathematics.Complex{`0}@,Extreme.Mathematics.Complex{`0}@)">
            <summary>
            <para>
            Generates a plane rotation so that
               [  CS  SN  ]     [ F ]     [ R ]
               [  __      ]  .</para>
            </summary>
            <param name="f">
            <code>
            F is COMPLEX*16
            The first component of vector to be rotated.
            </code>
            </param>
            <param name="g">
            <code>
            G is COMPLEX*16
            The second component of vector to be rotated.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is DOUBLE PRECISION
            The cosine of the rotation.
            </code>
            </param>
            <param name="sn">
            <code>
            SN is COMPLEX*16
            The sine of the rotation.
            </code>
            </param>
            <param name="r">
            <code>
            R is COMPLEX*16
            The nonzero component of the rotated vector.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            [   ]  =  [   ]   where CS**2 + |SN|**2 = 1.
               [ -SN  CS  ]     [ G ]     [ 0 ]
            This is a faster version of the BLAS1 routine ZROTG, except for
            the following differences:
               F and G are unchanged on return.
               If G=0, then CS=1 and SN=0.
               If F=0, then CS=0 and SN is chosen so that R is real.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            3-5-96 - Modified with a new algorithm by W. Kahan and J. Demmel
            This version has a few statements commented out for thread safety
            (machine parameters are computed on each entry). 10 feb 03, SJH.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zrot(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},`0,Extreme.Mathematics.Complex{`0})">
            <summary>
            <para>
            Applies a plane rotation, where the cos (C) is real and the
            sin (S) is complex, and the vectors CX and CY are complex.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vectors CX and CY.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX*16 array, dimension (N)
            On input, the vector X.
            On output, CX is overwritten with C*X + S*Y.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of CY.  INCX &amp;lt;> 0.
            </code>
            </param>
            <param name="cy">
            <code>
            CY is COMPLEX*16 array, dimension (N)
            On input, the vector Y.
            On output, CY is overwritten with -CONJG(S)*X + C*Y.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive values of CY.  INCX &amp;lt;> 0.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            </code>
            </param>
            <param name="s">
            <code>
            S is COMPLEX*16
            C and S define a rotation
               [  C          S  ]
               [ -conjg(S)   C  ]
            where C*C + S*CONJG(S) = 1.0.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlarft(System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Forms the triangular factor T of a complex block reflector H
            of order n, which is defined as a product of k elementary reflectors.</para>
            </summary>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the block reflector H. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
            If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and
               H  =  I - V * T * V**H
            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and
               H  =  I - V**H * T * V
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32)">
            <summary>
            <para>
            Is identical to ZLAQR3 except that it avoids
               recursion by calling ZLAHQR instead of ZLAQR4.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the unitary matrix Z is updated so
            so that the unitary Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the unitary matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by a unitary
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the unitary
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sh">
            <code>
            SH is COMPLEX*16 array, dimension KBOT
            On output, approximate eigenvalues that may
            be used for shifts are stored in SH(KBOT-ND-NS+1)
            through SR(KBOT-ND).  Converged eigenvalues are
            stored in SH(KBOT-ND+1) through SH(KBOT).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX*16 array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; ZLAQR2
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Aggressive early deflation:
               ZLAQR2 accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr1(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Mathematics.Complex{`0},Extreme.Mathematics.Complex{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            A 2-by-2 or 3-by-3 matrix H, ZLAQR1 sets v to a
                 scalar multiple of the first column of the product
                 (*)  K = (H - s1*I)*(H - s2*I)
                 scaling to avoid overflows and most underflows.</para>
            </summary>
            <param name="n">
            <code>
            N is integer
                Order of the matrix H. N must be either 2 or 3.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array of dimension (LDH,N)
                The 2-by-2 or 3-by-3 matrix H in (*).
            </code>
            <code>
            LDH is integer
                The leading dimension of H as declared in
                the calling procedure.  LDH.GE.N
            </code>
            </param>
            <param name="s1">
            <code>
            S1 is COMPLEX*16
            </code>
            </param>
            <param name="s2">
            <code>
            S2 is COMPLEX*16
            S1 and S2 are the shifts defining K in (*) above.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array of dimension N
                A scalar multiple of the first column of the
                matrix K in (*).
            </code>
            </param>
            <remarks>
            <para>
            <code>
                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr5(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Called by ZLAQR0, performs a
               single small-bulge multi-shift QR sweep.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is logical scalar
               WANTT = .true. if the triangular Schur factor
               is being computed.  WANTT is set to .false. otherwise.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is logical scalar
               WANTZ = .true. if the unitary Schur factor is being
               computed.  WANTZ is set to .false. otherwise.
            </code>
            </param>
            <param name="kacc22">
            <code>
            KACC22 is integer with value 0, 1, or 2.
               Specifies the computation mode of far-from-diagonal
               orthogonal updates.
            = 0: ZLAQR5 does not accumulate reflections and does not
                 use matrix-matrix multiply to update far-from-diagonal
                 matrix entries.
            = 1: ZLAQR5 accumulates reflections and uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries.
            = 2: ZLAQR5 accumulates reflections, uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries,
                 and takes advantage of 2-by-2 block structure during
                 matrix multiplies.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
               N is the order of the Hessenberg matrix H upon which this
               subroutine operates.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is integer scalar
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is integer scalar
               These are the first and last rows and columns of an
               isolated diagonal block upon which the QR sweep is to be
               applied. It is assumed without a check that
                         either KTOP = 1  or   H(KTOP,KTOP-1) = 0
               and
                         either KBOT = N  or   H(KBOT+1,KBOT) = 0.
            </code>
            </param>
            <param name="nshfts">
            <code>
            NSHFTS is integer scalar
               NSHFTS gives the number of simultaneous shifts.  NSHFTS
               must be positive and even.
            </code>
            </param>
            <param name="s">
            <code>
            S is COMPLEX*16 array of size (NSHFTS)
               S contains the shifts of origin that define the multi-
               shift QR sweep.  On output S may be reordered.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array of size (LDH,N)
               On input H contains a Hessenberg matrix.  On output a
               multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
               to the isolated diagonal block in rows and columns KTOP
               through KBOT.
            </code>
            <code>
            LDH is integer scalar
               LDH is the leading dimension of H just as declared in the
               calling procedure.  LDH.GE.MAX(1,N).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
               Specify the rows of Z to which transformations must be
               applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array of size (LDZ,IHI)
               If WANTZ = .TRUE., then the QR Sweep unitary
               similarity transformation is accumulated into
               Z(ILOZ:IHIZ,ILO:IHI) from the right.
               If WANTZ = .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer scalar
               LDA is the leading dimension of Z just as declared in
               the calling procedure. LDZ.GE.N.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array of size (LDV,NSHFTS/2)
            </code>
            <code>
            LDV is integer scalar
               LDV is the leading dimension of V as declared in the
               calling procedure.  LDV.GE.3.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX*16 array of size
               (LDU,3*NSHFTS-3)
            </code>
            <code>
            LDU is integer scalar
               LDU is the leading dimension of U just as declared in the
               in the calling subroutine.  LDU.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
               NH is the number of columns in array WH available for
               workspace. NH.GE.1.
            </code>
            </param>
            <param name="wh">
            <code>
            WH is COMPLEX*16 array of size (LDWH,NH)
            </code>
            <code>
            LDWH is integer scalar
               Leading dimension of WH just as declared in the
               calling procedure.  LDWH.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer scalar
               NV is the number of rows in WV agailable for workspace.
               NV.GE.1.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX*16 array of size
               (LDWV,3*NSHFTS-3)
            </code>
            <code>
            LDWV is integer scalar
               LDWV is the leading dimension of WV as declared in the
               in the calling subroutine.  LDWV.GE.NV.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr4(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Implements one level of recursion for ZLAQR0.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to ZGEBAL, and then passed to ZGEHRD when the
             matrix output by ZGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H
             contains the upper triangular matrix T from the Schur
             decomposition (the Schur form). If INFO = 0 and WANT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (N)
             The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
             in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then ZLAQR4 does a workspace query.
             In this case, ZLAQR4 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, ZLAQR4 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is a complete implementation of the small bulge multi-shift
            QR algorithm.  It may be called by ZLAQR0 and, for large enough
            deflation window size, it may be called by ZLAQR3.  This
            subroutine is identical to ZLAQR0 except that it calls ZLAQR2
            instead of ZLAQR3.
            ZLAQR4 computes the eigenvalues of a Hessenberg matrix H
            and, optionally, the matrices T and Z from the Schur decomposition
            H = Z T Z**H, where T is an upper triangular matrix (the
            Schur form), and Z is the unitary matrix of Schur vectors.
            Optionally Z may be postmultiplied into an input unitary
            matrix Q so that this routine can give the Schur factorization
            of a matrix A which has been reduced to the Hessenberg form H
            by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr3(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32)">
            <summary>
            <para>
            Early deflation:
               ZLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an unitary similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the unitary matrix Z is updated so
            so that the unitary Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the unitary matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by a unitary
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the unitary
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sh">
            <code>
            SH is COMPLEX*16 array, dimension KBOT
            On output, approximate eigenvalues that may
            be used for shifts are stored in SH(KBOT-ND-NS+1)
            through SR(KBOT-ND).  Converged eigenvalues are
            stored in SH(KBOT-ND+1) through SH(KBOT).
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is COMPLEX*16 array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension LWORK.
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; ZLAQR3
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an unitary similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqr0(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to ZGEBAL, and then passed to ZGEHRD when the
             matrix output by ZGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H
             contains the upper triangular matrix T from the Schur
             decomposition (the Schur form). If INFO = 0 and WANT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (N)
             The computed eigenvalues of H(ILO:IHI,ILO:IHI) are stored
             in W(ILO:IHI). If WANTT is .TRUE., then the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then ZLAQR0 does a workspace query.
             In this case, ZLAQR0 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, ZLAQR0 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlascl(System.Char,System.Int32,System.Int32,`0,`0,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Multiplies the M by N complex matrix A by the real scalar
            CTO/CFROM.</para>
            </summary>
            <param name="type">
            <code>
            TYPE is CHARACTER*1
            TYPE indices the storage type of the input matrix.
            = 'G':  A is a full matrix.
            = 'L':  A is a lower triangular matrix.
            = 'U':  A is an upper triangular matrix.
            = 'H':  A is an upper Hessenberg matrix.
            = 'B':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the lower
                    half stored.
            = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the upper
                    half stored.
            = 'Z':  A is a band matrix with lower bandwidth KL and upper
                    bandwidth KU. See ZGBTRF for storage details.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The lower bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The upper bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="cfrom">
            <code>
            CFROM is DOUBLE PRECISION
            </code>
            </param>
            <param name="cto">
            <code>
            CTO is DOUBLE PRECISION
            The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
            without over/underflow if the final result CTO*A(I,J)/CFROM
            can be represented without over/underflow.  CFROM must be
            nonzero.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The matrix to be multiplied by CTO/CFROM.  See TYPE for the
            storage type.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            0  - successful exit
            &amp;lt;0 - if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without over/underflow as long as the final
            result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
            A may be full, upper triangular, lower triangular, upper Hessenberg,
            or banded.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlassq(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},`0@,`0@)">
            <summary>
            <para>
            Returns the values scl and ssq such that
               ( scl**2 )*ssq = x( 1 )**2 +.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements to be used from the vector X.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (N)
            The vector x as described above.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &amp;lt;= i &amp;lt;= n.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector X.
            INCX > 0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with the value  scl .
            </code>
            </param>
            <param name="sumsq">
            <code>
            SUMSQ is DOUBLE PRECISION
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with the value  ssq .
            </code>
            </param>
            <remarks>
            <para>
            <code>
            where x( i ) = abs( X( 1 + ( i - 1 )*INCX ) ). The value of sumsq is
            assumed to be at least unity and the value of ssq will then satisfy
               1.0 .le. ssq .le. ( sumsq + 2*n ).
            scale is assumed to be non-negative and scl returns the value
               scl = max( scale, abs( real( x( i ) ) ), abs( aimag( x( i ) ) ) ),
                      i
            scale and sumsq must be supplied in SCALE and SUMSQ respectively.
            SCALE and SUMSQ are overwritten by scl and ssq respectively.
            The routine makes only one pass through the vector X.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in ZLANGE as described
            above.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            ZLANGE is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            ZLANGE is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            ZLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqp2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0.
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of the matrix A that must be pivoted
            but no factorized. OFFSET >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
            the triangular factor obtained; the elements in block
            A(OFFSET+1:M,1:N) below the diagonal, together with the
            array TAU, represent the orthogonal matrix Q as a product of
            elementary reflectors. Block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is DOUBLE PRECISION array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is DOUBLE PRECISION array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaqps(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Computes a step of QR factorization with column pivoting
            of a complex M-by-N matrix A by using Blas-3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of A that have been factorized in
            previous steps.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to factorize.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns actually factorized.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, block A(OFFSET+1:M,1:KB) is the triangular
            factor obtained and block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
            been updated.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            JPVT(I) = K &amp;lt;==> Column K of the full matrix A has been
            permuted into position I in AP.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (KB)
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is DOUBLE PRECISION array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is DOUBLE PRECISION array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="auxv">
            <code>
            AUXV is COMPLEX*16 array, dimension (NB)
            Auxiliar vector.
            </code>
            </param>
            <param name="f">
            <code>
            F is COMPLEX*16 array, dimension (LDF,NB)
            Matrix F**H = L * Y**H * A.
            </code>
            <code>
            LDF is INTEGER
            The leading dimension of the array F. LDF >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.
            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.
            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlabrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Reduces the first NB rows and columns of a complex general
            m by n matrix A to upper or lower real bidiagonal form by a unitary
            transformation Q**H * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of leading rows and columns of A to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the unitary matrix P as a product
              of elementary reflectors.
            If m &amp;lt; n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the unitary
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX*16 array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX*16 array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX*16 array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, A is reduced to upper bidiagonal form; if m &amp;lt; n, to lower
            bidiagonal form.
            This is an auxiliary routine called by ZGEBRD
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
               Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors.
            If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
            A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The elements of the vectors v and u together form the m-by-nb matrix
            V and the nb-by-n matrix U**H which are needed, with X and Y, to apply
            the transformation to the unreduced part of the matrix, using a block
            update of the form:  A := A - V*Y**H - X*U**H.
            The contents of A on exit are illustrated by the following examples
            with nb = 2:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
              (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
              (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )
            where a denotes an element of the original matrix which is unchanged,
            vi denotes an element of the vector defining H(i), and ui an element
            of the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlacp2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Copies all or part of a real two-dimensional matrix A to a
            complex matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper trapezium
            is accessed; if UPLO = 'L', only the lower trapezium is
            accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlacrm(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by N and complex; B is N by N and real;
            C is M by N and complex.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A and of the matrix C.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns and rows of the matrix B and
            the number of columns of the matrix C.
            N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            A contains the M by N matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >=max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            B contains the N by N matrix B.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >=max(1,N).
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC, N)
            C contains the M by N matrix C.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >=max(1,N).
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*M*N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlarcm(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Performs a very simple matrix-matrix multiplication:
                     C := A * B,
            where A is M by M and real; B is M by N and complex;
            C is M by N and complex.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A and of the matrix C.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns and rows of the matrix B and
            the number of columns of the matrix C.
            N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA, M)
            A contains the M by M matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >=max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB, N)
            B contains the M by N matrix B.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >=max(1,M).
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC, N)
            C contains the M by N matrix C.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >=max(1,M).
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*M*N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlapmt(System.Boolean,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Rearranges the columns of the M by N matrix X as specified
            by the permutation K(1),K(2),.</para>
            </summary>
            <param name="forwrd">
            <code>
            FORWRD is LOGICAL
            = .TRUE., forward permutation
            = .FALSE., backward permutation
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix X. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix X. N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (LDX,N)
            On entry, the M by N matrix X.
            On exit, X contains the permuted matrix X.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X, LDX >= MAX(1,M).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array, dimension (N)
            On entry, K contains the permutation vector. K is used as
            internal workspace, but reset to its original value on
            output.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If FORWRD = .TRUE.,  forward permutation:
                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
            If FORWRD = .FALSE., backward permutation:
                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlags2(System.Boolean,`0,Extreme.Mathematics.Complex{`0},`0,`0,Extreme.Mathematics.Complex{`0},`0,`0@,Extreme.Mathematics.Complex{`0}@,`0@,Extreme.Mathematics.Complex{`0}@,`0@,Extreme.Mathematics.Complex{`0}@)">
            <summary>
            <para>
            Computes 2-by-2 unitary matrices U, V and Q, such
            that if ( UPPER ) then
                      U**H *A*Q = U**H *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**H*B*Q = V**H *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )
            or if ( .</para>
            </summary>
            <param name="upper">
            <code>
            UPPER is LOGICAL
            = .TRUE.: the input matrices A and B are upper triangular.
            = .FALSE.: the input matrices A and B are lower triangular.
            </code>
            </param>
            <param name="a1">
            <code>
            A1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="a2">
            <code>
            A2 is COMPLEX*16
            </code>
            </param>
            <param name="a3">
            <code>
            A3 is DOUBLE PRECISION
            On entry, A1, A2 and A3 are elements of the input 2-by-2
            upper (lower) triangular matrix A.
            </code>
            </param>
            <param name="b1">
            <code>
            B1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="b2">
            <code>
            B2 is COMPLEX*16
            </code>
            </param>
            <param name="b3">
            <code>
            B3 is DOUBLE PRECISION
            On entry, B1, B2 and B3 are elements of the input 2-by-2
            upper (lower) triangular matrix B.
            </code>
            </param>
            <param name="csu">
            <code>
            CSU is DOUBLE PRECISION
            </code>
            </param>
            <param name="snu">
            <code>
            SNU is COMPLEX*16
            The desired unitary matrix U.
            </code>
            </param>
            <param name="csv">
            <code>
            CSV is DOUBLE PRECISION
            </code>
            </param>
            <param name="snv">
            <code>
            SNV is COMPLEX*16
            The desired unitary matrix V.
            </code>
            </param>
            <param name="csq">
            <code>
            CSQ is DOUBLE PRECISION
            </code>
            </param>
            <param name="snq">
            <code>
            SNQ is COMPLEX*16
            The desired unitary matrix Q.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            NOT.UPPER ) then
                      U**H *A*Q = U**H *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**H *B*Q = V**H *( B1 0  )*Q = ( x  x  )
                                        ( B2 B3 )     ( 0  x  )
            where
              U = (   CSU    SNU ), V = (  CSV    SNV ),
                  ( -SNU**H  CSU )      ( -SNV**H CSV )
              Q = (   CSQ    SNQ )
                  ( -SNQ**H  CSQ )
            The rows of the transformed A and B are parallel. Moreover, if the
            input 2-by-2 matrix A is not zero, then the transformed (1,1) entry
            of A is not zero. If the input matrices A and B are both not zero,
            then the transformed (2,2) element of B is not zero, except when the
            first rows of input A and B are parallel and the second rows are
            zero.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlapll(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}},`0@)">
            <summary>
            <para>
            Two column vectors X and Y, let
                                 A = ( X Y ).</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vectors X and Y.
            </code>
            </param>
            <param name="x">
            <code>
            X is COMPLEX*16 array, dimension (1+(N-1)*INCX)
            On entry, X contains the N-vector X.
            On exit, X is overwritten.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive elements of X. INCX > 0.
            </code>
            </param>
            <param name="y">
            <code>
            Y is COMPLEX*16 array, dimension (1+(N-1)*INCY)
            On entry, Y contains the N-vector Y.
            On exit, Y is overwritten.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive elements of Y. INCY > 0.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is DOUBLE PRECISION
            The smallest singular value of the N-by-2 matrix A = ( X Y ).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztgsja(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@,System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of two complex upper triangular (or trapezoidal) matrices A and B.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  U must contain a unitary matrix U1 on entry, and
                    the product U1*U is returned;
            = 'I':  U is initialized to the unit matrix, and the
                    unitary matrix U is returned;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  V must contain a unitary matrix V1 on entry, and
                    the product V1*V is returned;
            = 'I':  V is initialized to the unit matrix, and the
                    unitary matrix V is returned;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Q must contain a unitary matrix Q1 on entry, and
                    the product Q1*Q is returned;
            = 'I':  Q is initialized to the unit matrix, and the
                    unitary matrix Q is returned;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            K and L specify the subblocks in the input matrices A and B:
            A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,,N-L+1:N)
            of A and B, whose GSVD is going to be computed by ZTGSJA.
            See Further Details.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
            matrix R or part of R.  See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
            a part of R.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is DOUBLE PRECISION
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is DOUBLE PRECISION
            TOLA and TOLB are the convergence criteria for the Jacobi-
            Kogbetliantz iteration procedure. Generally, they are the
            same as used in the preprocessing step, say
                TOLA = MAX(M,N)*norm(A)*MAZHEPS,
                TOLB = MAX(P,N)*norm(B)*MAZHEPS.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = diag(C),
              BETA(K+1:K+L)  = diag(S),
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
              BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
            Furthermore, if K+L &amp;lt; N,
              ALPHA(K+L+1:N) = 0 and
              BETA(K+L+1:N)  = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            On entry, if JOBU = 'U', U must contain a matrix U1 (usually
            the unitary matrix returned by ZGGSVP).
            On exit,
            if JOBU = 'I', U contains the unitary matrix U;
            if JOBU = 'U', U contains the product U1*U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            On entry, if JOBV = 'V', V must contain a matrix V1 (usually
            the unitary matrix returned by ZGGSVP).
            On exit,
            if JOBV = 'I', V contains the unitary matrix V;
            if JOBV = 'V', V contains the product V1*V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
            the unitary matrix returned by ZGGSVP).
            On exit,
            if JOBQ = 'I', Q contains the unitary matrix Q;
            if JOBQ = 'Q', Q contains the product Q1*Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="ncycle">
            <code>
            NCYCLE is INTEGER
            The number of cycles required for convergence.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the procedure does not converge after MAXIT cycles.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On entry, it is assumed that matrices A and B have the following
            forms, which may be obtained by the preprocessing subroutine ZGGSVP
            from a general M-by-N matrix A and P-by-N matrix B:
                         N-K-L  K    L
               A =    K ( 0    A12  A13 ) if M-K-L >= 0;
                      L ( 0     0   A23 )
                  M-K-L ( 0     0    0  )
                       N-K-L  K    L
               A =  K ( 0    A12  A13 ) if M-K-L &amp;lt; 0;
                  M-K ( 0     0   A23 )
                       N-K-L  K    L
               B =  L ( 0     0   B13 )
                  P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.
            On exit,
                   U**H *A*Q = D1*( 0 R ),    V**H *B*Q = D2*( 0 R ),
            where U, V and Q are unitary matrices.
            R is a nonsingular upper triangular matrix, and D1
            and D2 are ``diagonal'' matrices, which are of the following
            structures:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                               K  L
                   D2 = L   ( 0  S )
                        P-L ( 0  0 )
                           N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 ) K
                        L (  0    0   R22 ) L
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                           K M-K K+L-M
                D1 =   K ( I  0    0   )
                     M-K ( 0  C    0   )
                             K M-K K+L-M
                D2 =   M-K ( 0  S    0   )
                     K+L-M ( 0  0    I   )
                       P-L ( 0  0    0   )
                           N-K-L  K   M-K  K+L-M
            ( 0 R ) =    K ( 0    R11  R12  R13  )
                      M-K ( 0     0   R22  R23  )
                    K+L-M ( 0     0    0   R33  )
            where
            C = diag( ALPHA(K+1), ... , ALPHA(M) ),
            S = diag( BETA(K+1),  ... , BETA(M) ),
            C**2 + S**2 = I.
            R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
                (  0  R22 R23 )
            in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The computation of the unitary transformation matrices U, V or Q
            is optional.  These matrices may either be formed explicitly, or they
            may be postmultiplied into input matrices U1, V1, or Q1.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            ZTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
            min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
            matrix B13 to the form:
                     U1**H *A13*Q1 = C1*R1; V1**H *B13*Q1 = S1*R1,
            where U1, V1 and Q1 are unitary matrix.
            C1 and S1 are diagonal matrices satisfying
                          C1**2 + S1**2 = I,
            and R1 is an L-by-L nonsingular upper triangular matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in ZLANTR as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &amp;lt;= N.  When M = 0, ZLANTR is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &amp;lt;= M.  When N = 0, ZLANTR is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            ZLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in ZLANSY as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, ZLANSY is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            ZLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.HermitianMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            complex hermitian matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in ZLANHE as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            hermitian matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, ZLANHE is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The hermitian matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced. Note that the imaginary parts of the diagonal
            elements need not be set and are assumed to be zero.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            ZLANHE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlauu2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**H;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**H * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the unblocked form of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlauum(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**H or L**H * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**H;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**H * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the blocked form of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlahef(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes a partial factorization of a complex Hermitian
            matrix A using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The maximum number of columns of the matrix A that should be
            factored.  NB should be at least 2 to allow for 2-by-2 pivot
            blocks.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns of A that were actually factored.
            KB is either NB-1 or NB, or N if N &amp;lt;= NB.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, A contains details of the partial factorization.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If UPLO = 'U', only the last KB elements of IPIV are set;
            if UPLO = 'L', only the first KB elements are set.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (LDW,NB)
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W.  LDW >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            partial factorization has the form:
            A  =  ( I  U12 ) ( A11  0  ) (  I      0     )  if UPLO = 'U', or:
                  ( 0  U22 ) (  0   D  ) ( U12**H U22**H )
            A  =  ( L11  0 ) (  D   0  ) ( L11**H L21**H )  if UPLO = 'L'
                  ( L21  I ) (  0  A22 ) (  0      I     )
            where the order of D is at most NB. The actual order is returned in
            the argument KB, and is either NB or NB-1, or N if N &amp;lt;= NB.
            Note that U**H denotes the conjugate transpose of U.
            ZLAHEF is an auxiliary routine called by ZHETRF. It uses blocked code
            (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
            A22 (if UPLO = 'L').
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlatrd(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Reduces NB rows and columns of a complex Hermitian matrix A to
            Hermitian tridiagonal form by a unitary similarity
            transformation Q**H * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of rows and columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the unitary matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  unitary matrix Q as a
              product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U', ZLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', ZLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.
            This is an auxiliary routine called by ZHETRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n) H(n-1) . . . H(n-nb+1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
            and tau in TAU(i-1).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
            and tau in TAU(i).
            The elements of the vectors v together form the n-by-nb matrix V
            which is needed, with W, to apply the transformation to the unreduced
            part of the matrix, using a Hermitian rank-2k update of the form:
            A := A - V*W**H - W*V**H.
            The contents of A on exit are illustrated by the following examples
            with n = 5 and nb = 2:
            if UPLO = 'U':                       if UPLO = 'L':
              (  a   a   a   v4  v5 )              (  d                  )
              (      a   a   v4  v5 )              (  1   d              )
              (          a   1   v5 )              (  v1  1   a          )
              (              d   1  )              (  v1  v2  a   a      )
              (                  d  )              (  v1  v2  a   a   a  )
            where d denotes a diagonal element of the reduced matrix, a denotes
            an element of the original matrix that is unchanged, and vi denotes
            an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaed8(System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},`0@,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            Contains the number of non-deflated eigenvalues.
            This is the order of the related secular equation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the dense or band matrix to tridiagonal form.
            QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            On entry, Q contains the eigenvectors of the partially solved
            system which has been previously updated in matrix
            multiplies with other partially solved eigensystems.
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, D contains the eigenvalues of the two submatrices to
            be combined.  On exit, D contains the trailing (N-K) updated
            eigenvalues (those which were deflated) sorted into increasing
            order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            Contains the off diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined. RHO is modified during the computation to
            the value required by DLAED3.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  MIN(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (N)
            On input this vector contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).  The contents of Z are
            destroyed during the updating process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is DOUBLE PRECISION array, dimension (N)
            Contains a copy of the first K eigenvalues which will be used
            by DLAED3 to form the secular equation.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is COMPLEX*16 array, dimension (LDQ2,N)
            If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
            Contains a copy of the first K eigenvectors which will be used
            by DLAED7 in a matrix multiply (DGEMM) to update the new
            eigenvectors.
            </code>
            <code>
            LDQ2 is INTEGER
            The leading dimension of the array Q2.  LDQ2 >= max( 1, N ).
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (N)
            This will hold the first k values of the final
            deflation-altered z-vector and will be passed to DLAED3.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output INDXP(1:K)
            points to the nondeflated D-values and INDXP(K+1:N)
            points to the deflated eigenvalues.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that elements in
            the second half of this permutation must first have CUTPNT
            added to their values in order to be accurate.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            Contains the number of Givens rotations which took place in
            this subproblem.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension (2, N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaed7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= curlvl &amp;lt;= tlvls.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            Contains the subdiagonal element used to create the rank-1
            modification.
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order,
            ie. D( INDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array,
                                   dimension (3*N+2*QSIZ*N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (QSIZ*N)
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is DOUBLE PRECISION array, dimension (N**2+1)
            Stores eigenvectors of submatrices encountered during
            divide and conquer, packed together. QPTR points to
            beginning of the submatrices.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            List of indices pointing to beginning of submatrices stored
            in QSTORE. The submatrices are numbered starting at the
            bottom left of the divide and conquer tree, from left to
            right and bottom to top.
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and also the size of
            the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense or banded
            Hermitian matrix that has been reduced to tridiagonal form.
              T = Q(in) ( D(in) + RHO * Z*Z**H ) Q**H(in) = Q(out) * D(out) * Q**H(out)
              where Z = Q**Hu, u is a vector of length N with ones in the
              CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine DLAED2.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine DLAED4 (as called by SLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlaed0(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            The divide and conquer method, ZLAED0 computes all eigenvalues
            of a symmetric tridiagonal matrix which is one diagonal block of
            those from reducing a dense or band Hermitian matrix and
            corresponding eigenvectors of the dense or band matrix.</para>
            </summary>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the unitary matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the off-diagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            On entry, Q must contain an QSIZ x N matrix whose columns
            unitarily orthonormal. It is a part of the unitary matrix
            that reduces the full dense Hermitian matrix to a
            (reducible) symmetric tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array,
            the dimension of IWORK must be at least
                         6 + 6*N + 5*N*lg N
                         ( lg( N ) = smallest integer k
                                     such that 2^k >= N )
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array,
                                 dimension (1 + 3*N + 2*N*lg N + 3*N**2)
                          ( lg( N ) = smallest integer k
                                      such that 2^k >= N )
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is COMPLEX*16 array, dimension (LDQS, N)
            Used to store parts of
            the eigenvector matrix when the updating matrix multiplies
            take place.
            </code>
            </param>
            <param name="ldqs">
            <code>
            LDQS is INTEGER
            The leading dimension of the array QSTORE.
            LDQS >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zlasr(Extreme.Mathematics.MatrixOperationSide,System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Applies a sequence of real plane rotations to a complex matrix
            A, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
            </code>
            </param>
            <param name="pivot">
            <code>
            PIVOT is CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  If m &amp;lt;= 1, an immediate
            return is effected.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  If n &amp;lt;= 1, an
            immediate return is effected.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The cosines c(k) of the plane rotations.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The sines s(k) of the plane rotations.  The 2-by-2 plane
            rotation part of the matrix P(k), R(k), has the form
            R(k) = (  c(k)  s(k) )
                   ( -s(k)  c(k) ).
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The M-by-N matrix A.  On exit, A is overwritten by P*A if
            SIDE = 'R' or by A*P**T if SIDE = 'L'.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            When SIDE = 'L', the transformation takes the form
               A := P*A
            and when SIDE = 'R', the transformation takes the form
               A := A*P**T
            where P is an orthogonal matrix consisting of a sequence of z plane
            rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            and P**T is the transpose of P.
            When DIRECT = 'F' (Forward sequence), then
               P = P(z-1) * ... * P(2) * P(1)
            and when DIRECT = 'B' (Backward sequence), then
               P = P(1) * P(2) * ... * P(z-1)
            where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
               R(k) = (  c(k)  s(k) )
                    = ( -s(k)  c(k) ).
            When PIVOT = 'V' (Variable pivot), the rotation is performed
            for the plane (k,k+1), i.e., P(k) has the form
               P(k) = (  1                                            )
                      (       ...                                     )
                      (              1                                )
                      (                   c(k)  s(k)                  )
                      (                  -s(k)  c(k)                  )
                      (                                1              )
                      (                                     ...       )
                      (                                            1  )
            where R(k) appears as a rank-2 modification to the identity matrix in
            rows and columns k and k+1.
            When PIVOT = 'T' (Top pivot), the rotation is performed for the
            plane (1,k+1), so P(k) has the form
               P(k) = (  c(k)                    s(k)                 )
                      (         1                                     )
                      (              ...                              )
                      (                     1                         )
                      ( -s(k)                    c(k)                 )
                      (                                 1             )
                      (                                      ...      )
                      (                                             1 )
            where R(k) appears in rows and columns 1 and k+1.
            Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            performed for the plane (k,z), giving P(k) the form
               P(k) = ( 1                                             )
                      (      ...                                      )
                      (             1                                 )
                      (                  c(k)                    s(k) )
                      (                         1                     )
                      (                              ...              )
                      (                                     1         )
                      (                 -s(k)                    c(k) )
            where R(k) appears in rows and columns k and z.  The rotations are
            performed without ever forming P(k) explicitly.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularBandMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in ZLANTB as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, ZLANTB is
            set to zero.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals of the matrix A if UPLO = 'L'.
            K >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first k+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+k).
            Note that when DIAG = 'U', the elements of the array AB
            corresponding to the diagonal elements of the matrix A are
            not referenced, but are assumed to be one.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= K+1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            ZLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            complex matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by ZGETRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by ZGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgetf2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general m-by-n matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, U(k,k) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A**T * X = B,  or  A**H * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by ZGETRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by ZGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from ZGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUInvert(System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by ZGETRF.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by ZGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from ZGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgebak(System.Char,Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Forms the right or left eigenvectors of a complex general
            matrix by backward transformation on the computed eigenvectors of the
            balanced matrix output by ZGEBAL.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to ZGEBAL.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows of the matrix V.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            The integers ILO and IHI determined by ZGEBAL.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by ZGEBAL.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns of the matrix V.  M >= 0.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by ZHSEIN or ZTREVC.
            On exit, V is overwritten by the transformed eigenvectors.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgebal(System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@,System.Int32@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Balances a general complex matrix A.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ilo">
            <code>
            </code>
            </param>
            <param name="ihi">
            <code>
            ILO and IHI are set to INTEGER such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This involves, first,
            permuting A by a similarity transformation to isolate eigenvalues
            in the first 1 to ILO-1 and last IHI+1 to N elements on the
            diagonal; and second, applying a diagonal similarity transformation
            to rows and columns ILO to IHI to make the rows and columns as
            close in norm as possible.  Both steps are optional.
            Balancing may reduce the 1-norm of the matrix, and improve the
            accuracy of the computed eigenvalues and/or eigenvectors.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The permutations consist of row and column interchanges which put
            the matrix in the form
                       ( T1   X   Y  )
               P A P = (  0   B   Z  )
                       (  0   0   T2 )
            where T1 and T2 are upper triangular matrices whose eigenvalues lie
            along the diagonal.  The column indices ILO and IHI mark the starting
            and ending columns of the submatrix B. Balancing consists of applying
            a diagonal similarity transformation inv(D) * B * D to make the
            1-norms of each row of B and its corresponding column nearly equal.
            The output matrix is
               ( T1     X*D          Y    )
               (  0  inv(D)*B*D  inv(D)*Z ).
               (  0      0           T2   )
            Information about the permutations P and the diagonal matrix D is
            returned in the vector SCALE.
            This subroutine is based on the EISPACK routine CBAL.
            Modified by Tzu-Yi Chen, Computer Science Division, University of
              California at Berkeley, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgehd2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex general matrix A to upper Hessenberg form H
            by a unitary similarity transformation:  Q**H * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to ZGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= max(1,N).
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the n by n general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgehrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a complex general matrix A to upper Hessenberg form H by
            an unitary similarity transformation:  Q**H * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to ZGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the unitary matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This file is a slight modification of LAPACK-3.0's DGEHRD
            subroutine incorporating improvements proposed by Quintana-Orti and
            Van de Geijn (2006). (See DLAHR2.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgeev(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N complex nonsymmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <code>
            JOBVL is CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of are computed.
            </code>
            </param>
            <param name="jobvr">
            <code>
            JOBVR is CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (N)
            W contains the computed eigenvalues.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is COMPLEX*16 array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            u(j) = VL(:,j), the j-th column of VL.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is COMPLEX*16 array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            v(j) = VR(:,j), the j-th column of VR.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,2*N).
            For good performance, LWORK must generally be larger.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements and i+1:N of W contain eigenvalues which have
                  converged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgeqr2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a complex m by n matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(m,n) by n upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a complex M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgeqp3(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            unitary matrix Q as a product of min(M,N) elementary
            reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= N+1.
            For optimal performance LWORK >= ( N+1 )*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgebd2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex general m by n matrix A to upper or lower
            real bidiagonal form B by a unitary transformation: Q**H * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX*16 array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (max(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, v and u are complex vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgebrd(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a general complex M-by-N matrix A to upper or lower
            bidiagonal form B by a unitary transformation: Q**H * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the unitary matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the unitary matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the unitary matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is COMPLEX*16 array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the unitary matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in
            A(i+1:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in
            A(i,i+2:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**H  and G(i) = I - taup * u * u**H
            where tauq and taup are complex scalars, and v and u are complex
            vectors; v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgelq2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a complex m by n matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgelqf(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a complex M-by-N matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the unitary matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k)**H . . . H(2)**H H(1)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; conjg(v(i+1:n)) is stored on exit in
            A(i,i+1:n), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgesdd(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a complex
            M-by-N matrix A, optionally computing the left and/or right singular
            vectors, by using divide-and-conquer method.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**H are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**H are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    in the array A and all rows of V**H are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**H are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**H are computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the input matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the input matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V**H (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX*16 array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N, U contains the M-by-M
            unitary matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &amp;lt; N, LDU >= M.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is COMPLEX*16 array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N unitary matrix V**H;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V**H (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &amp;lt; N, or JOBZ = 'N', VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 1.
            if JOBZ = 'N', LWORK >= 2*min(M,N)+max(M,N).
            if JOBZ = 'O',
                  LWORK >= 2*min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            if JOBZ = 'S' or 'A',
                  LWORK >= min(M,N)*min(M,N)+2*min(M,N)+max(M,N).
            For good performance, LWORK should generally be larger.
            If LWORK = -1, a workspace query is assumed.  The optimal
            size for the WORK array is calculated and stored in WORK(1),
            and no other work except argument checking is performed.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (MAX(1,LRWORK))
            If JOBZ = 'N', LRWORK >= 5*min(M,N).
            Otherwise,
            LRWORK >= min(M,N)*max(5*min(M,N)+7,2*max(M,N)+2*min(M,N)+1)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*min(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The updating process of DBDSDC did not converge.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The SVD is written
                 A = U * SIGMA * conjugate-transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M unitary matrix, and
            V is an N-by-N unitary matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**H, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgeqpf(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Routine is deprecated and has been replaced by routine ZGEQP3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the unitary matrix Q as a product of
            min(m,n) elementary reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            ZGEQPF computes a QR factorization with column pivoting of a
            complex M-by-N matrix A: A*P = Q*R.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(n)
            Each H(i) has the form
               H = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
            The matrix P is represented in jpvt as follows: If
               jpvt(j) = i
            then the jth column of P is the ith canonical unit vector.
            Partial column norm updating strategy modified by
              Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
              University of Zagreb, Croatia.
            -- April 2011                                                      --
            For more details see LAPACK Working Note 176.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgerq2(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes an RQ factorization of a complex m by n matrix A:
            A = R * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, if m &amp;lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
            if m >= n, the elements on and above the (m-n)-th subdiagonal
            contain the m by n upper trapezoidal matrix R; the remaining
            elements, with the array TAU, represent the unitary matrix
            Q as a product of elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1)**H H(2)**H . . . H(k)**H, where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; conjg(v(1:n-k+i-1)) is stored on
            exit in A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by ZGBTRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zgbtf2(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix
            A using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U, because of fill-in resulting from the row
            interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a complex m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B,  A**T * X = B,  or  A**H * X = B
            with a general band matrix A using the LU factorization computed
            by ZGBTRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations.
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by ZGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zggsvp(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0,System.Int32@,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes unitary matrices U, V and Q such that
                               N-K-L  K    L
             U**H*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
                            L ( 0     0   A23 )
                        M-K-L ( 0     0    0  )
                             N-K-L  K    L
                    =     K ( 0    A12  A13 )  if M-K-L &amp;lt; 0;
                        M-K ( 0     0   A23 )
                             N-K-L  K    L
             V**H*B*Q =   L ( 0     0   B13 )
                        P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular (or trapezoidal) matrix
            described in the Purpose section.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix described in
            the Purpose section.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is DOUBLE PRECISION
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is DOUBLE PRECISION
            TOLA and TOLB are the thresholds to determine the effective
            numerical rank of matrix B and a subblock of A. Generally,
            they are set to
               TOLA = MAX(M,N)*norm(A)*MAZHEPS,
               TOLB = MAX(P,N)*norm(B)*MAZHEPS.
            The size of TOLA and TOLB may affect the size of backward
            errors of the decomposition.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose section.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (max(3*N,M,P))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            K+L = the effective
            numerical rank of the (M+P)-by-N matrix (A**H,B**H)**H.
            This decomposition is the preprocessing step for computing the
            Generalized Singular Value Decomposition (GSVD), see subroutine
            ZGGSVD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The subroutine uses LAPACK subroutine ZGEQPF for the QR factorization
            with column pivoting to detect the effective numerical rank of the
            a matrix. It may be replaced by a better rank determination strategy.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zggsvd(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N complex matrix A and P-by-N complex matrix B:
                  U**H*A*Q = D1*( 0 R ),    V**H*B*Q = D2*( 0 R )
            where U, V and Q are unitary matrices.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Unitary matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Unitary matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Unitary matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**H,B**H)**H.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains part of the triangular matrix R if
            M-K-L &amp;lt; 0.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
            </param>
            <param name="u">
            <code>
            U is COMPLEX*16 array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M unitary matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is COMPLEX*16 array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P unitary matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N unitary matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (max(3*N,M,P)+N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            On exit, IWORK stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IWORK(I))
               endfor
            such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine ZTGSJA.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Let K+L = the effective numerical rank of the
            matrix (A**H,B**H)**H, then R is a (K+L)-by-(K+L) nonsingular upper
            triangular matrix, D1 and D2 are M-by-(K+L) and P-by-(K+L) "diagonal"
            matrices and of the following structures, respectively:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the unitary
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**H.
            If ( A**H,B**H)**H has orthnormal columns, then the GSVD of A and B is also
            equal to the CS decomposition of A and B. Furthermore, the GSVD can
            be used to derive the solution of the eigenvalue problem:
                                 A**H*A x = lambda* B**H*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**H*A*X = ( 0 D1 ),   V**H*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, and D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                  X = Q*(  I   0    )
                                        (  0 inv(R) )
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zhetf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method:
               A = U*D*U**H  or  A = L*D*L**H
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, U**H is the conjugate transpose of U, and D is
            Hermitian and block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular, and division by zero will occur if it
                 is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**H, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**H, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            <code>
            09-29-06 - patch from
              Bobby Cheng, MathWorks
              Replace l.210 and l.393
                   IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
              by
                   IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. DISNAN(ABSAKK) ) THEN
            01-01-96 - Based on modifications by
              J. Lewis, Boeing Computer Services Company
              A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.HermitianDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a complex Hermitian matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of WORK.  LWORK >=1.  For best performance
            LWORK >= N*NB, where NB is the block size returned by ILAENV.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The form of the
            factorization is
               A = U*D*U**H  or  A = L*D*L**H
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is Hermitian and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**H, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**H, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.HermitianSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a complex
            Hermitian matrix A using the factorization A = U*D*U**H or
            A = L*D*L**H computed by ZHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.HermitianInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian indefinite matrix
            A using the factorization A = U*D*U**H or A = L*D*L**H computed by
            ZHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by ZHETRF.
            On exit, if INFO = 0, the (Hermitian) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.HermitianEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{System.Int32},`0,`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a complex
            Hermitian matrix A using the factorization A = U*D*U**H or
            A = L*D*L**H computed by ZHETRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**H;
            = 'L':  Lower triangular, form is A = L*D*L**H.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by ZHETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by ZHETRF.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zhetd2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Reduces a complex Hermitian matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zhetrd(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a complex Hermitian matrix A to real symmetric
            tridiagonal form T by a unitary similarity transformation:
            Q**H * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the unitary
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the unitary matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**H
            where tau is a complex scalar, and v is a complex vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zheevd(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            complex Hermitian matrix A.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA, N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.
            If N &amp;lt;= 1,                LWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LWORK must be at least N + 1.
            If JOBZ  = 'V' and N > 1, LWORK must be at least 2*N + N**2.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array,
                                           dimension (LRWORK)
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
            </code>
            </param>
            <param name="lrwork">
            <code>
            LRWORK is INTEGER
            The dimension of the array RWORK.
            If N &amp;lt;= 1,                LRWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LRWORK must be at least N.
            If JOBZ  = 'V' and N > 1, LRWORK must be at least
                           1 + 5*N + 2*N**2.
            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If N &amp;lt;= 1,                LIWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
            If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the submatrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
             Modified description of INFO. Sven, 16 Feb 05.
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite band matrix using
            the Cholesky factorization A = U**H*U or A = L*L**H computed by
            ZPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm (or infinity-norm) of the Hermitian band matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zpbtf2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**H *U or A = L*L**H of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U ,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix, U**H is the conjugate transpose
            of U, and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the Hermitian band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**H*U or A = L*L**H of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite band matrix A using the Cholesky factorization
            A = U**H *U or A = L*L**H computed by ZPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H *U or A = L*L**H of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zpotf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            Hermitian matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H *U  or A = L*L**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U ,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0,`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a complex Hermitian positive definite matrix using the
            Cholesky factorization A = U**H*U or A = L*L**H computed by ZPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H*U or A = L*L**H, as computed by ZPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm (or infinity-norm) of the Hermitian matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a complex Hermitian
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the Hermitian matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**H *U or A = L*L**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**H * U,  if UPLO = 'U', or
               A = L  * L**H,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex Hermitian positive definite
            matrix A using the Cholesky factorization A = U**H*U or A = L*L**H
            computed by ZPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**H*U or A = L*L**H, as computed by
            ZPOTRF.
            On exit, the upper or lower triangle of the (Hermitian)
            inverse of A, overwriting the input factor U or L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a Hermitian
            positive definite matrix A using the Cholesky factorization
            A = U**H * U or A = L * L**H computed by ZPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**H * U or A = L * L**H, as computed by ZPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zsteqr(System.Char,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    Hermitian matrix.  On entry, Z must contain the
                    unitary matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is unitarily similar to the original
                  matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
            matrix to tridiagonal form.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zstedc(System.Char,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original Hermitian matrix
                    also.  On entry, Z contains the unitary matrix used
                    to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the unitary
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original Hermitian matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or 'I', or N &amp;lt;= 1, LWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LWORK must be at least N*N.
            Note that for COMPZ = 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be 1.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK, RWORK and
            IWORK arrays, returns these values as the first entries of
            the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array,
                                           dimension (LRWORK)
            On exit, if INFO = 0, RWORK(1) returns the optimal LRWORK.
            </code>
            </param>
            <param name="lrwork">
            <code>
            LRWORK is INTEGER
            The dimension of the array RWORK.
            If COMPZ = 'N' or N &amp;lt;= 1, LRWORK must be at least 1.
            If COMPZ = 'V' and N > 1, LRWORK must be at least
                           1 + 3*N + 2*N*lg N + 4*N**2 ,
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1, LRWORK must be at least
                           1 + 4*N + 2*N**2 .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LRWORK
            need only be max(1,2*(N-1)).
            If LRWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N &amp;lt;= 1, LIWORK must be at least 1.
            If COMPZ = 'V' or N > 1,  LIWORK must be at least
                                      6 + 6*N + 5*N*lg N.
            If COMPZ = 'I' or N > 1,  LIWORK must be at least
                                      3 + 5*N .
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK, RWORK
            and IWORK arrays, returns these values as the first entries
            of the WORK, RWORK and IWORK arrays, and no error message
            related to LWORK or LRWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band complex Hermitian matrix can also
            be found if ZHETRD or ZHPTRD or ZHBTRD has been used to reduce this
            matrix to tridiagonal form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See DLAED3 for details.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztrti2(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex upper or lower triangular
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a complex upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztrexc(System.Char,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32,System.Int32@)">
            <summary>
            <para>
            Reorders the Schur factorization of a complex matrix
            A = Q*T*Q**H, so that the diagonal element of T with row index IFST
            is moved to row ILST.</para>
            </summary>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,N)
            On entry, the upper triangular matrix T.
            On exit, the reordered upper triangular matrix.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is COMPLEX*16 array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            unitary transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="ifst">
            <code>
            IFST is INTEGER
            </code>
            </param>
            <param name="ilst">
            <code>
            ILST is INTEGER
            Specify the reordering of the diagonal elements of T:
            The element with row index IFST is moved to row ILST by a
            sequence of transpositions between adjacent elements.
            1 &amp;lt;= IFST &amp;lt;= N; 1 &amp;lt;= ILST &amp;lt;= N.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The Schur form T is reordered by a unitary similarity transformation
            Z**H*T*Z, and optionally the matrix Q of Schur vectors is updated by
            postmultplying it with Z.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztrevc(Extreme.Mathematics.MatrixOperationSide,System.Char,Extreme.Collections.Array1D{System.Boolean},System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes some or all of the right and/or left eigenvectors of
            a complex upper triangular matrix T.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
            </code>
            </param>
            <param name="howmny">
            <code>
            HOWMNY is CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed using the matrices supplied in
                    VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.
            </code>
            </param>
            <param name="select">
            <code>
            SELECT is LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            The eigenvector corresponding to the j-th eigenvalue is
            computed if SELECT(j) = .TRUE..
            Not referenced if HOWMNY = 'A' or 'B'.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is COMPLEX*16 array, dimension (LDT,N)
            The upper triangular matrix T.  T is modified, but restored
            on exit.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="vl">
            <code>
            VL is COMPLEX*16 array, dimension (LDVL,MM)
            On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by ZHSEQR).
            On exit, if SIDE = 'L' or 'B', VL contains:
            if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*Y;
            if HOWMNY = 'S', the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'R'.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1, and if
            SIDE = 'L' or 'B', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is COMPLEX*16 array, dimension (LDVR,MM)
            On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
            contain an N-by-N matrix Q (usually the unitary matrix Q of
            Schur vectors returned by ZHSEQR).
            On exit, if SIDE = 'R' or 'B', VR contains:
            if HOWMNY = 'A', the matrix X of right eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*X;
            if HOWMNY = 'S', the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            Not referenced if SIDE = 'L'.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1, and if
            SIDE = 'R' or 'B'; LDVR >= N.
            </code>
            </param>
            <param name="mm">
            <code>
            MM is INTEGER
            The number of columns in the arrays VL and/or VR. MM >= M.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.  If HOWMNY = 'A' or 'B', M
            is set to N.  Each selected eigenvector occupies one
            column.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Matrices of this type are produced by the Schur factorization of
            a complex general matrix:  A = Q*T*Q**H, as computed by ZHSEQR.
            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:
                         T*x = w*x,     (y**H)*T = w*(y**H)
            where y**H denotes the conjugate transpose of the vector y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal of T.
            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix.  If Q is the unitary factor that reduces a matrix A to
            Schur form T, then Q*X and Q*Y are the matrices of right and left
            eigenvectors of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The algorithm used in this program is basically backward (forward)
            substitution, with scaling to make the the code robust against
            possible overflow.
            Each eigenvector is normalized so that the element of largest
            magnitude has magnitude 1; here the magnitude of a complex number
            (x,y) is taken to be |x| + |y|.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B,  A**T * X = B,  or  A**H * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztbcon(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},`0@,Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular band matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (2*N)
            </code>
            </param>
            <param name="rwork">
            <code>
            RWORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ztbtrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B,  A**T * X = B,  or  A**H * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by-NRHS matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B     (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is COMPLEX*16 array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is COMPLEX*16 array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunm2r(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by ZGEQRF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.QRUnitaryMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQRF in the first k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by ZGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmhr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of ZGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by ZGEHRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEHRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by ZGEHRD:
            Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zung2r(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Generates an m by n complex matrix Q with orthonormal columns,
            which is defined as the first n columns of a product of k elementary
            reflectors of order m
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by ZGEQRF in the first k columns of its array
            argument A.
            On exit, the m by n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by ZGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zungqr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N complex matrix Q with orthonormal columns,
            which is defined as the first N columns of a product of K elementary
            reflectors of order M
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by ZGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by ZGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunghr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates a complex unitary matrix Q which is defined as the
            product of IHI-ILO elementary reflectors of order N, as returned by
            ZGEHRD:
            Q = H(ilo) H(ilo+1) .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix Q. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of ZGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by ZGEHRD.
            On exit, the N-by-N unitary matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEHRD.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zungl2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Generates an m-by-n complex matrix Q with orthonormal rows,
            which is defined as the first m rows of a product of k elementary
            reflectors of order n
                  Q  =  H(k)**H .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by ZGELQF in the first k rows of its array argument A.
            On exit, the m by n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunglq(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N complex matrix Q with orthonormal rows,
            which is defined as the first M rows of a product of K elementary
            reflectors of order N
                  Q  =  H(k)**H .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by ZGELQF in the first k rows of its array argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit;
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zungbr(System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates one of the complex unitary matrices Q or P**H
            determined by ZGEBRD when reducing a complex matrix A to bidiagonal
            form: A = Q * B * P**H.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            Specifies whether the matrix Q or the matrix P**H is
            required, as defined in the transformation applied by ZGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q or P**H to be returned.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q or P**H to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original M-by-K
            matrix reduced by ZGEBRD.
            If VECT = 'P', the number of rows in the original K-by-N
            matrix reduced by ZGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by ZGEBRD.
            On exit, the M-by-N matrix Q or P**H.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= M.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i), which determines Q or P**H, as
            returned by ZGEBRD in its array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            For optimum performance LWORK >= min(M,N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and P**H are defined as products of
            elementary reflectors H(i) or G(i) respectively.
            If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            is of order M:
            if m >= k, Q = H(1) H(2) . . . H(k) and ZUNGBR returns the first n
            columns of Q, where m >= n >= k;
            if m &amp;lt; k, Q = H(1) H(2) . . . H(m-1) and ZUNGBR returns Q as an
            M-by-M matrix.
            If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**H
            is of order N:
            if k &amp;lt; n, P**H = G(k) . . . G(2) G(1) and ZUNGBR returns the first m
            rows of P**H, where n >= m >= k;
            if k >= n, P**H = G(n-1) . . . G(2) G(1) and ZUNGBR returns P**H as
            an N-by-N matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  April 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunml2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmlq(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGELQF in the first k rows of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2)**H H(1)**H
            as returned by ZGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmbr(System.Char,Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            VECT = 'Q', ZUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            If VECT = 'P', ZUNMBR overwrites the general complex M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'C':      P**H * C       C * P**H
            Here Q and P**H are the unitary matrices determined by ZGEBRD when
            reducing a complex matrix A to bidiagonal form: A = Q * B * P**H.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            = 'Q': apply Q or Q**H;
            = 'P': apply P or P**H.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q, Q**H, P or P**H from the Left;
            = 'R': apply Q, Q**H, P or P**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q or P;
            = 'C':  Conjugate transpose, apply Q**H or P**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by ZGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by ZGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by ZGEBRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by ZGEBRD in the array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q
            or P*C or P**H*C or C*P or C*P**H.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M);
            if N = 0 or M = 0, LWORK >= 1.
            For optimum performance LWORK >= max(1,N*NB) if SIDE = 'L',
            and LWORK >= max(1,M*NB) if SIDE = 'R', where NB is the
            optimal blocksize. (NB = 0 if M = 0 or N = 0.)
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q
            and P**H are defined as products of elementary reflectors H(i) and
            G(i) respectively.
            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the unitary matrix Q or P**H that is applied.
            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq &amp;lt; k, Q = H(1) H(2) . . . H(nq-1).
            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &amp;lt; nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmr2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(1)**H H(2)**H .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGERQF in the last k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGERQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)**H
            as returned by ZGERQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunm2l(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex m-by-n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**H* C  if SIDE = 'L' and TRANS = 'C', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**H if SIDE = 'R' and TRANS = 'C',
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left
            = 'R': apply Q or Q**H from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'C': apply Q**H (Conjugate transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the m-by-n matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by ZGEQLF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmql(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            ZGEQLF in the last k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by ZGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zunmtr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general complex M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'C':      Q**H * C       C * Q**H
            where Q is a complex unitary matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**H from the Left;
            = 'R': apply Q or Q**H from the Right.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from ZHETRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from ZHETRD.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'C':  Conjugate transpose, apply Q**H.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by ZHETRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is COMPLEX*16 array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by ZHETRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is COMPLEX*16 array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**H*C or C*Q**H or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >=M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            nq-1 elementary reflectors, as returned by ZHETRD:
            if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
            if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Zhseqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}},Extreme.Collections.Array1D{Extreme.Mathematics.Complex{`0}},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**H, where T is an upper triangular matrix (the
               Schur form), and Z is the unitary matrix of Schur vectors.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
             = 'E':  compute eigenvalues only;
             = 'S':  compute eigenvalues and the Schur form T.
            </code>
            </param>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
             = 'N':  no Schur vectors are computed;
             = 'I':  Z is initialized to the unit matrix and the matrix Z
                     of Schur vectors of H is returned;
             = 'V':  Z must contain an unitary matrix Q on entry, and
                     the product Q*Z is returned.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to ZGEBAL, and then passed to ZGEHRD
             when the matrix output by ZGEBAL is reduced to Hessenberg
             form. Otherwise ILO and IHI should be set to 1 and N
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is COMPLEX*16 array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and JOB = 'S', H contains the upper
             triangular matrix T from the Schur decomposition (the
             Schur form). If INFO = 0 and JOB = 'E', the contents of
             H are unspecified on exit.  (The output value of H when
             INFO.GT.0 is given under the description of INFO below.)
             Unlike earlier versions of ZHSEQR, this subroutine may
             explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
             or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is COMPLEX*16 array, dimension (N)
             The computed eigenvalues. If JOB = 'S', the eigenvalues are
             stored in the same order as on the diagonal of the Schur
             form returned in H, with W(i) = H(i,i).
            </code>
            </param>
            <param name="z">
            <code>
            Z is COMPLEX*16 array, dimension (LDZ,N)
             If COMPZ = 'N', Z is not referenced.
             If COMPZ = 'I', on entry Z need not be set and on exit,
             if INFO = 0, Z contains the unitary matrix Z of the Schur
             vectors of H.  If COMPZ = 'V', on entry Z must contain an
             N-by-N matrix Q, which is assumed to be equal to the unit
             matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
             if INFO = 0, Z contains Q*Z.
             Normally Q is the unitary matrix generated by ZUNGHR
             after the call to ZGEHRD which formed the Hessenberg matrix
             H. (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if COMPZ = 'I' or
             COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is COMPLEX*16 array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient and delivers very good and sometimes
             optimal performance.  However, LWORK as large as 11*N
             may be required for optimal performance.  A workspace
             query is recommended to determine the optimal workspace
             size.
             If LWORK = -1, then ZHSEQR does a workspace query.
             In this case, ZHSEQR checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal
                      value
             .GT. 0:  if INFO = i, ZHSEQR failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and JOB = 'E', then on exit, the
                  remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and JOB   = 'S', then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a unitary matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and COMPZ = 'V', then on exit
                    (final value of Z)  =  (initial value of Z)*U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'I', then on exit
                        (final value of Z)  = U
                  where U is the unitary matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'N', then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input unitary
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the unitary matrix Q:  A = Q*H*Q**H = (QZ)*H*(QZ)**H.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Default values supplied by
            ILAENV(ISPEC,'ZHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
            It is suggested that these defaults be adjusted in order
            to attain best performance in each particular
            computational environment.
            ISPEC=12: The ZLAHQR vs ZLAQR0 crossover point.
                      Default: 75. (Must be at least 11.)
            ISPEC=13: Recommended deflation window size.
                      This depends on ILO, IHI and NS.  NS is the
                      number of simultaneous shifts returned
                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                      The default for (IHI-ILO+1).LE.500 is NS.
                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.
            ISPEC=14: Nibble crossover point. (See IPARMQ for
                      details.)  Default: 14% of deflation window
                      size.
            ISPEC=15: Number of simultaneous shifts in a multishift
                      QR iteration.
                      If IHI-ILO+1 is ...
                      greater than      ...but less    ... the
                      or equal to ...      than        default is
                           1               30          NS =   2(+)
                          30               60          NS =   4(+)
                          60              150          NS =  10(+)
                         150              590          NS =  **
                         590             3000          NS =  64
                        3000             6000          NS = 128
                        6000             infinity      NS = 256
                  (+)  By default some or all matrices of this order
                       are passed to the implicit double shift routine
                       ZLAHQR and this parameter is ignored.  See
                       ISPEC=12 above and comments in IPARMQ for
                       details.
                 (**)  The asterisks (**) indicate an ad-hoc
                       function of N increasing from 10 to 64.
            ISPEC=16: Select structured matrix multiply.
                      If the number of simultaneous shifts (specified
                      by ISPEC=15) is less than 14, then the default
                      for ISPEC=16 is 0.  Otherwise the default for
                      ISPEC=16 is 2.
            </code>
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlacn2(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},`0@,System.Int32@,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Estimates the 1-norm of a square, real matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (N)
            On the final return, V = A*W,  where  EST = norm(V)/norm(W)
            (W is not returned).
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (N)
            On an intermediate return, X should be overwritten by
                  A * X,   if KASE=1,
                  A**T * X,  if KASE=2,
            and DLACN2 must be re-called with all the other parameters
            unchanged.
            </code>
            </param>
            <param name="isgn">
            <code>
            ISGN is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="est">
            <code>
            EST is DOUBLE PRECISION
            On entry with KASE = 1 or 2 and ISAVE(1) = 3, EST should be
            unchanged from the previous call to DLACN2.
            On exit, EST is an estimate (a lower bound) for norm(A).
            </code>
            </param>
            <param name="kase">
            <code>
            KASE is INTEGER
            On the initial call to DLACN2, KASE should be 0.
            On an intermediate return, KASE will be 1 or 2, indicating
            whether X should be overwritten by A * X  or A**T * X.
            On the final return from DLACN2, KASE will again be 0.
            </code>
            </param>
            <param name="isave">
            <code>
            ISAVE is INTEGER array, dimension (3)
            ISAVE is used to save variables between calls to DLACN2
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Reverse communication is used for evaluating matrix-vector products.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Originally named SONEST, dated March 16, 1988.
            This is a thread safe version of DLACON, which uses the array ISAVE
            in place of a SAVE statement, as follows:
               DLACON     DLACN2
                JUMP     ISAVE(1)
                J        ISAVE(2)
                ITER     ISAVE(3)
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Nick Higham, University of Manchester
            </para>
            <h4> References:</h4>
            <para>
             N.J. Higham, "FORTRAN codes for estimating the one-norm of
             a real or complex matrix, with applications to condition estimation",
             ACM Trans. Math. Soft., vol. 14, no. 4, pp. 381-396, December 1988.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlatbs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},`0@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A *x = s*b  or  A**T*x = s*b
            with scaling to prevent overflow, where A is an upper or lower
            triangular band matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b  (No transpose)
            = 'T':  Solve A**T* x = s*b  (Transpose)
            = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of subdiagonals or superdiagonals in the
            triangular matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first KD+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            The scaling factor s for the triangular system
               A * x = s*b  or  A**T* x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is DOUBLE PRECISION array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A**T denotes the transpose of A, x and b
            are n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine DTBSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, DTBSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine DTBSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
            algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call DTBSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlabad(`0@,`0@)">
            <summary>
            <para>
            Takes as input the values computed by DLAMCH for underflow and
            overflow, and returns the square root of each of these values if the
            log of LARGE is sufficiently large.</para>
            </summary>
            <param name="small">
            <code>
            SMALL is DOUBLE PRECISION
            On entry, the underflow threshold as computed by DLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of SMALL, otherwise unchanged.
            </code>
            </param>
            <param name="large">
            <code>
            LARGE is DOUBLE PRECISION
            On entry, the overflow threshold as computed by DLAMCH.
            On exit, if LOG10(LARGE) is sufficiently large, the square
            root of LARGE, otherwise unchanged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This subroutine is intended to
            identify machines with a large exponent range, such as the Crays, and
            redefine the underflow and overflow limits to be the square roots of
            the values computed by DLAMCH.  This subroutine is needed because
            DLAMCH does not compensate for poor arithmetic in the upper half of
            the exponent range, as is found on a Cray.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Drscl(System.Int32,`0,Extreme.Collections.ArraySlice{`0})">
            <summary>
            <para>
            Multiplies an n-element real vector x by the real scalar 1/a.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of components of the vector x.
            </code>
            </param>
            <param name="sa">
            <code>
            SA is DOUBLE PRECISION
            The scalar a which is used to divide each component of x.
            SA must be >= 0, or the subroutine will divide by zero.
            </code>
            </param>
            <param name="sx">
            <code>
            SX is DOUBLE PRECISION array, dimension
                           (1+(N-1)*abs(INCX))
            The n-element vector x.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector SX.
            > 0:  SX(1) = X(1) and SX(1+(i-1)*INCX) = x(i),     1&amp;lt; i&amp;lt;= n
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without overflow or underflow as long as
            the final result x/a does not overflow or underflow.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ieeeck(System.Int32,`0,`0)">
            <summary>
            <para>
            Is called from the ILAENV to verify that Infinity and
            possibly NaN arithmetic is safe (i.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is INTEGER
            Specifies whether to test just for inifinity arithmetic
            or whether to test for infinity and NaN arithmetic.
            = 0: Verify infinity arithmetic only.
            = 1: Verify infinity and NaN arithmetic.
            </code>
            </param>
            <param name="zero">
            <code>
            ZERO is REAL
            Must contain the value 0.0
            This is passed to prevent the compiler from optimizing
            away this code.
            </code>
            </param>
            <param name="one">
            <code>
            ONE is REAL
            Must contain the value 1.0
            This is passed to prevent the compiler from optimizing
            away this code.
            VALUE:  INTEGER
             = 0:  Arithmetic failed to produce the correct answers
             = 1:  Arithmetic produced the correct answers
            </code>
            </param>
            <remarks>
            <para>
            <code>
            e. will not trap).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Iparmq(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Program sets problem and machine dependent parameters
                 useful for xHSEQR and its subroutines.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is integer scalar
                ISPEC specifies which tunable parameter IPARMQ should
                return.
                ISPEC=12: (INMIN)  Matrices of order nmin or less
                          are sent directly to xLAHQR, the implicit
                          double shift QR algorithm.  NMIN must be
                          at least 11.
                ISPEC=13: (INWIN)  Size of the deflation window.
                          This is best set greater than or equal to
                          the number of simultaneous shifts NS.
                          Larger matrices benefit from larger deflation
                          windows.
                ISPEC=14: (INIBL) Determines when to stop nibbling and
                          invest in an (expensive) multi-shift QR sweep.
                          If the aggressive early deflation subroutine
                          finds LD converged eigenvalues from an order
                          NW deflation window and LD.GT.(NW*NIBBLE)/100,
                          then the next QR sweep is skipped and early
                          deflation is applied immediately to the
                          remaining active diagonal block.  Setting
                          IPARMQ(ISPEC=14) = 0 causes TTQRE to skip a
                          multi-shift QR sweep whenever early deflation
                          finds a converged eigenvalue.  Setting
                          IPARMQ(ISPEC=14) greater than or equal to 100
                          prevents TTQRE from skipping a multi-shift
                          QR sweep.
                ISPEC=15: (NSHFTS) The number of simultaneous shifts in
                          a multi-shift QR iteration.
                ISPEC=16: (IACC22) IPARMQ is set to 0, 1 or 2 with the
                          following meanings.
                          0:  During the multi-shift QR sweep,
                              xLAQR5 does not accumulate reflections and
                              does not use matrix-matrix multiply to
                              update the far-from-diagonal matrix
                              entries.
                          1:  During the multi-shift QR sweep,
                              xLAQR5 and/or xLAQRaccumulates reflections and uses
                              matrix-matrix multiply to update the
                              far-from-diagonal matrix entries.
                          2:  During the multi-shift QR sweep.
                              xLAQR5 accumulates reflections and takes
                              advantage of 2-by-2 block structure during
                              matrix-matrix multiplies.
                          (If xTRMM is slower than xGEMM, then
                          IPARMQ(ISPEC=16)=1 may be more efficient than
                          IPARMQ(ISPEC=16)=2 despite the greater level of
                          arithmetic work implied by the latter choice.)
            </code>
            </param>
            <param name="name">
            <code>
            NAME is character string
                 Name of the calling subroutine
            </code>
            </param>
            <param name="opts">
            <code>
            OPTS is character string
                 This is a concatenation of the string arguments to
                 TTQRE.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
                 N is the order of the Hessenberg matrix H.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
                 It is assumed that H is already upper triangular
                 in rows and columns 1:ILO-1 and IHI+1:N.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer scalar
                 The amount of workspace available.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is called whenever
                 ILAENV is called with 12 &amp;lt;= ISPEC &amp;lt;= 16
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Little is known about how best to choose these parameters.
            It is possible to use different values of the parameters
            for each of CHSEQR, DHSEQR, SHSEQR and ZHSEQR.
            It is probably best to choose different parameters for
            different matrices and different parameters at different
            times during the iteration, but this has not been
            implemented --- yet.
            The best choices of most of the parameters depend
            in an ill-understood way on the relative execution
            rate of xLAQR3 and xLAQR5 and on the nature of each
            particular eigenvalue problem.  Experiment may be the
            only practical way to determine which choices are most
            effective.
            Following is a list of default values supplied by IPARMQ.
            These defaults may be adjusted in order to attain better
            performance in any particular computational environment.
            IPARMQ(ISPEC=12) The xLAHQR vs xLAQR0 crossover point.
                             Default: 75. (Must be at least 11.)
            IPARMQ(ISPEC=13) Recommended deflation window size.
                             This depends on ILO, IHI and NS, the
                             number of simultaneous shifts returned
                             by IPARMQ(ISPEC=15).  The default for
                             (IHI-ILO+1).LE.500 is NS.  The default
                             for (IHI-ILO+1).GT.500 is 3*NS/2.
            IPARMQ(ISPEC=14) Nibble crossover point.  Default: 14.
            IPARMQ(ISPEC=15) Number of simultaneous shifts, NS.
                             a multi-shift QR iteration.
                             If IHI-ILO+1 is ...
                             greater than      ...but less    ... the
                             or equal to ...      than        default is
                                     0               30       NS =   2+
                                    30               60       NS =   4+
                                    60              150       NS =  10
                                   150              590       NS =  **
                                   590             3000       NS =  64
                                  3000             6000       NS = 128
                                  6000             infinity   NS = 256
                         (+)  By default matrices of this order are
                              passed to the implicit double shift routine
                              xLAHQR.  See IPARMQ(ISPEC=12) above.   These
                              values of NS are used only in case of a rare
                              xLAHQR failure.
                         (**) The asterisks (**) indicate an ad-hoc
                              function increasing from 10 to 64.
            IPARMQ(ISPEC=16) Select structured matrix multiply.
                             (See ISPEC=16 above for details.)
                             Default: 3.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ilaenv(System.Int32,System.String,System.String,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            <para>
            Is called from the LAPACK routines to choose problem-dependent
            parameters for the local environment.</para>
            </summary>
            <param name="ispec">
            <code>
            ISPEC is INTEGER
            Specifies the parameter to be returned as the value of
            ILAENV.
            = 1: the optimal blocksize; if this value is 1, an unblocked
                 algorithm will give the best performance.
            = 2: the minimum block size for which the block routine
                 should be used; if the usable block size is less than
                 this value, an unblocked routine should be used.
            = 3: the crossover point (in a block routine, for N less
                 than this value, an unblocked routine should be used)
            = 4: the number of shifts, used in the nonsymmetric
                 eigenvalue routines (DEPRECATED)
            = 5: the minimum column dimension for blocking to be used;
                 rectangular blocks must have dimension at least k by m,
                 where k is given by ILAENV(2,...) and m by ILAENV(5,...)
            = 6: the crossover point for the SVD (when reducing an m by n
                 matrix to bidiagonal form, if max(m,n)/min(m,n) exceeds
                 this value, a QR factorization is used first to reduce
                 the matrix to a triangular form.)
            = 7: the number of processors
            = 8: the crossover point for the multishift QR method
                 for nonsymmetric eigenvalue problems (DEPRECATED)
            = 9: maximum size of the subproblems at the bottom of the
                 computation tree in the divide-and-conquer algorithm
                 (used by xGELSD and xGESDD)
            =10: ieee NaN arithmetic can be trusted not to trap
            =11: infinity arithmetic can be trusted not to trap
            12 &amp;lt;= ISPEC &amp;lt;= 16:
                 xHSEQR or one of its subroutines,
                 see IPARMQ for detailed explanation
            </code>
            </param>
            <param name="name">
            <code>
            NAME is CHARACTER*(*)
            The name of the calling subroutine, in either upper case or
            lower case.
            </code>
            </param>
            <param name="opts">
            <code>
            OPTS is CHARACTER*(*)
            The character options to the subroutine NAME, concatenated
            into a single character string.  For example, UPLO = 'U',
            TRANS = 'T', and DIAG = 'N' for a triangular routine would
            be specified as OPTS = 'UTN'.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            </code>
            </param>
            <param name="n3">
            <code>
            N3 is INTEGER
            </code>
            </param>
            <param name="n4">
            <code>
            N4 is INTEGER
            Problem dimensions for the subroutine NAME; these may not all
            be required.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            See ISPEC for a description of
            the parameters.
            ILAENV returns an INTEGER
            if ILAENV >= 0: ILAENV returns the value of the parameter specified by ISPEC
            if ILAENV &amp;lt; 0:  if ILAENV = -k, the k-th argument had an illegal value.
            This version provides a set of parameters which should give good,
            but not optimal, performance on many of the currently available
            computers.  Users are encouraged to modify this subroutine to set
            the tuning parameters for their particular machine using the option
            and problem size information in the arguments.
            This routine will not function correctly if it is converted to all
            lower case.  Converting it to all upper case is allowed.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The following conventions have been used when calling ILAENV from the
            LAPACK routines:
            1)  OPTS is a concatenation of all of the character options to
                subroutine NAME, in the same order that they appear in the
                argument list for NAME, even if they are not used in determining
                the value of the parameter specified by ISPEC.
            2)  The problem dimensions N1, N2, N3, N4 are specified in the order
                that they appear in the argument list for NAME.  N1 is used
                first, N2 second, and so on, and unused problem dimensions are
                passed a value of -1.
            3)  The parameter value returned by ILAENV is checked for validity in
                the calling subroutine.  For example, ILAENV is used to retrieve
                the optimal blocksize for STRTRI as follows:
                NB = ILAENV( 1, 'STRTRI', UPLO // DIAG, N, -1, -1, -1 )
                IF( NB.LE.1 ) NB = MAX( 1, N )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaswp(System.Int32,Extreme.Collections.Array2D{`0},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Performs a series of row interchanges on the matrix A.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the matrix of column dimension N to which the row
            interchanges will be applied.
            On exit, the permuted matrix.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            </code>
            </param>
            <param name="k1">
            <code>
            K1 is INTEGER
            The first element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="k2">
            <code>
            K2 is INTEGER
            The last element of IPIV for which a row interchange will
            be done.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (K2*abs(INCX))
            The vector of pivot indices.  Only the elements in positions
            K1 through K2 of IPIV are accessed.
            IPIV(K) = L implies rows K and L are to be interchanged.
            </code>
            </param>
            <param name="incx">
            <code>
            INCX is INTEGER
            The increment between successive values of IPIV.  If IPIV
            is negative, the pivots are applied in reverse order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            One row interchange is initiated for each of rows K1 through K2 of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by
             R. C. Whaley, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlatrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},`0@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Solves one of the triangular systems
               A *x = s*b  or  A**T *x = s*b
            with scaling to prevent overflow.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the operation applied to A.
            = 'N':  Solve A * x = s*b  (No transpose)
            = 'T':  Solve A**T* x = s*b  (Transpose)
            = 'C':  Solve A**T* x = s*b  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="normin">
            <code>
            NORMIN is CHARACTER*1
            Specifies whether CNORM has been set or not.
            = 'Y':  CNORM contains the column norms on entry
            = 'N':  CNORM is not set on entry.  On exit, the norms will
                    be computed and stored in CNORM.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max (1,N).
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (N)
            On entry, the right hand side b of the triangular system.
            On exit, X is overwritten by the solution vector x.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            The scaling factor s for the triangular system
               A * x = s*b  or  A**T* x = s*b.
            If SCALE = 0, the matrix A is singular or badly scaled, and
            the vector x is an exact or approximate solution to A*x = 0.
            </code>
            </param>
            <param name="cnorm">
            <code>
            CNORM is DOUBLE PRECISION array, dimension (N)
            If NORMIN = 'Y', CNORM is an input argument and CNORM(j)
            contains the norm of the off-diagonal part of the j-th column
            of A.  If TRANS = 'N', CNORM(j) must be greater than or equal
            to the infinity-norm, and if TRANS = 'T' or 'C', CNORM(j)
            must be greater than or equal to the 1-norm.
            If NORMIN = 'N', CNORM is an output argument and CNORM(j)
            returns the 1-norm of the offdiagonal part of the j-th column
            of A.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Here A is an upper or lower
            triangular matrix, A**T denotes the transpose of A, x and b are
            n-element vectors, and s is a scaling factor, usually less than
            or equal to 1, chosen so that the components of x will be less than
            the overflow threshold.  If the unscaled problem will not cause
            overflow, the Level 2 BLAS routine DTRSV is called.  If the matrix A
            is singular (A(j,j) = 0 for some j), then s is set to 0 and a
            non-trivial solution to A*x = 0 is returned.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            A rough bound on x is computed; if that is less than overflow, DTRSV
            is called, otherwise, specific code is used which checks for possible
            overflow or divide-by-zero at every operation.
            A columnwise scheme is used for solving A*x = b.  The basic algorithm
            if A is lower triangular is
                 x[1:n] := b[1:n]
                 for j = 1, ..., n
                      x(j) := x(j) / A(j,j)
                      x[j+1:n] := x[j+1:n] - x(j) * A[j+1:n,j]
                 end
            Define bounds on the components of x after j iterations of the loop:
               M(j) = bound on x[1:j]
               G(j) = bound on x[j+1:n]
            Initially, let M(0) = 0 and G(0) = max{x(i), i=1,...,n}.
            Then for iteration j+1 we have
               M(j+1) &amp;lt;= G(j) / | A(j+1,j+1) |
               G(j+1) &amp;lt;= G(j) + M(j+1) * | A[j+2:n,j+1] |
                      &amp;lt;= G(j) ( 1 + CNORM(j+1) / | A(j+1,j+1) | )
            where CNORM(j+1) is greater than or equal to the infinity-norm of
            column j+1 of A, not counting the diagonal.  Hence
               G(j) &amp;lt;= G(0) product ( 1 + CNORM(i) / | A(i,i) | )
                            1&amp;lt;=i&amp;lt;=j
            and
               |x(j)| &amp;lt;= ( G(0) / |A(j,j)| ) product ( 1 + CNORM(i) / |A(i,i)| )
                                             1&amp;lt;=i&amp;lt; j
            Since |x(j)| &amp;lt;= M(j), we use the Level 2 BLAS routine DTRSV if the
            reciprocal of the largest M(j), j=1,..,n, is larger than
            max(underflow, 1/overflow).
            The bound on x(j) is also used to determine when a step in the
            columnwise method can be performed without fear of overflow.  If
            the computed bound is greater than a large constant, x is scaled to
            prevent overflow, but if the bound overflows, x is set to 0, x(j) to
            1, and scale to 0, and a non-trivial solution to A*x = 0 is found.
            Similarly, a row-wise scheme is used to solve A**T*x = b.  The basic
            algorithm for A upper triangular is
                 for j = 1, ..., n
                      x(j) := ( b(j) - A[1:j-1,j]**T * x[1:j-1] ) / A(j,j)
                 end
            We simultaneously compute two bounds
                 G(j) = bound on ( b(i) - A[1:i-1,i]**T * x[1:i-1] ), 1&amp;lt;=i&amp;lt;=j
                 M(j) = bound on x(i), 1&amp;lt;=i&amp;lt;=j
            The initial values are G(0) = 0, M(0) = max{b(i), i=1,..,n}, and we
            add the constraint G(j) >= G(j-1) and M(j) >= M(j-1) for j >= 1.
            Then the bound on x(j) is
                 M(j) &amp;lt;= M(j-1) * ( 1 + CNORM(j) ) / | A(j,j) |
                      &amp;lt;= M(0) * product ( ( 1 + CNORM(i) ) / |A(i,i)| )
                                1&amp;lt;=i&amp;lt;=j
            and we can safely call DTRSV if 1/M(n) and 1/G(n) are both greater
            than max(underflow, 1/overflow).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaisnan(`0,`0)">
            <summary>
            <para>
            Routine is not for general use.</para>
            </summary>
            <param name="din1">
            <code>
            DIN1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="din2">
            <code>
            DIN2 is DOUBLE PRECISION
            Two numbers to compare for inequality.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It exists solely to avoid
            over-optimization in DISNAN.
            DLAISNAN checks for NaNs by comparing its two arguments for
            inequality.  NaN is the only floating-point value where NaN != NaN
            returns .TRUE.  To check for NaNs, pass the same variable as both
            arguments.
            A compiler must assume that the two arguments are
            not the same variable, and the test will not be optimized away.
            Interprocedural or whole-program optimization may delete this
            test.  The ISNAN functions will be replaced by the correct
            Fortran 03 intrinsic once the intrinsic is widely available.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Disnan(`0)">
            <summary>
            <para>
            Returns .</para>
            </summary>
            <param name="din">
            <code>
            DIN is DOUBLE PRECISION
            Input to test for NaN.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            TRUE. if its argument is NaN, and .FALSE.
            otherwise.  To be replaced by the Fortran 2003 intrinsic in the
            future.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Iladlr(System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Scans A for its last non-zero row.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Iladlc(System.Int32,System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Scans A for its last non-zero column.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlarf(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.ArraySlice{`0},`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Applies a real elementary reflector H to a real m by n matrix
            C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension
                       (1 + (M-1)*abs(INCV)) if SIDE = 'L'
                    or (1 + (N-1)*abs(INCV)) if SIDE = 'R'
            The vector v in the representation of H. V is not used if
            TAU = 0.
            </code>
            <code>
            INCV is INTEGER
            The increment between elements of v. INCV &amp;lt;> 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                           (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the form
                  H = I - tau * v * v**T
            where tau is a real scalar and v is a real vector.
            If tau = 0, then H is taken to be the unit matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlapy2(`0,`0)">
            <summary>
            <para>
            Returns sqrt(x**2+y**2), taking care not to cause unnecessary
            overflow.</para>
            </summary>
            <param name="x">
            <code>
            X is DOUBLE PRECISION
            </code>
            </param>
            <param name="y">
            <code>
            Y is DOUBLE PRECISION
            X and Y specify the values x and y.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlarfg(System.Int32,`0@,Extreme.Collections.ArraySlice{`0},`0@)">
            <summary>
            <para>
            Generates a real elementary reflector H of order n, such
            that
                  H * ( alpha ) = ( beta ),   H**T * H = I.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the elementary reflector.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            On entry, the value alpha.
            On exit, it is overwritten with the value beta.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension
                           (1+(N-2)*abs(INCX))
            On entry, the vector x.
            On exit, it is overwritten with the vector v.
            </code>
            <code>
            INCX is INTEGER
            The increment between elements of X. INCX > 0.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            The value tau.
            </code>
            </param>
            <remarks>
            <para>
            <code>
                      (   x   )   (   0  )
            where alpha and beta are scalars, and x is an (n-1)-element real
            vector. H is represented in the form
                  H = I - tau * ( 1 ) * ( 1 v**T ) ,
                                ( v )
            where tau is a real scalar and v is a real (n-1)-element
            vector.
            If the elements of x are all zero, then tau = 0 and H is taken to be
            the unit matrix.
            Otherwise  1 &amp;lt;= tau &amp;lt;= 2.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Copy(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Copies all or part of a two-dimensional matrix A to another
            matrix B.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be copied to B.
            = 'U':      Upper triangular part
            = 'L':      Lower triangular part
            Otherwise:  All of the matrix A
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.  If UPLO = 'U', only the upper triangle
            or trapezoid is accessed; if UPLO = 'L', only the lower
            triangle or trapezoid is accessed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,N)
            On exit, B = A in the locations specified by UPLO.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlahr2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Reduces the first NB columns of A real general n-BY-(n-k+1)
            matrix A so that elements below the k-th subdiagonal are zero.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The offset for the reduction. Elements below the k-th
            subdiagonal in the first NB columns are reduced to zero.
            K &amp;lt; N.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N-K+1)
            On entry, the n-by-(n-k+1) general matrix A.
            On exit, the elements on and above the k-th subdiagonal in
            the first NB columns are overwritten with the corresponding
            elements of the reduced matrix; the elements below the k-th
            subdiagonal, with the array TAU, represent the matrix Q as a
            product of elementary reflectors. The other columns of A are
            unchanged. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (NB)
            The scalar factors of the elementary reflectors. See Further
            Details.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,NB)
            The upper triangular matrix T.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T.  LDT >= NB.
            </code>
            </param>
            <param name="y">
            <code>
            Y is DOUBLE PRECISION array, dimension (LDY,NB)
            The n-by-nb matrix Y.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= N.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            reduction is performed by an orthogonal similarity transformation
            Q**T * A * Q. The routine returns the matrices V and T which determine
            Q as a block reflector I - V*T*V**T, and also the matrix Y = A * V * T.
            This is an auxiliary routine called by DGEHRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of nb elementary reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i+k-1) = 0, v(i+k) = 1; v(i+k+1:n) is stored on exit in
            A(i+k+1:n,i), and tau in TAU(i).
            The elements of the vectors v together form the (n-k+1)-by-nb matrix
            V which is needed, with T and Y, to apply the transformation to the
            unreduced part of the matrix, using an update of the form:
            A := (I - V*T*V**T) * (A - Y*V**T).
            The contents of A on exit are illustrated by the following example
            with n = 7, k = 3 and nb = 2:
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( a   a   a   a   a )
               ( h   h   a   a   a )
               ( v1  h   a   a   a )
               ( v1  v2  a   a   a )
               ( v1  v2  a   a   a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This subroutine is a slight modification of LAPACK-3.0's DLAHRD
            incorporating improvements proposed by Quintana-Orti and Van de
            Gejin. Note that the entries of A(1:K,2:NB) differ from those
            returned by the original LAPACK-3.0's DLAHRD routine. (This
            subroutine is not backward compatible with LAPACK-3.0's DLAHRD.)
            </code>
            </para>
            <h4> References:</h4>
            <para>
             Gregorio Quintana-Orti and Robert van de Geijn, "Improving the
             performance of reduction to Hessenberg form," ACM Transactions on
             Mathematical Software, 32(2):180-194, June 2006.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlarfb(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Applies a real block reflector H or its transpose H**T to a
            real m by n matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply H or H**T from the Left
            = 'R': apply H or H**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply H (No transpose)
            = 'T': apply H**T (Transpose)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Indicates how H is formed from a product of elementary
            reflectors
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Indicates how the vectors which define the elementary
            reflectors are stored:
            = 'C': Columnwise
            = 'R': Rowwise
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the matrix T (= the number of elementary
            reflectors whose product defines the block reflector).
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension
                                  (LDV,K) if STOREV = 'C'
                                  (LDV,M) if STOREV = 'R' and SIDE = 'L'
                                  (LDV,N) if STOREV = 'R' and SIDE = 'R'
            The matrix V. See Further Details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C' and SIDE = 'L', LDV >= max(1,M);
            if STOREV = 'C' and SIDE = 'R', LDV >= max(1,N);
            if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,K)
            The triangular k by k matrix T in the representation of the
            block reflector.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by H*C or H**T*C or C*H or C*H**T.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (LDWORK,K)
            </code>
            <code>
            LDWORK is INTEGER
            The leading dimension of the array WORK.
            If SIDE = 'L', LDWORK >= max(1,N);
            if SIDE = 'R', LDWORK >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored; the corresponding
            array elements are modified but restored on exit. The rest of the
            array is not used.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlanv2(`0@,`0@,`0@,`0@,`0@,`0@,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Computes the Schur factorization of a real 2-by-2 nonsymmetric
            matrix in standard form:
                 [ A  B ] = [ CS -SN ] [ AA  BB ] [ CS  SN ]
                 [ C  D ]   [ SN  CS ] [ CC  DD ] [-SN  CS ]
            where either
            1) CC = 0 so that AA and DD are real eigenvalues of the matrix, or
            2) AA = DD and BB*CC &amp;lt; 0, so that AA + or - sqrt(BB*CC) are complex
            conjugate eigenvalues.</para>
            </summary>
            <param name="a">
            <code>
            A is DOUBLE PRECISION
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION
            On entry, the elements of the input matrix.
            On exit, they are overwritten by the elements of the
            standardised Schur form.
            </code>
            </param>
            <param name="rt1r">
            <code>
            RT1R is DOUBLE PRECISION
            </code>
            </param>
            <param name="rt1i">
            <code>
            RT1I is DOUBLE PRECISION
            </code>
            </param>
            <param name="rt2r">
            <code>
            RT2R is DOUBLE PRECISION
            </code>
            </param>
            <param name="rt2i">
            <code>
            RT2I is DOUBLE PRECISION
            The real and imaginary parts of the eigenvalues. If the
            eigenvalues are a complex conjugate pair, RT1I > 0.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is DOUBLE PRECISION
            </code>
            </param>
            <param name="sn">
            <code>
            SN is DOUBLE PRECISION
            Parameters of the rotation matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Modified by V. Sima, Research Institute for Informatics, Bucharest,
            Romania, to reduce the risk of cancellation errors,
            when computing real eigenvalues, and to ensure, if possible, that
            abs(RT1R) >= abs(RT2R).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlahqr(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Is an auxiliary routine called by DHSEQR to update the
               eigenvalues and Schur decomposition already computed by DHSEQR, by
               dealing with the Hessenberg submatrix in rows and columns ILO to
               IHI.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that H is already upper quasi-triangular in
            rows and columns IHI+1:N, and that H(ILO,ILO-1) = 0 (unless
            ILO = 1). DLAHQR works primarily with the Hessenberg
            submatrix in rows and columns ILO to IHI, but applies
            transformations to all of H if WANTT is .TRUE..
            1 &amp;lt;= ILO &amp;lt;= max(1,IHI); IHI &amp;lt;= N.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
            On entry, the upper Hessenberg matrix H.
            On exit, if INFO is zero and if WANTT is .TRUE., H is upper
            quasi-triangular in rows and columns ILO:IHI, with any
            2-by-2 diagonal blocks in standard form. If INFO is zero
            and WANTT is .FALSE., the contents of H are unspecified on
            exit.  The output state of H if INFO is nonzero is given
            below under the description of INFO.
            </code>
            <code>
            LDH is INTEGER
            The leading dimension of the array H. LDH >= max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION array, dimension (N)
            The real and imaginary parts, respectively, of the computed
            eigenvalues ILO to IHI are stored in the corresponding
            elements of WR and WI. If two eigenvalues are computed as a
            complex conjugate pair, they are stored in consecutive
            elements of WR and WI, say the i-th and (i+1)th, with
            WI(i) > 0 and WI(i+1) &amp;lt; 0. If WANTT is .TRUE., the
            eigenvalues are stored in the same order as on the diagonal
            of the Schur form returned in H, with WR(i) = H(i,i), and, if
            H(i:i+1,i:i+1) is a 2-by-2 diagonal block,
            WI(i) = sqrt(H(i+1,i)*H(i,i+1)) and WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE..
            1 &amp;lt;= ILOZ &amp;lt;= ILO; IHI &amp;lt;= IHIZ &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,N)
            If WANTZ is .TRUE., on entry Z must contain the current
            matrix Z of transformations accumulated by DHSEQR, and on
            exit Z has been updated; transformations are applied only to
            the submatrix Z(ILOZ:IHIZ,ILO:IHI).
            If WANTZ is .FALSE., Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z. LDZ >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
             =   0: successful exit
            .GT. 0: If INFO = i, DLAHQR failed to compute all the
                    eigenvalues ILO to IHI in a total of 30 iterations
                    per eigenvalue; elements i+1:ihi of WR and WI
                    contain those eigenvalues which have been
                    successfully computed.
                    If INFO .GT. 0 and WANTT is .FALSE., then on exit,
                    the remaining unconverged eigenvalues are the
                    eigenvalues of the upper Hessenberg matrix rows
                    and columns ILO thorugh INFO of the final, output
                    value of H.
                    If INFO .GT. 0 and WANTT is .TRUE., then on exit
            (*)       (initial value of H)*U  = U*(final value of H)
                    where U is an orthognal matrix.    The final
                    value of H is upper Hessenberg and triangular in
                    rows and columns INFO+1 through IHI.
                    If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                        (final value of Z)  = (initial value of Z)*U
                    where U is the orthogonal matrix in (*)
                    (regardless of the value of WANTT.)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            02-96 Based on modifications by
            David Day, Sandia National Laboratory, USA
            12-04 Further modifications by
            Ralph Byers, University of Kansas, USA
            This is a modified version of DLAHQR from LAPACK version 3.0.
            It is (1) more robust against overflow and underflow and
            (2) adopts the more conservative Ahues &amp; Tisseur stopping
            criterion (LAWN 122, 1997).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaset(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,`0,`0,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Initializes an m-by-n matrix A to BETA on the diagonal and
            ALPHA on the offdiagonals.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies the part of the matrix A to be set.
            = 'U':      Upper triangular part is set; the strictly lower
                        triangular part of A is not changed.
            = 'L':      Lower triangular part is set; the strictly upper
                        triangular part of A is not changed.
            Otherwise:  All of the matrix A is set.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            The constant to which the offdiagonal elements are to be set.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION
            The constant to which the diagonal elements are to be set.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On exit, the leading m-by-n submatrix of A is set as follows:
            if UPLO = 'U', A(i,j) = ALPHA, 1&amp;lt;=i&amp;lt;=j-1, 1&amp;lt;=j&amp;lt;=n,
            if UPLO = 'L', A(i,j) = ALPHA, j+1&amp;lt;=i&amp;lt;=m, 1&amp;lt;=j&amp;lt;=n,
            otherwise,     A(i,j) = ALPHA, 1&amp;lt;=i&amp;lt;=m, 1&amp;lt;=j&amp;lt;=n, i.ne.j,
            and, for all UPLO, A(i,i) = BETA, 1&amp;lt;=i&amp;lt;=min(m,n).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlarft(System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Forms the triangular factor T of a real block reflector H
            of order n, which is defined as a product of k elementary reflectors.</para>
            </summary>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies the order in which the elementary reflectors are
            multiplied to form the block reflector:
            = 'F': H = H(1) H(2) . . . H(k) (Forward)
            = 'B': H = H(k) . . . H(2) H(1) (Backward)
            </code>
            </param>
            <param name="storev">
            <code>
            STOREV is CHARACTER*1
            Specifies how the vectors which define the elementary
            reflectors are stored (see also Further Details):
            = 'C': columnwise
            = 'R': rowwise
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the block reflector H. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The order of the triangular factor T (= the number of
            elementary reflectors). K >= 1.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension
                                 (LDV,K) if STOREV = 'C'
                                 (LDV,N) if STOREV = 'R'
            The matrix V. See further details.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V.
            If STOREV = 'C', LDV >= max(1,N); if STOREV = 'R', LDV >= K.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i).
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,K)
            The k by k triangular factor T of the block reflector.
            If DIRECT = 'F', T is upper triangular; if DIRECT = 'B', T is
            lower triangular. The rest of the array is not used.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= K.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If DIRECT = 'F', H = H(1) H(2) . . . H(k) and T is upper triangular;
            If DIRECT = 'B', H = H(k) . . . H(2) H(1) and T is lower triangular.
            If STOREV = 'C', the vector which defines the elementary reflector
            H(i) is stored in the i-th column of the array V, and
               H  =  I - V * T * V**T
            If STOREV = 'R', the vector which defines the elementary reflector
            H(i) is stored in the i-th row of the array V, and
               H  =  I - V**T * T * V
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The shape of the matrix V and the storage of the vectors which define
            the H(i) is best illustrated by the following example with n = 5 and
            k = 3. The elements equal to 1 are not stored.
            DIRECT = 'F' and STOREV = 'C':         DIRECT = 'F' and STOREV = 'R':
                         V = (  1       )                 V = (  1 v1 v1 v1 v1 )
                             ( v1  1    )                     (     1 v2 v2 v2 )
                             ( v1 v2  1 )                     (        1 v3 v3 )
                             ( v1 v2 v3 )
                             ( v1 v2 v3 )
            DIRECT = 'B' and STOREV = 'C':         DIRECT = 'B' and STOREV = 'R':
                         V = ( v1 v2 v3 )                 V = ( v1 v1  1       )
                             ( v1 v2 v3 )                     ( v2 v2 v2  1    )
                             (  1 v2 v3 )                     ( v3 v3 v3 v3  1 )
                             (     1 v3 )
                             (        1 )
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlassq(System.Int32,Extreme.Collections.ArraySlice{`0},`0@,`0@)">
            <summary>
            <para>
            Returns the values  scl  and  smsq  such that
               ( scl**2 )*smsq = x( 1 )**2 +.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements to be used from the vector X.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (N)
            The vector for which a scaled sum of squares is computed.
               x( i )  = X( 1 + ( i - 1 )*INCX ), 1 &amp;lt;= i &amp;lt;= n.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive values of the vector X.
            INCX > 0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            On entry, the value  scale  in the equation above.
            On exit, SCALE is overwritten with  scl , the scaling factor
            for the sum of squares.
            </code>
            </param>
            <param name="sumsq">
            <code>
            SUMSQ is DOUBLE PRECISION
            On entry, the value  sumsq  in the equation above.
            On exit, SUMSQ is overwritten with  smsq , the basic sum of
            squares from which  scl  has been factored out.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            where  x( i ) = X( 1 + ( i - 1 )*INCX ). The value of  sumsq  is
            assumed to be non-negative and  scl  returns the value
               scl = max( scale, abs( x( i ) ) ).
            scale and sumsq must be supplied in SCALE and SUMSQ and
            scl and smsq are overwritten on SCALE and SUMSQ respectively.
            The routine makes only one pass through the vector x.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.FullMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in DLANGE as described
            above.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.  When M = 0,
            DLANGE is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.  When N = 0,
            DLANGE is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            DLANGE = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlarfx(Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Applies a real elementary reflector H to a real m by n
            matrix C, from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': form  H * C
            = 'R': form  C * H
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (M) if SIDE = 'L'
                                       or (N) if SIDE = 'R'
            The vector v in the representation of H.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            The value tau in the representation of H.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by the matrix H * C if SIDE = 'L',
            or C * H if SIDE = 'R'.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDA >= (1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                        (N) if SIDE = 'L'
                        or (M) if SIDE = 'R'
            WORK is not referenced if H has order &amp;lt; 11.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            H is represented in the
            form
                  H = I - tau * v * v**T
            where tau is a real scalar and v is a real vector.
            If tau = 0, then H is taken to be the unit matrix
            This version uses inline code if H has order &amp;lt; 11.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlartg(`0,`0,`0@,`0@,`0@)">
            <summary>
            <para>
            Generate a plane rotation so that
               [  CS  SN  ]  .</para>
            </summary>
            <param name="f">
            <code>
            F is DOUBLE PRECISION
            The first component of vector to be rotated.
            </code>
            </param>
            <param name="g">
            <code>
            G is DOUBLE PRECISION
            The second component of vector to be rotated.
            </code>
            </param>
            <param name="cs">
            <code>
            CS is DOUBLE PRECISION
            The cosine of the rotation.
            </code>
            </param>
            <param name="sn">
            <code>
            SN is DOUBLE PRECISION
            The sine of the rotation.
            </code>
            </param>
            <param name="r">
            <code>
            R is DOUBLE PRECISION
            The nonzero component of the rotated vector.
            rsion has a few statements commented out for thread safety
            ne parameters are computed on each entry). 10 feb 03, SJH.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            [ F ]  =  [ R ]   where CS**2 + SN**2 = 1.
               [ -SN  CS  ]     [ G ]     [ 0 ]
            This is a slower, more accurate version of the BLAS1 routine DROTG,
            with the following other differences:
               F and G are unchanged on return.
               If G=0, then CS=1 and SN=0.
               If F=0 and (G .ne. 0), then CS=0 and SN=1 without doing any
                  floating point operations (saves work in DBDSQR when
                  there are zeros on the diagonal).
            If F exceeds G in magnitude, CS will be positive.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasy2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0@,Extreme.Collections.Array2D{`0},`0@,System.Int32@)">
            <summary>
            <para>
            Solves for the N1 by N2 matrix X, 1 &amp;lt;= N1,N2 &amp;lt;= 2, in
                   op(TL)*X + ISGN*X*op(TR) = SCALE*B,
            where TL is N1 by N1, TR is N2 by N2, B is N1 by N2, and ISGN = 1 or
            -1.</para>
            </summary>
            <param name="ltranl">
            <code>
            LTRANL is LOGICAL
            On entry, LTRANL specifies the op(TL):
               = .FALSE., op(TL) = TL,
               = .TRUE., op(TL) = TL**T.
            </code>
            </param>
            <param name="ltranr">
            <code>
            LTRANR is LOGICAL
            On entry, LTRANR specifies the op(TR):
              = .FALSE., op(TR) = TR,
              = .TRUE., op(TR) = TR**T.
            </code>
            </param>
            <param name="isgn">
            <code>
            ISGN is INTEGER
            On entry, ISGN specifies the sign of the equation
            as described before. ISGN may only be 1 or -1.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            On entry, N1 specifies the order of matrix TL.
            N1 may only be 0, 1 or 2.
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            On entry, N2 specifies the order of matrix TR.
            N2 may only be 0, 1 or 2.
            </code>
            </param>
            <param name="tl">
            <code>
            TL is DOUBLE PRECISION array, dimension (LDTL,2)
            On entry, TL contains an N1 by N1 matrix.
            </code>
            <code>
            LDTL is INTEGER
            The leading dimension of the matrix TL. LDTL >= max(1,N1).
            </code>
            </param>
            <param name="tr">
            <code>
            TR is DOUBLE PRECISION array, dimension (LDTR,2)
            On entry, TR contains an N2 by N2 matrix.
            </code>
            <code>
            LDTR is INTEGER
            The leading dimension of the matrix TR. LDTR >= max(1,N2).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,2)
            On entry, the N1 by N2 matrix B contains the right-hand
            side of the equation.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the matrix B. LDB >= max(1,N1).
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            On exit, SCALE contains the scale factor. SCALE is chosen
            less than or equal to 1 to prevent the solution overflowing.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (LDX,2)
            On exit, X contains the N1 by N2 solution.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the matrix X. LDX >= max(1,N1).
            </code>
            </param>
            <param name="xnorm">
            <code>
            XNORM is DOUBLE PRECISION
            On exit, XNORM is the infinity-norm of the solution.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            On exit, INFO is set to
               0: successful exit.
               1: TL and TR have too close eigenvalues, so TL or
                  TR is perturbed to get a nonsingular equation.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            op(T) = T or T**T, where T**T denotes the transpose of T.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaexc(System.Boolean,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Swaps adjacent diagonal blocks T11 and T22 of order 1 or 2 in
            an upper quasi-triangular matrix T by an orthogonal similarity
            transformation.</para>
            </summary>
            <param name="wantq">
            <code>
            WANTQ is LOGICAL
            = .TRUE. : accumulate the transformation in the matrix Q;
            = .FALSE.: do not accumulate the transformation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            canonical form.
            On exit, the updated matrix T, again in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if WANTQ is .TRUE., the orthogonal matrix Q.
            On exit, if WANTQ is .TRUE., the updated matrix Q.
            If WANTQ is .FALSE., Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.
            LDQ >= 1; and if WANTQ is .TRUE., LDQ >= N.
            </code>
            </param>
            <param name="j1">
            <code>
            J1 is INTEGER
            The index of the first row of the first block T11.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The order of the first block T11. N1 = 0, 1 or 2.
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            The order of the second block T22. N2 = 0, 1 or 2.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            = 1: the transformed matrix T would be too far from Schur
                 form; the blocks are not swapped and T and Q are
                 unchanged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            T must be in Schur canonical form, that is, block upper triangular
            with 1-by-1 and 2-by-2 diagonal blocks; each 2-by-2 diagonal block
            has its diagonal elemnts equal and its off-diagonal elements of
            opposite sign.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr2(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@,System.Int32@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32)">
            <summary>
            <para>
            Is identical to DLAQR3 except that it avoids
               recursion by calling DLAHQR instead of DLAQR4.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the quasi-triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the orthogonal matrix Z is updated so
            so that the orthogonal Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the orthogonal matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by an orthogonal
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the orthogonal
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is DOUBLE PRECISION array, dimension (KBOT)
            </code>
            </param>
            <param name="si">
            <code>
            SI is DOUBLE PRECISION array, dimension (KBOT)
            On output, the real and imaginary parts of approximate
            eigenvalues that may be used for shifts are stored in
            SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
            SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
            The real and imaginary parts of converged eigenvalues
            are stored in SR(KBOT-ND+1) through SR(KBOT) and
            SI(KBOT-ND+1) through SI(KBOT), respectively.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is DOUBLE PRECISION array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (LWORK)
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; DLAQR2
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Aggressive early deflation:
               This subroutine accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.  On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr1(System.Int32,Extreme.Collections.Array2D{`0},`0,`0,`0,`0,Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            A 2-by-2 or 3-by-3 matrix H, DLAQR1 sets v to a
                 scalar multiple of the first column of the product
                 (*)  K = (H - (sr1 + i*si1)*I)*(H - (sr2 + i*si2)*I)
                 scaling to avoid overflows and most underflows.</para>
            </summary>
            <param name="n">
            <code>
            N is integer
                Order of the matrix H. N must be either 2 or 3.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array of dimension (LDH,N)
                The 2-by-2 or 3-by-3 matrix H in (*).
            </code>
            <code>
            LDH is integer
                The leading dimension of H as declared in
                the calling procedure.  LDH.GE.N
            </code>
            </param>
            <param name="sr1">
            <code>
            SR1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="si1">
            <code>
            SI1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="sr2">
            <code>
            SR2 is DOUBLE PRECISION
            </code>
            </param>
            <param name="si2">
            <code>
            SI2 is DOUBLE PRECISION
                The shifts in (*).
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array of dimension N
                A scalar multiple of the first column of the
                matrix K in (*).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It
                 is assumed that either
                         1) sr1 = sr2 and si1 = -si2
                     or
                         2) si1 = si2 = 0.
                 This is useful for starting double implicit shift bulges
                 in the QR algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr5(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Called by DLAQR0, performs a
               single small-bulge multi-shift QR sweep.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is logical scalar
               WANTT = .true. if the quasi-triangular Schur factor
               is being computed.  WANTT is set to .false. otherwise.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is logical scalar
               WANTZ = .true. if the orthogonal Schur factor is being
               computed.  WANTZ is set to .false. otherwise.
            </code>
            </param>
            <param name="kacc22">
            <code>
            KACC22 is integer with value 0, 1, or 2.
               Specifies the computation mode of far-from-diagonal
               orthogonal updates.
            = 0: DLAQR5 does not accumulate reflections and does not
                 use matrix-matrix multiply to update far-from-diagonal
                 matrix entries.
            = 1: DLAQR5 accumulates reflections and uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries.
            = 2: DLAQR5 accumulates reflections, uses matrix-matrix
                 multiply to update the far-from-diagonal matrix entries,
                 and takes advantage of 2-by-2 block structure during
                 matrix multiplies.
            </code>
            </param>
            <param name="n">
            <code>
            N is integer scalar
               N is the order of the Hessenberg matrix H upon which this
               subroutine operates.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is integer scalar
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is integer scalar
               These are the first and last rows and columns of an
               isolated diagonal block upon which the QR sweep is to be
               applied. It is assumed without a check that
                         either KTOP = 1  or   H(KTOP,KTOP-1) = 0
               and
                         either KBOT = N  or   H(KBOT+1,KBOT) = 0.
            </code>
            </param>
            <param name="nshfts">
            <code>
            NSHFTS is integer scalar
               NSHFTS gives the number of simultaneous shifts.  NSHFTS
               must be positive and even.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is DOUBLE PRECISION array of size (NSHFTS)
            </code>
            </param>
            <param name="si">
            <code>
            SI is DOUBLE PRECISION array of size (NSHFTS)
               SR contains the real parts and SI contains the imaginary
               parts of the NSHFTS shifts of origin that define the
               multi-shift QR sweep.  On output SR and SI may be
               reordered.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array of size (LDH,N)
               On input H contains a Hessenberg matrix.  On output a
               multi-shift QR sweep with shifts SR(J)+i*SI(J) is applied
               to the isolated diagonal block in rows and columns KTOP
               through KBOT.
            </code>
            <code>
            LDH is integer scalar
               LDH is the leading dimension of H just as declared in the
               calling procedure.  LDH.GE.MAX(1,N).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
               Specify the rows of Z to which transformations must be
               applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array of size (LDZ,IHI)
               If WANTZ = .TRUE., then the QR Sweep orthogonal
               similarity transformation is accumulated into
               Z(ILOZ:IHIZ,ILO:IHI) from the right.
               If WANTZ = .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer scalar
               LDA is the leading dimension of Z just as declared in
               the calling procedure. LDZ.GE.N.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array of size (LDV,NSHFTS/2)
            </code>
            <code>
            LDV is integer scalar
               LDV is the leading dimension of V as declared in the
               calling procedure.  LDV.GE.3.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array of size
               (LDU,3*NSHFTS-3)
            </code>
            <code>
            LDU is integer scalar
               LDU is the leading dimension of U just as declared in the
               in the calling subroutine.  LDU.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
               NH is the number of columns in array WH available for
               workspace. NH.GE.1.
            </code>
            </param>
            <param name="wh">
            <code>
            WH is DOUBLE PRECISION array of size (LDWH,NH)
            </code>
            <code>
            LDWH is integer scalar
               Leading dimension of WH just as declared in the
               calling procedure.  LDWH.GE.3*NSHFTS-3.
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer scalar
               NV is the number of rows in WV agailable for workspace.
               NV.GE.1.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is DOUBLE PRECISION array of size
               (LDWV,3*NSHFTS-3)
            </code>
            <code>
            LDWV is integer scalar
               LDWV is the leading dimension of WV as declared in the
               in the calling subroutine.  LDWV.GE.NV.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr4(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Implements one level of recursion for DLAQR0.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to DGEBAL, and then passed to DGEHRD when the
             matrix output by DGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION array, dimension (IHI)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then DLAQR4 does a workspace query.
             In this case, DLAQR4 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, DLAQR4 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is a orthogonal matrix.  The final
                  value of  H is upper Hessenberg and triangular in
                  rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It is a complete implementation of the small bulge multi-shift
            QR algorithm.  It may be called by DLAQR0 and, for large enough
            deflation window size, it may be called by DLAQR3.  This
            subroutine is identical to DLAQR0 except that it calls DLAQR2
            instead of DLAQR3.
            DLAQR4 computes the eigenvalues of a Hessenberg matrix H
            and, optionally, the matrices T and Z from the Schur decomposition
            H = Z T Z**T, where T is an upper quasi-triangular matrix (the
            Schur form), and Z is the orthogonal matrix of Schur vectors.
            Optionally Z may be postmultiplied into an input orthogonal
            matrix Q so that this routine can give the Schur factorization
            of a matrix A which has been reduced to the Hessenberg form H
            by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr3(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@,System.Int32@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32)">
            <summary>
            <para>
            Early deflation:
               DLAQR3 accepts as input an upper Hessenberg matrix
               H and performs an orthogonal similarity transformation
               designed to detect and deflate fully converged eigenvalues from
               a trailing principal submatrix.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            If .TRUE., then the Hessenberg matrix H is fully updated
            so that the quasi-triangular Schur factor may be
            computed (in cooperation with the calling subroutine).
            If .FALSE., then only enough of H is updated to preserve
            the eigenvalues.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            If .TRUE., then the orthogonal matrix Z is updated so
            so that the orthogonal Schur factor may be computed
            (in cooperation with the calling subroutine).
            If .FALSE., then Z is not referenced.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix H and (if WANTZ is .TRUE.) the
            order of the orthogonal matrix Z.
            </code>
            </param>
            <param name="ktop">
            <code>
            KTOP is INTEGER
            It is assumed that either KTOP = 1 or H(KTOP,KTOP-1)=0.
            KBOT and KTOP together determine an isolated block
            along the diagonal of the Hessenberg matrix.
            </code>
            </param>
            <param name="kbot">
            <code>
            KBOT is INTEGER
            It is assumed without a check that either
            KBOT = N or H(KBOT+1,KBOT)=0.  KBOT and KTOP together
            determine an isolated block along the diagonal of the
            Hessenberg matrix.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            Deflation window size.  1 .LE. NW .LE. (KBOT-KTOP+1).
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
            On input the initial N-by-N section of H stores the
            Hessenberg matrix undergoing aggressive early deflation.
            On output H has been transformed by an orthogonal
            similarity transformation, perturbed, and the returned
            to Hessenberg form that (it is to be hoped) has some
            zero subdiagonal entries.
            </code>
            <code>
            LDH is integer
            Leading dimension of H just as declared in the calling
            subroutine.  N .LE. LDH
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
            Specify the rows of Z to which transformations must be
            applied if WANTZ is .TRUE.. 1 .LE. ILOZ .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,N)
            IF WANTZ is .TRUE., then on output, the orthogonal
            similarity transformation mentioned above has been
            accumulated into Z(ILOZ:IHIZ,ILO:IHI) from the right.
            If WANTZ is .FALSE., then Z is unreferenced.
            </code>
            <code>
            LDZ is integer
            The leading dimension of Z just as declared in the
            calling subroutine.  1 .LE. LDZ.
            </code>
            </param>
            <param name="ns">
            <code>
            NS is integer
            The number of unconverged (ie approximate) eigenvalues
            returned in SR and SI that may be used as shifts by the
            calling subroutine.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is integer
            The number of converged eigenvalues uncovered by this
            subroutine.
            </code>
            </param>
            <param name="sr">
            <code>
            SR is DOUBLE PRECISION array, dimension (KBOT)
            </code>
            </param>
            <param name="si">
            <code>
            SI is DOUBLE PRECISION array, dimension (KBOT)
            On output, the real and imaginary parts of approximate
            eigenvalues that may be used for shifts are stored in
            SR(KBOT-ND-NS+1) through SR(KBOT-ND) and
            SI(KBOT-ND-NS+1) through SI(KBOT-ND), respectively.
            The real and imaginary parts of converged eigenvalues
            are stored in SR(KBOT-ND+1) through SR(KBOT) and
            SI(KBOT-ND+1) through SI(KBOT), respectively.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,NW)
            An NW-by-NW work array.
            </code>
            <code>
            LDV is integer scalar
            The leading dimension of V just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="nh">
            <code>
            NH is integer scalar
            The number of columns of T.  NH.GE.NW.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,NW)
            </code>
            <code>
            LDT is integer
            The leading dimension of T just as declared in the
            calling subroutine.  NW .LE. LDT
            </code>
            </param>
            <param name="nv">
            <code>
            NV is integer
            The number of rows of work array WV available for
            workspace.  NV.GE.NW.
            </code>
            </param>
            <param name="wv">
            <code>
            WV is DOUBLE PRECISION array, dimension (LDWV,NW)
            </code>
            <code>
            LDWV is integer
            The leading dimension of W just as declared in the
            calling subroutine.  NW .LE. LDV
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (LWORK)
            On exit, WORK(1) is set to an estimate of the optimal value
            of LWORK for the given values of N, NW, KTOP and KBOT.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is integer
            The dimension of the work array WORK.  LWORK = 2*NW
            suffices, but greater efficiency may result from larger
            values of LWORK.
            If LWORK = -1, then a workspace query is assumed; DLAQR3
            only estimates the optimal workspace size for the given
            values of N, NW, KTOP and KBOT.  The estimate is returned
            in WORK(1).  No error message related to LWORK is issued
            by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On output H has been over-
               written by a new Hessenberg matrix that is a perturbation of
               an orthogonal similarity transformation of H.  It is to be
               hoped that the final version of H has many zero subdiagonal
               entries.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqr0(System.Boolean,System.Boolean,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.</para>
            </summary>
            <param name="wantt">
            <code>
            WANTT is LOGICAL
            = .TRUE. : the full Schur form T is required;
            = .FALSE.: only eigenvalues are required.
            </code>
            </param>
            <param name="wantz">
            <code>
            WANTZ is LOGICAL
            = .TRUE. : the matrix of Schur vectors Z is required;
            = .FALSE.: Schur vectors are not required.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N and, if ILO.GT.1,
             H(ILO,ILO-1) is zero. ILO and IHI are normally set by a
             previous call to DGEBAL, and then passed to DGEHRD when the
             matrix output by DGEBAL is reduced to Hessenberg form.
             Otherwise, ILO and IHI should be set to 1 and N,
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and WANTT is .TRUE., then H contains
             the upper quasi-triangular matrix T from the Schur
             decomposition (the Schur form); 2-by-2 diagonal blocks
             (corresponding to complex conjugate pairs of eigenvalues)
             are returned in standard form, with H(i,i) = H(i+1,i+1)
             and H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and WANTT is
             .FALSE., then the contents of H are unspecified on exit.
             (The output value of H when INFO.GT.0 is given under the
             description of INFO below.)
             This subroutine may explicitly set H(i,j) = 0 for i.GT.j and
             j = 1, 2, ... ILO-1 or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION array, dimension (IHI)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION array, dimension (IHI)
             The real and imaginary parts, respectively, of the computed
             eigenvalues of H(ILO:IHI,ILO:IHI) are stored in WR(ILO:IHI)
             and WI(ILO:IHI). If two eigenvalues are computed as a
             complex conjugate pair, they are stored in consecutive
             elements of WR and WI, say the i-th and (i+1)th, with
             WI(i) .GT. 0 and WI(i+1) .LT. 0. If WANTT is .TRUE., then
             the eigenvalues are stored in the same order as on the
             diagonal of the Schur form returned in H, with
             WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2 diagonal
             block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="iloz">
            <code>
            ILOZ is INTEGER
            </code>
            </param>
            <param name="ihiz">
            <code>
            IHIZ is INTEGER
             Specify the rows of Z to which transformations must be
             applied if WANTZ is .TRUE..
             1 .LE. ILOZ .LE. ILO; IHI .LE. IHIZ .LE. N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,IHI)
             If WANTZ is .FALSE., then Z is not referenced.
             If WANTZ is .TRUE., then Z(ILO:IHI,ILOZ:IHIZ) is
             replaced by Z(ILO:IHI,ILOZ:IHIZ)*U where U is the
             orthogonal Schur factor of H(ILO:IHI,ILO:IHI).
             (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if WANTZ is .TRUE.
             then LDZ.GE.MAX(1,IHIZ).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension LWORK
             On exit, if LWORK = -1, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient, but LWORK typically as large as 6*N may
             be required for optimal performance.  A workspace query
             to determine the optimal workspace size is recommended.
             If LWORK = -1, then DLAQR0 does a workspace query.
             In this case, DLAQR0 checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .GT. 0:  if INFO = i, DLAQR0 failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and WANT is .FALSE., then on exit,
                  the remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and WANTT is .TRUE., then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is an orthogonal matrix.  The final
                  value of H is upper Hessenberg and quasi-triangular
                  in rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and WANTZ is .TRUE., then on exit
                    (final value of Z(ILO:IHI,ILOZ:IHIZ)
                     =  (initial value of Z(ILO:IHI,ILOZ:IHIZ)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of WANTT.)
                  If INFO .GT. 0 and WANTZ is .FALSE., then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlascl(System.Char,System.Int32,System.Int32,`0,`0,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Multiplies the M by N real matrix A by the real scalar
            CTO/CFROM.</para>
            </summary>
            <param name="type">
            <code>
            TYPE is CHARACTER*1
            TYPE indices the storage type of the input matrix.
            = 'G':  A is a full matrix.
            = 'L':  A is a lower triangular matrix.
            = 'U':  A is an upper triangular matrix.
            = 'H':  A is an upper Hessenberg matrix.
            = 'B':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the lower
                    half stored.
            = 'Q':  A is a symmetric band matrix with lower bandwidth KL
                    and upper bandwidth KU and with the only the upper
                    half stored.
            = 'Z':  A is a band matrix with lower bandwidth KL and upper
                    bandwidth KU. See DGBTRF for storage details.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The lower bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The upper bandwidth of A.  Referenced only if TYPE = 'B',
            'Q' or 'Z'.
            </code>
            </param>
            <param name="cfrom">
            <code>
            CFROM is DOUBLE PRECISION
            </code>
            </param>
            <param name="cto">
            <code>
            CTO is DOUBLE PRECISION
            The matrix A is multiplied by CTO/CFROM. A(I,J) is computed
            without over/underflow if the final result CTO*A(I,J)/CFROM
            can be represented without over/underflow.  CFROM must be
            nonzero.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The matrix to be multiplied by CTO/CFROM.  See TYPE for the
            storage type.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            0  - successful exit
            &amp;lt;0 - if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is done without over/underflow as long as the final
            result CTO*A(I,J)/CFROM does not over/underflow. TYPE specifies that
            A may be full, upper triangular, lower triangular, upper Hessenberg,
            or banded.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dladiv(`0,`0,`0,`0,`0@,`0@)">
            <summary>
            <para>
            Performs complex division in  real arithmetic
                                  a + i*b
                       p + i*q = ---------
                                  c + i*d
            The algorithm is due to Robert L.</para>
            </summary>
            <param name="a">
            <code>
            A is DOUBLE PRECISION
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION
            The scalars a, b, c, and d in the above expression.
            </code>
            </param>
            <param name="p">
            <code>
            P is DOUBLE PRECISION
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION
            The scalars p and q in the above expression.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Smith and can be found
            in D. Knuth, The art of Computer Programming, Vol.2, p.195
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaln2(System.Boolean,System.Int32,System.Int32,`0,`0,Extreme.Collections.Array2D{`0},`0,`0,Extreme.Collections.Array2D{`0},`0,`0,Extreme.Collections.Array2D{`0},`0@,`0@,System.Int32@)">
            <summary>
            <para>
            Solves a system of the form  (ca A - w D ) X = s B
            or (ca A**T - w D) X = s B   with possible scaling ("s") and
            perturbation of A.</para>
            </summary>
            <param name="ltrans">
            <code>
            LTRANS is LOGICAL
            =.TRUE.:  A-transpose will be used.
            =.FALSE.: A will be used (not transposed.)
            </code>
            </param>
            <param name="na">
            <code>
            NA is INTEGER
            The size of the matrix A.  It may (only) be 1 or 2.
            </code>
            </param>
            <param name="nw">
            <code>
            NW is INTEGER
            1 if "w" is real, 2 if "w" is complex.  It may only be 1
            or 2.
            </code>
            </param>
            <param name="smin">
            <code>
            SMIN is DOUBLE PRECISION
            The desired lower bound on the singular values of A.  This
            should be a safe distance away from underflow or overflow,
            say, between (underflow/machine precision) and  (machine
            precision * overflow ).  (See BIGNUM and ULP.)
            </code>
            </param>
            <param name="ca">
            <code>
            CA is DOUBLE PRECISION
            The coefficient c, which A is multiplied by.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,NA)
            The NA x NA matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of A.  It must be at least NA.
            </code>
            </param>
            <param name="d1">
            <code>
            D1 is DOUBLE PRECISION
            The 1,1 element in the diagonal matrix D.
            </code>
            </param>
            <param name="d2">
            <code>
            D2 is DOUBLE PRECISION
            The 2,2 element in the diagonal matrix D.  Not used if NW=1.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NW)
            The NA x NW matrix B (right-hand side).  If NW=2 ("w" is
            complex), column 1 contains the real part of B and column 2
            contains the imaginary part.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of B.  It must be at least NA.
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION
            The real part of the scalar "w".
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION
            The imaginary part of the scalar "w".  Not used if NW=1.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (LDX,NW)
            The NA x NW matrix X (unknowns), as computed by DLALN2.
            If NW=2 ("w" is complex), on exit, column 1 will contain
            the real part of X and column 2 will contain the imaginary
            part.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of X.  It must be at least NA.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION
            The scale factor that B must be multiplied by to insure
            that overflow does not occur when computing X.  Thus,
            (ca A - w D) X  will be SCALE*B, not B (ignoring
            perturbations of A.)  It will be at most 1.
            </code>
            </param>
            <param name="xnorm">
            <code>
            XNORM is DOUBLE PRECISION
            The infinity-norm of X, when X is regarded as an NA x NW
            real matrix.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            An error flag.  It will be set to zero if no error occurs,
            a negative number if an argument is in error, or a positive
            number if  ca A - w D  had to be perturbed.
            The possible values are:
            = 0: No error occurred, and (ca A - w D) did not have to be
                   perturbed.
            = 1: (ca A - w D) had to be perturbed to make its smallest
                 (or only) singular value greater than SMIN.
            NOTE: In the interests of speed, this routine does not
                  check the inputs for errors.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            (A**T means A-transpose.)
            A is an NA x NA real matrix, ca is a real scalar, D is an NA x NA
            real diagonal matrix, w is a real or complex value, and X and B are
            NA x 1 matrices -- real if w is real, complex if w is complex.  NA
            may be 1 or 2.
            If w is complex, X and B are represented as NA x 2 matrices,
            the first column of each being the real part and the second
            being the imaginary part.
            "s" is a scaling factor (.LE. 1), computed by DLALN2, which is
            so chosen that X can be computed without overflow.  X is further
            scaled if necessary to assure that norm(ca A - w D)*norm(X) is less
            than overflow.
            If both singular values of (ca A - w D) are less than SMIN,
            SMIN*identity will be used instead of (ca A - w D).  If only one
            singular value is less than SMIN, one element of (ca A - w D) will be
            perturbed enough to make the smallest singular value roughly SMIN.
            If both singular values are at least SMIN, (ca A - w D) will not be
            perturbed.  In any case, the perturbation will be at most some small
            multiple of max( SMIN, ulp*norm(ca A - w D) ).  The singular values
            are computed by infinity-norm approximations, and thus will only be
            correct to a factor of 2 or so.
            Note: all input quantities are assumed to be smaller than overflow
            by a reasonable factor.  (See BIGNUM.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqp2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of
            the block A(OFFSET+1:M,1:N).</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0.
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of the matrix A that must be pivoted
            but no factorized. OFFSET >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of block A(OFFSET+1:M,1:N) is
            the triangular factor obtained; the elements in block
            A(OFFSET+1:M,1:N) below the diagonal, together with the
            array TAU, represent the orthogonal matrix Q as a product of
            elementary reflectors. Block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is DOUBLE PRECISION array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is DOUBLE PRECISION array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaqps(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Computes a step of QR factorization with column pivoting
            of a real M-by-N matrix A by using Blas-3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="offset">
            <code>
            OFFSET is INTEGER
            The number of rows of A that have been factorized in
            previous steps.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of columns to factorize.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns actually factorized.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, block A(OFFSET+1:M,1:KB) is the triangular
            factor obtained and block A(1:OFFSET,1:N) has been
            accordingly pivoted, but no factorized.
            The rest of the matrix, block A(OFFSET+1:M,KB+1:N) has
            been updated.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            JPVT(I) = K &amp;lt;==> Column K of the full matrix A has been
            permuted into position I in AP.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (KB)
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="vn1">
            <code>
            VN1 is DOUBLE PRECISION array, dimension (N)
            The vector with the partial column norms.
            </code>
            </param>
            <param name="vn2">
            <code>
            VN2 is DOUBLE PRECISION array, dimension (N)
            The vector with the exact column norms.
            </code>
            </param>
            <param name="auxv">
            <code>
            AUXV is DOUBLE PRECISION array, dimension (NB)
            Auxiliar vector.
            </code>
            </param>
            <param name="f">
            <code>
            F is DOUBLE PRECISION array, dimension (LDF,NB)
            Matrix F**T = L*Y**T*A.
            </code>
            <code>
            LDF is INTEGER
            The leading dimension of the array F. LDF >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It tries to factorize
            NB columns from A starting from the row OFFSET+1, and updates all
            of the matrix with Blas-3 xGEMM.
            In some cases, due to catastrophic cancellations, it cannot
            factorize NB columns.  Hence, the actual number of factorized
            columns is returned in KB.
            Block A(1:OFFSET,1:N) is accordingly pivoted, but not factorized.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>
             Partial column norm updating strategy modified on April 2011
               Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
               University of Zagreb, Croatia.
            </para>
            <h4> References:</h4>
            <para>
            LAPACK Working Note 176
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricTridiagonalMatrixNorm(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric tridiagonal matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in DLANST as described
            above.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, DLANST is
            set to zero.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The diagonal elements of A.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The (n-1) sub-diagonal or super-diagonal elements of A.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            DLANST = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlamrg(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Will create a permutation list which will merge the elements
            of A (which is composed of two independently sorted sets) into a
            single set which is sorted in ascending order.</para>
            </summary>
            <param name="n1">
            <code>
            N1 is INTEGER
            </code>
            </param>
            <param name="n2">
            <code>
            N2 is INTEGER
            These arguements contain the respective lengths of the two
            sorted lists to be merged.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (N1+N2)
            The first N1 elements of A contain a list of numbers which
            are sorted in either ascending or descending order.  Likewise
            for the final N2 elements.
            </code>
            </param>
            <param name="dtrd1">
            <code>
            DTRD1 is INTEGER
            </code>
            </param>
            <param name="dtrd2">
            <code>
            DTRD2 is INTEGER
            These are the strides to be taken through the array A.
            Allowable strides are 1 and -1.  They indicate whether a
            subset of A is sorted in ascending (DTRDx = 1) or descending
            (DTRDx = -1) order.
            </code>
            </param>
            <param name="index">
            <code>
            INDEX is INTEGER array, dimension (N1+N2)
            On exit this array will contain a permutation such that
            if B( I ) = A( INDEX( I ) ) for I=1,N1+N2, then B will be
            sorted in ascending order.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd2(System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of singular values together into a single
            sorted set.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix,
            This is the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension(N)
            On entry D contains the singular values of the two submatrices
            to be combined.  On exit D contains the trailing (N-K) updated
            singular values (those which were deflated) sorted into
            increasing order.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension(N)
            On exit Z contains the updating row vector in the secular
            equation.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension(LDU,N)
            On entry U contains the left singular vectors of two
            submatrices in the two square blocks with corners at (1,1),
            (NL, NL), and (NL+2, NL+2), (N,N).
            On exit U contains the trailing (N-K) updated left singular
            vectors (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= N.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension(LDVT,M)
            On entry VT**T contains the right singular vectors of two
            submatrices in the two square blocks with corners at (1,1),
            (NL+1, NL+1), and (NL+2, NL+2), (M,M).
            On exit VT**T contains the trailing (N-K) updated right singular
            vectors (those which were deflated) in its last N-K columns.
            In case SQRE =1, the last row of VT spans the right null
            space.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= M.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is DOUBLE PRECISION array, dimension (N)
            Contains a copy of the diagonal elements (K-1 singular values
            and one zero) in the secular equation.
            </code>
            </param>
            <param name="u2">
            <code>
            U2 is DOUBLE PRECISION array, dimension(LDU2,N)
            Contains a copy of the first K-1 left singular vectors which
            will be used by DLASD3 in a matrix multiply (DGEMM) to solve
            for the new left singular vectors. U2 is arranged into four
            blocks. The first block contains a column with 1 at NL+1 and
            zero everywhere else; the second block contains non-zero
            entries only at and above NL; the third contains non-zero
            entries only below NL+1; and the fourth is dense.
            </code>
            <code>
            LDU2 is INTEGER
            The leading dimension of the array U2.  LDU2 >= N.
            </code>
            </param>
            <param name="vt2">
            <code>
            VT2 is DOUBLE PRECISION array, dimension(LDVT2,N)
            VT2**T contains a copy of the first K right singular vectors
            which will be used by DLASD3 in a matrix multiply (DGEMM) to
            solve for the new right singular vectors. VT2 is arranged into
            three blocks. The first block contains a row that corresponds
            to the special 0 diagonal element in SIGMA; the second block
            contains non-zeros only at and before NL +1; the third block
            contains non-zeros only at and after  NL +2.
            </code>
            <code>
            LDVT2 is INTEGER
            The leading dimension of the array VT2.  LDVT2 >= M.
            </code>
            </param>
            <param name="idxp">
            <code>
            IDXP is INTEGER array dimension(N)
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output IDXP(2:K)
            points to the nondeflated D-values and IDXP(K+1:N)
            points to the deflated singular values.
            </code>
            </param>
            <param name="idx">
            <code>
            IDX is INTEGER array dimension(N)
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="idxc">
            <code>
            IDXC is INTEGER array dimension(N)
            This will contain the permutation used to arrange the columns
            of the deflated U matrix into three groups:  the first group
            contains non-zero entries only at and above NL, the second
            contains non-zero entries only below NL+2, and the third is
            dense.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array dimension(N)
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that entries in
            the first hlaf of this permutation must first be moved one
            position backward; and entries in the second half
            must first have NL+1 added to their values.
            </code>
            </param>
            <param name="coltyp">
            <code>
            COLTYP is INTEGER array dimension(N)
            As workspace, this will contain a label which will indicate
            which of the following types a column in the U2 matrix or a
            row in the VT2 matrix is:
            1 : non-zero in the upper half only
            2 : non-zero in the lower half only
            3 : dense
            4 : deflated
            On exit, it is an array of dimension 4, with COLTYP(I) being
            the dimension of the I-th type columns.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            singular values are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            DLASD2 is called from DLASD1.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed6(System.Int32,System.Boolean,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Computes the positive or negative root (closest to the origin)
            of
                             z(1)        z(2)        z(3)
            f(x) =   rho + --------- + ---------- + ---------
                            d(1)-x      d(2)-x      d(3)-x
            It is assumed that
                  if ORGATI = .</para>
            </summary>
            <param name="kniter">
            <code>
            KNITER is INTEGER
                 Refer to DLAED4 for its significance.
            </code>
            </param>
            <param name="orgati">
            <code>
            ORGATI is LOGICAL
                 If ORGATI is true, the needed root is between d(2) and
                 d(3); otherwise it is between d(1) and d(2).  See
                 DLAED4 for further details.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
                 Refer to the equation f(x) above.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (3)
                 D satisfies d(1) &amp;lt; d(2) &amp;lt; d(3).
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (3)
                 Each of the elements in z must be positive.
            </code>
            </param>
            <param name="finit">
            <code>
            FINIT is DOUBLE PRECISION
                 The value of f at 0. It is more accurate than the one
                 evaluated inside this routine (if someone wants to do
                 so).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
                 The root of the equation f(x).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
                 = 0: successful exit
                 > 0: if INFO = 1, failure to converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            true. the root is between d(2) and d(3);
                  otherwise it is between d(1) and d(2)
            This routine will be called by DLAED4 when necessary. In most cases,
            the root sought is the smallest in magnitude, though it might not be
            in some extremely rare situations.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            10/02/03: This version has a few statements commented out for thread
            safety (machine parameters are computed on each entry). SJH.
            05/10/06: Modified from a new version of Ren-Cang Li, use
               Gragg-Thornton-Warner cubic convergent scheme for better stability.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd5(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0@,Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Subroutine computes the square root of the I-th eigenvalue
            of a positive symmetric rank-one modification of a 2-by-2 diagonal
            matrix
                       diag( D ) * diag( D ) +  RHO * Z * transpose(Z) .</para>
            </summary>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( 2 )
            The original eigenvalues.  We assume 0 &amp;lt;= D(1) &amp;lt; D(2).
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 2 )
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is DOUBLE PRECISION array, dimension ( 2 )
            Contains (D(j) - sigma_I) in its  j-th component.
            The vector DELTA contains the information necessary
            to construct the eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is DOUBLE PRECISION
            The computed sigma_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension ( 2 )
            WORK contains (D(j) + sigma_I) in its  j-th component.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The diagonal entries in the array D are assumed to satisfy
                       0 &amp;lt;= D(i) &amp;lt; D(j)  for  i &amp;lt; j .
            We also assume RHO > 0 and that the Euclidean norm of the vector
            Z is one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd4(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Subroutine computes the square root of the I-th updated
            eigenvalue of a positive symmetric rank-one modification to
            a positive diagonal matrix whose entries are given as the squares
            of the corresponding entries in the array d, and that
                   0 &amp;lt;= D(i) &amp;lt; D(j)  for  i &amp;lt; j
            and that RHO > 0.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of all arrays.
            </code>
            </param>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  1 &amp;lt;= I &amp;lt;= N.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( N )
            The original eigenvalues.  It is assumed that they are in
            order, 0 &amp;lt;= D(I) &amp;lt; D(J)  for I &amp;lt; J.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( N )
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is DOUBLE PRECISION array, dimension ( N )
            If N .ne. 1, DELTA contains (D(j) - sigma_I) in its  j-th
            component.  If N = 1, then DELTA(1) = 1.  The vector DELTA
            contains the information necessary to construct the
            (singular) eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="sigma">
            <code>
            SIGMA is DOUBLE PRECISION
            The computed sigma_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension ( N )
            If N .ne. 1, WORK contains (D(j) + sigma_I) in its  j-th
            component.  If N = 1, then WORK( 1 ) = 1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            > 0:  if INFO = 1, the updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus
                   diag( D ) * diag( D ) +  RHO * Z * Z_transpose.
            where we assume the Euclidean norm of Z is 1.
            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd3(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Finds all the square roots of the roots of the secular
            equation, as defined by the values in D and Z.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The size of the secular equation, 1 =&amp;lt; K = &amp;lt; N.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension(K)
            On exit the square roots of the roots of the secular equation,
            in ascending order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array,
                       dimension at least (LDQ,K).
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= K.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is DOUBLE PRECISION array, dimension(K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU, N)
            The last N - K columns of this matrix contain the deflated
            left singular vectors.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= N.
            </code>
            </param>
            <param name="u2">
            <code>
            U2 is DOUBLE PRECISION array, dimension (LDU2, N)
            The first K columns of this matrix contain the non-deflated
            left singular vectors for the split problem.
            </code>
            <code>
            LDU2 is INTEGER
            The leading dimension of the array U2.  LDU2 >= N.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension (LDVT, M)
            The last M - K columns of VT**T contain the deflated
            right singular vectors.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= N.
            </code>
            </param>
            <param name="vt2">
            <code>
            VT2 is DOUBLE PRECISION array, dimension (LDVT2, N)
            The first K columns of VT2**T contain the non-deflated
            right singular vectors for the split problem.
            </code>
            <code>
            LDVT2 is INTEGER
            The leading dimension of the array VT2.  LDVT2 >= N.
            </code>
            </param>
            <param name="idxc">
            <code>
            IDXC is INTEGER array, dimension ( N )
            The permutation used to arrange the columns of U (and rows of
            VT) into three groups:  the first group contains non-zero
            entries only at and above (or before) NL +1; the second
            contains non-zero entries only at and below (or after) NL+2;
            and the third is dense. The first column of U and the row of
            VT are treated separately, however.
            The rows of the singular vectors found by DLASD4
            must be likewise permuted before the matrix multiplies can
            take place.
            </code>
            </param>
            <param name="ctot">
            <code>
            CTOT is INTEGER array, dimension ( 4 )
            A count of the total number of the various types of columns
            in U (or rows in VT), as described in IDXC. The fourth column
            type is any column which has been deflated.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating row vector.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to DLASD4 and then updates the singular
            vectors by matrix multiplication.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray XMP, Cray YMP, Cray C 90, or Cray 2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            DLASD3 is called from DLASD1.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd1(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},`0@,`0@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the SVD of an upper bidiagonal N-by-M matrix B,
            where N = NL + NR + 1 and M = N + SQRE.</para>
            </summary>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has row dimension N = NL + NR + 1,
            and column dimension M = N + SQRE.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array,
                          dimension (N = NL+NR+1).
            On entry D(1:NL,1:NL) contains the singular values of the
            upper block; and D(NL+2:N) contains the singular values of
            the lower block. On exit D(1:N) contains the singular values
            of the modified matrix.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension(LDU,N)
            On entry U(1:NL, 1:NL) contains the left singular vectors of
            the upper block; U(NL+2:N, NL+2:N) contains the left singular
            vectors of the lower block. On exit U contains the left
            singular vectors of the bidiagonal matrix.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= max( 1, N ).
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension(LDVT,M)
            where M = N + SQRE.
            On entry VT(1:NL+1, 1:NL+1)**T contains the right singular
            vectors of the upper block; VT(NL+2:M, NL+2:M)**T contains
            the right singular vectors of the lower block. On exit
            VT**T contains the right singular vectors of the
            bidiagonal matrix.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= max( 1, M ).
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension(N)
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order, i.e.
            D( IDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension( 4 * N )
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension( 3*M**2 + 2*M )
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            DLASD1 is called from DLASD0.
            A related subroutine DLASD7 handles the case in which the singular
            values (and the singular vectors in factored form) are desired.
            DLASD1 computes the SVD as follows:
                          ( D1(in)    0    0       0 )
              B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
                          (   0       0   D2(in)   0 )
                = U(out) * ( D(out) 0) * VT(out)
            where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
            with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            elsewhere; and the entry b is empty if SQRE = 0.
            The left singular vectors of the original matrix are stored in U, and
            the transpose of the right singular vectors are stored in VT, and the
            singular values are in D.  The algorithm consists of three stages:
               The first stage consists of deflating the size of the problem
               when there are multiple singular values or when there are zeros in
               the Z vector.  For each such occurence the dimension of the
               secular equation problem is reduced by one.  This stage is
               performed by the routine DLASD2.
               The second stage consists of calculating the updated
               singular values. This is done by finding the square roots of the
               roots of the secular equation via the routine DLASD4 (as called
               by DLASD3). This routine also calculates the singular vectors of
               the current problem.
               The final stage consists of computing the updated singular vectors
               directly using the updated singular values.  The singular vectors
               for the current problem are multiplied with the singular vectors
               from the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlas2(`0,`0,`0,`0@,`0@)">
            <summary>
            <para>
            Computes the singular values of the 2-by-2 matrix
               [  F   G  ]
               [  0   H  ].</para>
            </summary>
            <param name="f">
            <code>
            F is DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="g">
            <code>
            G is DOUBLE PRECISION
            The (1,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is DOUBLE PRECISION
            The smaller singular value.
            </code>
            </param>
            <param name="ssmax">
            <code>
            SSMAX is DOUBLE PRECISION
            The larger singular value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, SSMIN is the smaller singular value and SSMAX is the
            larger singular value.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Barring over/underflow, all output quantities are correct to within
            a few units in the last place (ulps), even in the absence of a guard
            digit in addition/subtraction.
            In IEEE arithmetic, the code works correctly if one matrix element is
            infinite.
            Overflow will not occur unless the largest singular value itself
            overflows, or is within a few ulps of overflow. (On machines with
            partial overflow, like the Cray, overflow may occur if the largest
            singular value is within a factor of 2 of overflow.)
            Underflow is harmless if underflow is gradual. Otherwise, results
            may correspond to a matrix modified by perturbations of size near
            the underflow threshold.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq4(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,System.Int32,`0,`0,`0,`0,`0,`0,`0@,System.Int32@,`0@)">
            <summary>
            <para>
            Computes an approximation TAU to the smallest eigenvalue
            using values of d from the previous transform.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 4*N )
            Z holds the qd array.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="n0in">
            <code>
            N0IN is INTEGER
            he value of N0 at start of EIGTEST.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is DOUBLE PRECISION
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is DOUBLE PRECISION
            (N)
            </code>
            </param>
            <param name="dn1">
            <code>
            DN1 is DOUBLE PRECISION
            (N-1)
            </code>
            </param>
            <param name="dn2">
            <code>
            DN2 is DOUBLE PRECISION
            (N-2)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            his is the shift.
            </code>
            </param>
            <param name="ttype">
            <code>
            TTYPE is INTEGER
            hift type.
            </code>
            </param>
            <param name="g">
            <code>
            G is REAL
            G is passed as an argument in order to save its value between
            calls to DLASQ4.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            CNST1 = 9/16
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq5(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,`0,`0,`0@,`0@,`0@,`0@,`0@,`0@,System.Boolean,`0)">
            <summary>
            <para>
            Computes one dqds transform in ping-pong form, one
            version for IEEE machines another for non IEEE machines.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 4*N )
            Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            an extra argument.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            his is the shift.
            </code>
            </param>
            <param name="sigma">
            <code>
            SIGMA is DOUBLE PRECISION
            his is the accumulated shift up to this step.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is DOUBLE PRECISION
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is DOUBLE PRECISION
            (N0), the last value of d.
            </code>
            </param>
            <param name="dnm1">
            <code>
            DNM1 is DOUBLE PRECISION
            (N0-1).
            </code>
            </param>
            <param name="dnm2">
            <code>
            DNM2 is DOUBLE PRECISION
            (N0-2).
            </code>
            </param>
            <param name="ieee">
            <code>
            IEEE is LOGICAL
            lag for IEEE or non IEEE arithmetic.
            </code>
            </param>
            <param name="eps">
            <code>
            EPS is DOUBLE PRECISION
            his is the value of epsilon used.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq6(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,`0@,`0@,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Computes one dqd (shift equal to zero) transform in
            ping-pong form, with protection against underflow and overflow.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            irst index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            ast index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 4*N )
            Z holds the qd array. EMIN is stored in Z(4*N0) to avoid
            an extra argument.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            P=0 for ping, PP=1 for pong.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is DOUBLE PRECISION
            inimum value of d.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ).
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is DOUBLE PRECISION
            inimum value of d, excluding D( N0 ) and D( N0-1 ).
            </code>
            </param>
            <param name="dn">
            <code>
            DN is DOUBLE PRECISION
            (N0), the last value of d.
            </code>
            </param>
            <param name="dnm1">
            <code>
            DNM1 is DOUBLE PRECISION
            (N0-1).
            </code>
            </param>
            <param name="dnm2">
            <code>
            DNM2 is DOUBLE PRECISION
            (N0-2).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq3(System.Int32,System.Int32@,Extreme.Collections.Array1D{`0},System.Int32@,`0@,`0@,`0@,`0,System.Int32@,System.Int32@,System.Int32@,System.Boolean,System.Int32@,`0@,`0@,`0@,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Checks for deflation, computes a shift (TAU) and calls dqds.</para>
            </summary>
            <param name="i0">
            <code>
            I0 is INTEGER
            First index.
            </code>
            </param>
            <param name="n0">
            <code>
            N0 is INTEGER
            Last index.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 4*N )
            Z holds the qd array.
            </code>
            </param>
            <param name="pp">
            <code>
            PP is INTEGER
            PP=0 for ping, PP=1 for pong.
            PP=2 indicates that flipping was applied to the Z array
            and that the initial tests for deflation should not be
            performed.
            </code>
            </param>
            <param name="dmin">
            <code>
            DMIN is DOUBLE PRECISION
            Minimum value of d.
            </code>
            </param>
            <param name="sigma">
            <code>
            SIGMA is DOUBLE PRECISION
            Sum of shifts used in current segment.
            </code>
            </param>
            <param name="desig">
            <code>
            DESIG is DOUBLE PRECISION
            Lower order part of SIGMA
            </code>
            </param>
            <param name="qmax">
            <code>
            QMAX is DOUBLE PRECISION
            Maximum value of q.
            </code>
            </param>
            <param name="nfail">
            <code>
            NFAIL is INTEGER
            Number of times shift was too big.
            </code>
            </param>
            <param name="iter">
            <code>
            ITER is INTEGER
            Number of iterations.
            </code>
            </param>
            <param name="ndiv">
            <code>
            NDIV is INTEGER
            Number of divisions.
            </code>
            </param>
            <param name="ieee">
            <code>
            IEEE is LOGICAL
            Flag for IEEE or non IEEE arithmetic (passed to DLASQ5).
            </code>
            </param>
            <param name="ttype">
            <code>
            TTYPE is INTEGER
            Shift type.
            </code>
            </param>
            <param name="dmin1">
            <code>
            DMIN1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="dmin2">
            <code>
            DMIN2 is DOUBLE PRECISION
            </code>
            </param>
            <param name="dn">
            <code>
            DN is DOUBLE PRECISION
            </code>
            </param>
            <param name="dn1">
            <code>
            DN1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="dn2">
            <code>
            DN2 is DOUBLE PRECISION
            </code>
            </param>
            <param name="g">
            <code>
            G is DOUBLE PRECISION
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION
            These are passed as arguments in order to save their values
            between calls to DLASQ3.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            In case of failure it changes shifts, and tries again until output
            is positive.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasrt(System.Char,System.Int32,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            The numbers in D in increasing order (if ID = 'I') or
            in decreasing order (if ID = 'D' ).</para>
            </summary>
            <param name="id">
            <code>
            ID is CHARACTER*1
            = 'I': sort D in increasing order;
            = 'D': sort D in decreasing order.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The length of the array D.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the array to be sorted.
            On exit, D has been sorted into increasing order
            (D(1) &amp;lt;= ... &amp;lt;= D(N) ) or into decreasing order
            (D(1) >= ... >= D(N) ), depending on ID.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Use Quick Sort, reverting to Insertion sort on arrays of
            size &amp;lt;= 20. Dimension of STACK limits N to about 2**32.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq2(System.Int32,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all the eigenvalues of the symmetric positive
            definite tridiagonal matrix associated with the qd array Z to high
            relative accuracy are computed to high relative accuracy, in the
            absence of denormalization, underflow and overflow.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            he number of rows and columns in the matrix. N >= 0.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( 4*N )
            n entry Z holds the qd array. On exit, entries 1 to N hold
            the eigenvalues in decreasing order, Z( 2*N+1 ) holds the
            trace, and Z( 2*N+2 ) holds the sum of the eigenvalues. If
            N > 2, then Z( 2*N+3 ) holds the iteration count, Z( 2*N+4 )
            holds NDIVS/NIN^2, and Z( 2*N+5 ) holds the percentage of
            shifts that failed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if the i-th argument is a scalar and had an illegal
                 value, then INFO = -i, if the i-th argument is an
                 array and the j-entry had an illegal value, then
                 INFO = -(i*100+j)
            > 0: the algorithm failed
                  = 1, a split was marked by a positive value in E
                  = 2, current block of Z not diagonalized after 100*N
                       iterations (in inner while loop).  On exit Z holds
                       a qd array with the same eigenvalues as the given Z.
                  = 3, termination criterion of outer while loop not met
                       (program created more than N unreduced blocks)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            To see the relation of Z to the tridiagonal matrix, let L be a
            unit lower bidiagonal matrix with subdiagonals Z(2,4,6,,..) and
            let U be an upper bidiagonal matrix with 1's above and diagonal
            Z(1,3,5,,..). The tridiagonal is L*U or, if you prefer, the
            symmetric tridiagonal to which it is similar.
            Note : DLASQ2 defines a logical variable, IEEE, which is true
            on machines which follow ieee-754 floating-point standard in their
            handling of infinities and NaNs, and false otherwise. This variable
            is passed to DLASQ3.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Local Variables: I0:N0 defines a current unreduced segment of Z.
            The shifts are accumulated in SIGMA. Iteration count is in ITER.
            Ping-pong is controlled by PP (alternates between 0 and 1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasq1(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the singular values of a real N-by-N bidiagonal
            matrix with diagonal D and off-diagonal E.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            he number of rows and columns in the matrix. N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            n entry, D contains the diagonal elements of the
            bidiagonal matrix whose SVD is desired. On normal exit,
            D contains the singular values in decreasing order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N)
            n entry, elements E(1:N-1) contain the off-diagonal elements
            of the bidiagonal matrix whose SVD is desired.
            On exit, E is overwritten.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: the algorithm failed
                 = 1, a split was marked by a positive value in E
                 = 2, current block of Z not diagonalized after 100*N
                      iterations (in inner while loop)  On exit D and E
                      represent a matrix with the same singular values
                      which the calling subroutine could use to finish the
                      computation, or even feed back into DLASQ1
                 = 3, termination criterion of outer while loop not met
                      (program created more than N unreduced blocks)
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The singular values
            are computed to high relative accuracy, in the absence of
            denormalization, underflow and overflow. The algorithm was first
            presented in
            "Accurate singular values and differential qd algorithms" by K. V.
            Fernando and B. N. Parlett, Numer. Math., Vol-67, No. 2, pp. 191-230,
            1994,
            and the present implementation is described in "An implementation of
            the dqds Algorithm (Positive Case)", LAPACK Working Note.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasr(Extreme.Mathematics.MatrixOperationSide,System.Char,System.Char,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Applies a sequence of plane rotations to a real matrix A,
            from either the left or the right.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            Specifies whether the plane rotation matrix P is applied to
            A on the left or the right.
            = 'L':  Left, compute A := P*A
            = 'R':  Right, compute A:= A*P**T
            </code>
            </param>
            <param name="pivot">
            <code>
            PIVOT is CHARACTER*1
            Specifies the plane for which P(k) is a plane rotation
            matrix.
            = 'V':  Variable pivot, the plane (k,k+1)
            = 'T':  Top pivot, the plane (1,k+1)
            = 'B':  Bottom pivot, the plane (k,z)
            </code>
            </param>
            <param name="direct">
            <code>
            DIRECT is CHARACTER*1
            Specifies whether P is a forward or backward sequence of
            plane rotations.
            = 'F':  Forward, P = P(z-1)*...*P(2)*P(1)
            = 'B':  Backward, P = P(1)*P(2)*...*P(z-1)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  If m &amp;lt;= 1, an immediate
            return is effected.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  If n &amp;lt;= 1, an
            immediate return is effected.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The cosines c(k) of the plane rotations.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension
                    (M-1) if SIDE = 'L'
                    (N-1) if SIDE = 'R'
            The sines s(k) of the plane rotations.  The 2-by-2 plane
            rotation part of the matrix P(k), R(k), has the form
            R(k) = (  c(k)  s(k) )
                   ( -s(k)  c(k) ).
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The M-by-N matrix A.  On exit, A is overwritten by P*A if
            SIDE = 'R' or by A*P**T if SIDE = 'L'.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            When SIDE = 'L', the transformation takes the form
               A := P*A
            and when SIDE = 'R', the transformation takes the form
               A := A*P**T
            where P is an orthogonal matrix consisting of a sequence of z plane
            rotations, with z = M when SIDE = 'L' and z = N when SIDE = 'R',
            and P**T is the transpose of P.
            When DIRECT = 'F' (Forward sequence), then
               P = P(z-1) * ... * P(2) * P(1)
            and when DIRECT = 'B' (Backward sequence), then
               P = P(1) * P(2) * ... * P(z-1)
            where P(k) is a plane rotation matrix defined by the 2-by-2 rotation
               R(k) = (  c(k)  s(k) )
                    = ( -s(k)  c(k) ).
            When PIVOT = 'V' (Variable pivot), the rotation is performed
            for the plane (k,k+1), i.e., P(k) has the form
               P(k) = (  1                                            )
                      (       ...                                     )
                      (              1                                )
                      (                   c(k)  s(k)                  )
                      (                  -s(k)  c(k)                  )
                      (                                1              )
                      (                                     ...       )
                      (                                            1  )
            where R(k) appears as a rank-2 modification to the identity matrix in
            rows and columns k and k+1.
            When PIVOT = 'T' (Top pivot), the rotation is performed for the
            plane (1,k+1), so P(k) has the form
               P(k) = (  c(k)                    s(k)                 )
                      (         1                                     )
                      (              ...                              )
                      (                     1                         )
                      ( -s(k)                    c(k)                 )
                      (                                 1             )
                      (                                      ...      )
                      (                                             1 )
            where R(k) appears in rows and columns 1 and k+1.
            Similarly, when PIVOT = 'B' (Bottom pivot), the rotation is
            performed for the plane (k,z), giving P(k) the form
               P(k) = ( 1                                             )
                      (      ...                                      )
                      (             1                                 )
                      (                  c(k)                    s(k) )
                      (                         1                     )
                      (                              ...              )
                      (                                     1         )
                      (                 -s(k)                    c(k) )
            where R(k) appears in rows and columns k and z.  The rotations are
            performed without ever forming P(k) explicitly.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasv2(`0,`0,`0,`0@,`0@,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Computes the singular value decomposition of a 2-by-2
            triangular matrix
               [  F   G  ]
               [  0   H  ].</para>
            </summary>
            <param name="f">
            <code>
            F is DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="g">
            <code>
            G is DOUBLE PRECISION
            The (1,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is DOUBLE PRECISION
            abs(SSMIN) is the smaller singular value.
            </code>
            </param>
            <param name="ssmax">
            <code>
            SSMAX is DOUBLE PRECISION
            abs(SSMAX) is the larger singular value.
            </code>
            </param>
            <param name="snl">
            <code>
            SNL is DOUBLE PRECISION
            </code>
            </param>
            <param name="csl">
            <code>
            CSL is DOUBLE PRECISION
            The vector (CSL, SNL) is a unit left singular vector for the
            singular value abs(SSMAX).
            </code>
            </param>
            <param name="snr">
            <code>
            SNR is DOUBLE PRECISION
            </code>
            </param>
            <param name="csr">
            <code>
            CSR is DOUBLE PRECISION
            The vector (CSR, SNR) is a unit right singular vector for the
            singular value abs(SSMAX).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, abs(SSMAX) is the larger singular value, abs(SSMIN) is the
            smaller singular value, and (CSL,SNL) and (CSR,SNR) are the left and
            right singular vectors for abs(SSMAX), giving the decomposition
               [ CSL  SNL ] [  F   G  ] [ CSR -SNR ]  =  [ SSMAX   0   ]
               [-SNL  CSL ] [  0   H  ] [ SNR  CSR ]     [  0    SSMIN ].
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Any input parameter may be aliased with any output parameter.
            Barring over/underflow and assuming a guard digit in subtraction, all
            output quantities are correct to within a few units in the last
            place (ulps).
            In IEEE arithmetic, the code works correctly if one matrix element is
            infinite.
            Overflow will not occur unless the largest singular value itself
            overflows or is within a few ulps of overflow. (On machines with
            partial overflow, like the Cray, overflow may occur if the largest
            singular value is within a factor of 2 of overflow.)
            Underflow is harmless if underflow is gradual. Otherwise, results
            may correspond to a matrix modified by perturbations of size near
            the underflow threshold.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasdq(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            (upper or lower) bidiagonal matrix with diagonal D and offdiagonal
            E, accumulating the transformations if desired.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            n entry, UPLO specifies whether the input bidiagonal matrix
            is upper or lower bidiagonal, and wether it is square are
            not.
               UPLO = 'U' or 'u'   B is upper bidiagonal.
               UPLO = 'L' or 'l'   B is lower bidiagonal.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: then the input matrix is N-by-N.
            = 1: then the input matrix is N-by-(N+1) if UPLU = 'U' and
                 (N+1)-by-N if UPLU = 'L'.
            The bidiagonal matrix has
            N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            n entry, N specifies the number of rows and columns
            in the matrix. N must be at least 0.
            </code>
            </param>
            <param name="ncvt">
            <code>
            NCVT is INTEGER
            n entry, NCVT specifies the number of columns of
            the matrix VT. NCVT must be at least 0.
            </code>
            </param>
            <param name="nru">
            <code>
            NRU is INTEGER
            n entry, NRU specifies the number of rows of
            the matrix U. NRU must be at least 0.
            </code>
            </param>
            <param name="ncc">
            <code>
            NCC is INTEGER
            n entry, NCC specifies the number of columns of
            the matrix C. NCC must be at least 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            n entry, D contains the diagonal entries of the
            bidiagonal matrix whose SVD is desired. On normal exit,
            D contains the singular values in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array.
            imension is (N-1) if SQRE = 0 and N if SQRE = 1.
            On entry, the entries of E contain the offdiagonal entries
            of the bidiagonal matrix whose SVD is desired. On normal
            exit, E will contain 0. If the algorithm does not converge,
            D and E will contain the diagonal and superdiagonal entries
            of a bidiagonal matrix orthogonally equivalent to the one
            given as input.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
            n entry, contains a matrix which on exit has been
            premultiplied by P**T, dimension N-by-NCVT if SQRE = 0
            and (N+1)-by-NCVT if SQRE = 1 (not referenced if NCVT=0).
            </code>
            <code>
            LDVT is INTEGER
            n entry, LDVT specifies the leading dimension of VT as
            declared in the calling (sub) program. LDVT must be at
            least 1. If NCVT is nonzero LDVT must also be at least N.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU, N)
            n entry, contains a  matrix which on exit has been
            postmultiplied by Q, dimension NRU-by-N if SQRE = 0
            and NRU-by-(N+1) if SQRE = 1 (not referenced if NRU=0).
            </code>
            <code>
            LDU is INTEGER
            n entry, LDU  specifies the leading dimension of U as
            declared in the calling (sub) program. LDU must be at
            least max( 1, NRU ) .
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC, NCC)
            n entry, contains an N-by-NCC matrix which on exit
            has been premultiplied by Q**T  dimension N-by-NCC if SQRE = 0
            and (N+1)-by-NCC if SQRE = 1 (not referenced if NCC=0).
            </code>
            <code>
            LDC is INTEGER
            n entry, LDC  specifies the leading dimension of C as
            declared in the calling (sub) program. LDC must be at
            least 1. If NCC is nonzero, LDC must also be at least N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (4*N)
            orkspace. Only referenced if one of NCVT, NRU, or NCC is
            nonzero, and if N is at least 2.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            n exit, a value of 0 indicates a successful exit.
            If INFO &amp;lt; 0, argument number -INFO is illegal.
            If INFO > 0, the algorithm did not converge, and INFO
            specifies how many superdiagonals did not converge.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Letting B denote
            the input bidiagonal matrix, the algorithm computes orthogonal
            matrices Q and P such that B = Q * S * P**T (P**T denotes the transpose
            of P). The singular values S are overwritten on D.
            The input matrix U  is changed to U  * Q  if desired.
            The input matrix VT is changed to P**T * VT if desired.
            The input matrix C  is changed to Q**T * C  if desired.
            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3, for a detailed description of the algorithm.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasdt(System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32)">
            <summary>
            <para>
            Creates a tree of subproblems for bidiagonal divide and
            conquer.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            On entry, the number of diagonal elements of the
            bidiagonal matrix.
            </code>
            </param>
            <param name="lvl">
            <code>
            LVL is INTEGER
            On exit, the number of levels on the computation tree.
            </code>
            </param>
            <param name="nd">
            <code>
            ND is INTEGER
            On exit, the number of nodes on the tree.
            </code>
            </param>
            <param name="inode">
            <code>
            INODE is INTEGER array, dimension ( N )
            On exit, centers of subproblems.
            </code>
            </param>
            <param name="ndiml">
            <code>
            NDIML is INTEGER array, dimension ( N )
            On exit, row dimensions of left children.
            </code>
            </param>
            <param name="ndimr">
            <code>
            NDIMR is INTEGER array, dimension ( N )
            On exit, row dimensions of right children.
            </code>
            </param>
            <param name="msub">
            <code>
            MSUB is INTEGER
            On entry, the maximum row dimension each subproblem at the
            bottom of the tree can be of.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd0(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            A divide and conquer approach, DLASD0 computes the singular
            value decomposition (SVD) of a real upper bidiagonal N-by-M
            matrix B with diagonal D and offdiagonal E, where M = N + SQRE.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            On entry, the row dimension of the upper bidiagonal matrix.
            This is also the dimension of the main diagonal array D.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            Specifies the column dimension of the bidiagonal matrix.
            = 0: The bidiagonal matrix has column dimension M = N;
            = 1: The bidiagonal matrix has column dimension M = N+1;
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry D contains the main diagonal of the bidiagonal
            matrix.
            On exit D, if INFO = 0, contains its singular values.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (M-1)
            Contains the subdiagonal entries of the bidiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension at least (LDQ, N)
            On exit, U contains the left singular vectors.
            </code>
            <code>
            LDU is INTEGER
            On entry, leading dimension of U.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension at least (LDVT, M)
            On exit, VT**T contains the right singular vectors.
            </code>
            <code>
            LDVT is INTEGER
            On entry, leading dimension of VT.
            </code>
            </param>
            <param name="smlsiz">
            <code>
            SMLSIZ is INTEGER
            On entry, maximum size of the subproblems at the
            bottom of the computation tree.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER work array.
            Dimension must be at least (8 * N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION work array.
            Dimension must be at least (3 * M**2 + 2 * M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The algorithm computes orthogonal matrices U and VT such that
            B = U * S * VT. The singular values S are overwritten on D.
            A related subroutine, DLASDA, computes only the singular values,
            and optionally, the singular vectors in compact form.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{`0},System.Int32,`0@,`0@,System.Int32@)">
            <summary>
            <para>
            Merges the two sets of singular values together into a single
            sorted set.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows:
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper
                 bidiagonal matrix in compact form.
            </code>
            </param>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block. NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block. NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has
            N = NL + NR + 1 rows and
            M = N + SQRE >= N columns.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix, this is
            the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( N )
            On entry D contains the singular values of the two submatrices
            to be combined. On exit D contains the trailing (N-K) updated
            singular values (those which were deflated) sorted into
            increasing order.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( M )
            On exit Z contains the updating row vector in the secular
            equation.
            </code>
            </param>
            <param name="zw">
            <code>
            ZW is DOUBLE PRECISION array, dimension ( M )
            Workspace for Z.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is DOUBLE PRECISION array, dimension ( M )
            On entry, VF(1:NL+1) contains the first components of all
            right singular vectors of the upper block; and VF(NL+2:M)
            contains the first components of all right singular vectors
            of the lower block. On exit, VF contains the first components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vfw">
            <code>
            VFW is DOUBLE PRECISION array, dimension ( M )
            Workspace for VF.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is DOUBLE PRECISION array, dimension ( M )
            On entry, VL(1:NL+1) contains the  last components of all
            right singular vectors of the upper block; and VL(NL+2:M)
            contains the last components of all right singular vectors
            of the lower block. On exit, VL contains the last components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vlw">
            <code>
            VLW is DOUBLE PRECISION array, dimension ( M )
            Workspace for VL.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is DOUBLE PRECISION array, dimension ( N )
            Contains a copy of the diagonal elements (K-1 singular values
            and one zero) in the secular equation.
            </code>
            </param>
            <param name="idx">
            <code>
            IDX is INTEGER array, dimension ( N )
            This will contain the permutation used to sort the contents of
            D into ascending order.
            </code>
            </param>
            <param name="idxp">
            <code>
            IDXP is INTEGER array, dimension ( N )
            This will contain the permutation used to place deflated
            values of D at the end of the array. On output IDXP(2:K)
            points to the nondeflated D-values and IDXP(K+1:N)
            points to the deflated singular values.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension ( N )
            This contains the permutation which separately sorts the two
            sub-problems in D into ascending order.  Note that entries in
            the first half of this permutation must first be moved one
            position backward; and entries in the second half
            must first have NL+1 added to their values.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension ( N )
            The permutations (from deflation and sorting) to be applied
            to each singular block. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER
            The leading dimension of GIVCOL, must be at least N.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            Each number indicates the C or S value to be used in the
            corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgnum">
            <code>
            LDGNUM is INTEGER
            The leading dimension of GIVNUM, must be at least N.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            C contains garbage if SQRE =0 and the C-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION
            S contains garbage if SQRE =0 and the S-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem. There
            are two ways in which deflation can occur:  when two or more singular
            values are close together or if there is a tiny entry in the Z
            vector. For each such occurrence the order of the related
            secular equation problem is reduced by one.
            DLASD7 is called from DLASD6.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd8(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Finds the square roots of the roots of the secular equation,
            as defined by the values in DSIGMA and Z.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed in
            factored form in the calling routine:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved
            by DLASD4.  K >= 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( K )
            On output, D contains the updated singular values.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( K )
            On entry, the first K elements of this array contain the
            components of the deflation-adjusted updating row vector.
            On exit, Z is updated.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is DOUBLE PRECISION array, dimension ( K )
            On entry, VF contains  information passed through DBEDE8.
            On exit, VF contains the first K components of the first
            components of all right singular vectors of the bidiagonal
            matrix.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is DOUBLE PRECISION array, dimension ( K )
            On entry, VL contains  information passed through DBEDE8.
            On exit, VL contains the first K components of the last
            components of all right singular vectors of the bidiagonal
            matrix.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is DOUBLE PRECISION array, dimension ( K )
            On exit, DIFL(I) = D(I) - DSIGMA(I).
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is DOUBLE PRECISION array,
                     dimension ( LDDIFR, 2 ) if ICOMPQ = 1 and
                     dimension ( K ) if ICOMPQ = 0.
            On exit, DIFR(I,1) = D(I) - DSIGMA(I+1), DIFR(K,1) is not
            defined and will not be referenced.
            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.
            </code>
            <code>
            LDDIFR is INTEGER
            The leading dimension of DIFR, must be at least K.
            </code>
            </param>
            <param name="dsigma">
            <code>
            DSIGMA is DOUBLE PRECISION array, dimension ( K )
            On entry, the first K elements of this array contain the old
            roots of the deflated updating problem.  These are the poles
            of the secular equation.
            On exit, the elements of DSIGMA may be very slightly altered
            in value.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension at least 3 * K
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the appropriate
            calls to DLASD4, and stores, for each  element in D, the distance
            to its two nearest poles (elements in DSIGMA). It also updates
            the arrays VF and VL, the first and last components of all the
            right singular vectors of the original bidiagonal matrix.
            DLASD8 is called from DLASD6.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasd6(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0@,`0@,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@,`0@,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the SVD of an updated upper bidiagonal matrix B
            obtained by merging two smaller ones by appending a row.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed in
            factored form:
            = 0: Compute singular values only.
            = 1: Compute singular vectors in factored form as well.
            </code>
            </param>
            <param name="nl">
            <code>
            NL is INTEGER
            The row dimension of the upper block.  NL >= 1.
            </code>
            </param>
            <param name="nr">
            <code>
            NR is INTEGER
            The row dimension of the lower block.  NR >= 1.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            = 0: the lower block is an NR-by-NR square matrix.
            = 1: the lower block is an NR-by-(NR+1) rectangular matrix.
            The bidiagonal matrix has row dimension N = NL + NR + 1,
            and column dimension M = N + SQRE.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( NL+NR+1 ).
            On entry D(1:NL,1:NL) contains the singular values of the
            upper block, and D(NL+2:N) contains the singular values
            of the lower block. On exit D(1:N) contains the singular
            values of the modified matrix.
            </code>
            </param>
            <param name="vf">
            <code>
            VF is DOUBLE PRECISION array, dimension ( M )
            On entry, VF(1:NL+1) contains the first components of all
            right singular vectors of the upper block; and VF(NL+2:M)
            contains the first components of all right singular vectors
            of the lower block. On exit, VF contains the first components
            of all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is DOUBLE PRECISION array, dimension ( M )
            On entry, VL(1:NL+1) contains the  last components of all
            right singular vectors of the upper block; and VL(NL+2:M)
            contains the last components of all right singular vectors of
            the lower block. On exit, VL contains the last components of
            all right singular vectors of the bidiagonal matrix.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION
            Contains the diagonal element associated with the added row.
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION
            Contains the off-diagonal element associated with the added
            row.
            </code>
            </param>
            <param name="idxq">
            <code>
            IDXQ is INTEGER array, dimension ( N )
            This contains the permutation which will reintegrate the
            subproblem just solved back into sorted order, i.e.
            D( IDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension ( N )
            The permutations (from deflation and sorting) to be applied
            to each block. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension ( LDGCOL, 2 )
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER
            leading dimension of GIVCOL, must be at least N.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            Each number indicates the C or S value to be used in the
            corresponding Givens rotation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="ldgnum">
            <code>
            LDGNUM is INTEGER
            The leading dimension of GIVNUM and POLES, must be at least N.
            </code>
            </param>
            <param name="poles">
            <code>
            POLES is DOUBLE PRECISION array, dimension ( LDGNUM, 2 )
            On exit, POLES(1,*) is an array containing the new singular
            values obtained from solving the secular equation, and
            POLES(2,*) is an array containing the poles in the secular
            equation. Not referenced if ICOMPQ = 0.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is DOUBLE PRECISION array, dimension ( N )
            On exit, DIFL(I) is the distance between I-th updated
            (undeflated) singular value and the I-th (undeflated) old
            singular value.
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is DOUBLE PRECISION array,
                    dimension ( LDGNUM, 2 ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            On exit, DIFR(I, 1) is the distance between I-th updated
            (undeflated) singular value and the I+1-th (undeflated) old
            singular value.
            If ICOMPQ = 1, DIFR(1:K,2) is an array containing the
            normalizing factors for the right singular vector matrix.
            See DLASD8 for details on DIFL and DIFR.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension ( M )
            The first elements of this array contain the components
            of the deflation-adjusted updating row vector.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            Contains the dimension of the non-deflated matrix,
            This is the order of the related secular equation. 1 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            C contains garbage if SQRE =0 and the C-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION
            S contains garbage if SQRE =0 and the S-value of a Givens
            rotation related to the right null space if SQRE = 1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension ( 4 * M )
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension ( 3 * N )
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the problem which requires all singular
            values and optionally singular vector matrices in factored form.
            B is an N-by-M matrix with N = NL + NR + 1 and M = N + SQRE.
            A related subroutine, DLASD1, handles the case in which all singular
            values and singular vectors of the bidiagonal matrix are desired.
            DLASD6 computes the SVD as follows:
                          ( D1(in)    0    0       0 )
              B = U(in) * (   Z1**T   a   Z2**T    b ) * VT(in)
                          (   0       0   D2(in)   0 )
                = U(out) * ( D(out) 0) * VT(out)
            where Z**T = (Z1**T a Z2**T b) = u**T VT**T, and u is a vector of dimension M
            with ALPHA and BETA in the NL+1 and NL+2 th entries and zeros
            elsewhere; and the entry b is empty if SQRE = 0.
            The singular values of B can be computed using D1, D2, the first
            components of all the right singular vectors of the lower block, and
            the last components of all the right singular vectors of the upper
            block. These components are stored and updated in VF and VL,
            respectively, in DLASD6. Hence U and VT are not explicitly
            referenced.
            The singular values are stored in D. The algorithm consists of two
            stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple singular values or if there is a zero
                  in the Z vector. For each such occurence the dimension of the
                  secular equation problem is reduced by one. This stage is
                  performed by the routine DLASD7.
                  The second stage consists of calculating the updated
                  singular values. This is done by finding the roots of the
                  secular equation via the routine DLASD4 (as called by DLASD8).
                  This routine also updates VF and VL and computes the distances
                  between the updated singular values and the old singular
                  values.
            DLASD6 is called from DLASDA.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasda(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},System.Int32,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            A divide and conquer approach, DLASDA computes the singular
            value decomposition (SVD) of a real upper bidiagonal N-by-M matrix
            B with diagonal D and offdiagonal E, where M = N + SQRE.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            Specifies whether singular vectors are to be computed
            in compact form, as follows
            = 0: Compute singular values only.
            = 1: Compute singular vectors of upper bidiagonal
                 matrix in compact form.
            </code>
            </param>
            <param name="smlsiz">
            <code>
            SMLSIZ is INTEGER
            The maximum size of the subproblems at the bottom of the
            computation tree.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The row dimension of the upper bidiagonal matrix. This is
            also the dimension of the main diagonal array D.
            </code>
            </param>
            <param name="sqre">
            <code>
            SQRE is INTEGER
            Specifies the column dimension of the bidiagonal matrix.
            = 0: The bidiagonal matrix has column dimension M = N;
            = 1: The bidiagonal matrix has column dimension M = N + 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension ( N )
            On entry D contains the main diagonal of the bidiagonal
            matrix. On exit D, if INFO = 0, contains its singular values.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension ( M-1 )
            Contains the subdiagonal entries of the bidiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array,
            dimension ( LDU, SMLSIZ ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, U contains the left
            singular vector matrices of all subproblems at the bottom
            level.
            </code>
            <code>
            LDU is INTEGER, LDU = > N.
            The leading dimension of arrays U, VT, DIFL, DIFR, POLES,
            GIVNUM, and Z.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array,
            dimension ( LDU, SMLSIZ+1 ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, VT**T contains the right
            singular vector matrices of all subproblems at the bottom
            level.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array,
            dimension ( N ) if ICOMPQ = 1 and dimension 1 if ICOMPQ = 0.
            If ICOMPQ = 1, on exit, K(I) is the dimension of the I-th
            secular equation on the computation tree.
            </code>
            </param>
            <param name="difl">
            <code>
            DIFL is DOUBLE PRECISION array, dimension ( LDU, NLVL ),
            where NLVL = floor(log_2 (N/SMLSIZ))).
            </code>
            </param>
            <param name="difr">
            <code>
            DIFR is DOUBLE PRECISION array,
                    dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            If ICOMPQ = 1, on exit, DIFL(1:N, I) and DIFR(1:N, 2 * I - 1)
            record distances between singular values on the I-th
            level and singular values on the (I -1)-th level, and
            DIFR(1:N, 2 * I ) contains the normalizing factors for
            the right singular vector matrix. See DLASD8 for details.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array,
                    dimension ( LDU, NLVL ) if ICOMPQ = 1 and
                    dimension ( N ) if ICOMPQ = 0.
            The first K elements of Z(1, I) contain the components of
            the deflation-adjusted updating row vector for subproblems
            on the I-th level.
            </code>
            </param>
            <param name="poles">
            <code>
            POLES is DOUBLE PRECISION array,
            dimension ( LDU, 2 * NLVL ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, POLES(1, 2*I - 1) and
            POLES(1, 2*I) contain  the new and old singular values
            involved in the secular equations on the I-th level.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array,
            dimension ( N ) if ICOMPQ = 1, and not referenced if
            ICOMPQ = 0. If ICOMPQ = 1, on exit, GIVPTR( I ) records
            the number of Givens rotations performed on the I-th
            problem on the computation tree.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array,
            dimension ( LDGCOL, 2 * NLVL ) if ICOMPQ = 1, and not
            referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
            GIVCOL(1, 2 *I - 1) and GIVCOL(1, 2 *I) record the locations
            of Givens rotations performed on the I-th level on the
            computation tree.
            </code>
            </param>
            <param name="ldgcol">
            <code>
            LDGCOL is INTEGER, LDGCOL = > N.
            The leading dimension of arrays GIVCOL and PERM.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array,
            dimension ( LDGCOL, NLVL ) if ICOMPQ = 1, and not referenced
            if ICOMPQ = 0. If ICOMPQ = 1, on exit, PERM(1, I) records
            permutations done on the I-th level of the computation tree.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array,
            dimension ( LDU,  2 * NLVL ) if ICOMPQ = 1, and not
            referenced if ICOMPQ = 0. If ICOMPQ = 1, on exit, for each I,
            GIVNUM(1, 2 *I - 1) and GIVNUM(1, 2 *I) record the C- and S-
            values of Givens rotations performed on the I-th level on
            the computation tree.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array,
            dimension ( N ) if ICOMPQ = 1, and dimension 1 if ICOMPQ = 0.
            If ICOMPQ = 1 and the I-th subproblem is not square, on exit,
            C( I ) contains the C-value of a Givens rotation related to
            the right null space of the I-th subproblem.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension ( N ) if
            ICOMPQ = 1, and dimension 1 if ICOMPQ = 0. If ICOMPQ = 1
            and the I-th subproblem is not square, on exit, S( I )
            contains the S-value of a Givens rotation related to
            the right null space of the I-th subproblem.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
            (6 * N + (SMLSIZ + 1)*(SMLSIZ + 1)).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array.
            Dimension must be at least (7 * N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, a singular value did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The
            algorithm computes the singular values in the SVD B = U * S * VT.
            The orthogonal matrices U and VT are optionally computed in
            compact form.
            A related subroutine, DLASD0, computes the singular values and
            the singular vectors in explicit form.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlabrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Reduces the first NB rows and columns of a real general
            m by n matrix A to upper or lower bidiagonal form by an orthogonal
            transformation Q**T * A * P, and returns the matrices X and Y which
            are needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of leading rows and columns of A to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit, the first NB rows and columns of the matrix are
            overwritten; the rest of the array is unchanged.
            If m >= n, elements on and below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors; and
              elements above the diagonal in the first NB rows, with the
              array TAUP, represent the orthogonal matrix P as a product
              of elementary reflectors.
            If m &amp;lt; n, elements below the diagonal in the first NB
              columns, with the array TAUQ, represent the orthogonal
              matrix Q as a product of elementary reflectors, and
              elements on and above the diagonal in the first NB rows,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (NB)
            The diagonal elements of the first NB rows and columns of
            the reduced matrix.  D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (NB)
            The off-diagonal elements of the first NB rows and columns of
            the reduced matrix.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is DOUBLE PRECISION array dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is DOUBLE PRECISION array, dimension (NB)
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (LDX,NB)
            The m-by-nb matrix X required to update the unreduced part
            of A.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X. LDX >= max(1,M).
            </code>
            </param>
            <param name="y">
            <code>
            Y is DOUBLE PRECISION array, dimension (LDY,NB)
            The n-by-nb matrix Y required to update the unreduced part
            of A.
            </code>
            <code>
            LDY is INTEGER
            The leading dimension of the array Y. LDY >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, A is reduced to upper bidiagonal form; if m &amp;lt; n, to lower
            bidiagonal form.
            This is an auxiliary routine called by DGEBRD
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
               Q = H(1) H(2) . . . H(nb)  and  P = G(1) G(2) . . . G(nb)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors.
            If m >= n, v(1:i-1) = 0, v(i) = 1, and v(i:m) is stored on exit in
            A(i:m,i); u(1:i) = 0, u(i+1) = 1, and u(i+1:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n, v(1:i) = 0, v(i+1) = 1, and v(i+1:m) is stored on exit in
            A(i+2:m,i); u(1:i-1) = 0, u(i) = 1, and u(i:n) is stored on exit in
            A(i,i+1:n); tauq is stored in TAUQ(i) and taup in TAUP(i).
            The elements of the vectors v and u together form the m-by-nb matrix
            V and the nb-by-n matrix U**T which are needed, with X and Y, to apply
            the transformation to the unreduced part of the matrix, using a block
            update of the form:  A := A - V*Y**T - X*U**T.
            The contents of A on exit are illustrated by the following examples
            with nb = 2:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  1   1   u1  u1  u1 )           (  1   u1  u1  u1  u1  u1 )
              (  v1  1   1   u2  u2 )           (  1   1   u2  u2  u2  u2 )
              (  v1  v2  a   a   a  )           (  v1  1   a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )           (  v1  v2  a   a   a   a  )
              (  v1  v2  a   a   a  )
            where a denotes an element of the original matrix which is unchanged,
            vi denotes an element of the vector defining H(i), and ui an element
            of the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlapmt(System.Boolean,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32})">
            <summary>
            <para>
            Rearranges the columns of the M by N matrix X as specified
            by the permutation K(1),K(2),.</para>
            </summary>
            <param name="forwrd">
            <code>
            FORWRD is LOGICAL
            = .TRUE., forward permutation
            = .FALSE., backward permutation
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix X. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix X. N >= 0.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array, dimension (LDX,N)
            On entry, the M by N matrix X.
            On exit, X contains the permuted matrix X.
            </code>
            <code>
            LDX is INTEGER
            The leading dimension of the array X, LDX >= MAX(1,M).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER array, dimension (N)
            On entry, K contains the permutation vector. K is used as
            internal workspace, but reset to its original value on
            output.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If FORWRD = .TRUE.,  forward permutation:
                 X(*,K(J)) is moved X(*,J) for J = 1,2,...,N.
            If FORWRD = .FALSE., backward permutation:
                 X(*,J) is moved to X(*,K(J)) for J = 1,2,...,N.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlags2(System.Boolean,`0,`0,`0,`0,`0,`0,`0@,`0@,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Computes 2-by-2 orthogonal matrices U, V and Q, such
            that if ( UPPER ) then
                      U**T *A*Q = U**T *( A1 A2 )*Q = ( x  0  )
                                        ( 0  A3 )     ( x  x  )
            and
                      V**T*B*Q = V**T *( B1 B2 )*Q = ( x  0  )
                                       ( 0  B3 )     ( x  x  )
            or if ( .</para>
            </summary>
            <param name="upper">
            <code>
            UPPER is LOGICAL
            = .TRUE.: the input matrices A and B are upper triangular.
            = .FALSE.: the input matrices A and B are lower triangular.
            </code>
            </param>
            <param name="a1">
            <code>
            A1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="a2">
            <code>
            A2 is DOUBLE PRECISION
            </code>
            </param>
            <param name="a3">
            <code>
            A3 is DOUBLE PRECISION
            On entry, A1, A2 and A3 are elements of the input 2-by-2
            upper (lower) triangular matrix A.
            </code>
            </param>
            <param name="b1">
            <code>
            B1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="b2">
            <code>
            B2 is DOUBLE PRECISION
            </code>
            </param>
            <param name="b3">
            <code>
            B3 is DOUBLE PRECISION
            On entry, B1, B2 and B3 are elements of the input 2-by-2
            upper (lower) triangular matrix B.
            </code>
            </param>
            <param name="csu">
            <code>
            CSU is DOUBLE PRECISION
            </code>
            </param>
            <param name="snu">
            <code>
            SNU is DOUBLE PRECISION
            The desired orthogonal matrix U.
            </code>
            </param>
            <param name="csv">
            <code>
            CSV is DOUBLE PRECISION
            </code>
            </param>
            <param name="snv">
            <code>
            SNV is DOUBLE PRECISION
            The desired orthogonal matrix V.
            </code>
            </param>
            <param name="csq">
            <code>
            CSQ is DOUBLE PRECISION
            </code>
            </param>
            <param name="snq">
            <code>
            SNQ is DOUBLE PRECISION
            The desired orthogonal matrix Q.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            NOT.UPPER ) then
                      U**T *A*Q = U**T *( A1 0  )*Q = ( x  x  )
                                        ( A2 A3 )     ( 0  x  )
            and
                      V**T*B*Q = V**T*( B1 0  )*Q = ( x  x  )
                                      ( B2 B3 )     ( 0  x  )
            The rows of the transformed A and B are parallel, where
              U = (  CSU  SNU ), V = (  CSV SNV ), Q = (  CSQ   SNQ )
                  ( -SNU  CSU )      ( -SNV CSV )      ( -SNQ   CSQ )
            Z**T denotes the transpose of Z.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlapll(System.Int32,Extreme.Collections.ArraySlice{`0},Extreme.Collections.ArraySlice{`0},`0@)">
            <summary>
            <para>
            Two column vectors X and Y, let
                                 A = ( X Y ).</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of the vectors X and Y.
            </code>
            </param>
            <param name="x">
            <code>
            X is DOUBLE PRECISION array,
                           dimension (1+(N-1)*INCX)
            On entry, X contains the N-vector X.
            On exit, X is overwritten.
            </code>
            <code>
            INCX is INTEGER
            The increment between successive elements of X. INCX > 0.
            </code>
            </param>
            <param name="y">
            <code>
            Y is DOUBLE PRECISION array,
                           dimension (1+(N-1)*INCY)
            On entry, Y contains the N-vector Y.
            On exit, Y is overwritten.
            </code>
            <code>
            INCY is INTEGER
            The increment between successive elements of Y. INCY > 0.
            </code>
            </param>
            <param name="ssmin">
            <code>
            SSMIN is DOUBLE PRECISION
            The smallest singular value of the N-by-2 matrix A = ( X Y ).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The subroutine first computes the QR factorization of A = Q*R,
            and then computes the SVD of the 2-by-2 upper triangular matrix R.
            The smaller singular value of R is returned in SSMIN, which is used
            as the measurement of the linear dependency of the vectors X and Y.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtgsja(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@,System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of two real upper triangular (or trapezoidal) matrices A and B.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  U must contain an orthogonal matrix U1 on entry, and
                    the product U1*U is returned;
            = 'I':  U is initialized to the unit matrix, and the
                    orthogonal matrix U is returned;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  V must contain an orthogonal matrix V1 on entry, and
                    the product V1*V is returned;
            = 'I':  V is initialized to the unit matrix, and the
                    orthogonal matrix V is returned;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Q must contain an orthogonal matrix Q1 on entry, and
                    the product Q1*Q is returned;
            = 'I':  Q is initialized to the unit matrix, and the
                    orthogonal matrix Q is returned;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            K and L specify the subblocks in the input matrices A and B:
            A23 = A(K+1:MIN(K+L,M),N-L+1:N) and B13 = B(1:L,N-L+1:N)
            of A and B, whose GSVD is going to be computed by DTGSJA.
            See Further Details.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A(N-K+1:N,1:MIN(K+L,M) ) contains the triangular
            matrix R or part of R.  See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, if necessary, B(M-K+1:L,N+M-K-L+1:N) contains
            a part of R.  See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is DOUBLE PRECISION
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is DOUBLE PRECISION
            TOLA and TOLB are the convergence criteria for the Jacobi-
            Kogbetliantz iteration procedure. Generally, they are the
            same as used in the preprocessing step, say
                TOLA = max(M,N)*norm(A)*MAZHEPS,
                TOLB = max(P,N)*norm(B)*MAZHEPS.
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = diag(C),
              BETA(K+1:K+L)  = diag(S),
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)= C, ALPHA(M+1:K+L)= 0
              BETA(K+1:M) = S, BETA(M+1:K+L) = 1.
            Furthermore, if K+L &amp;lt; N,
              ALPHA(K+L+1:N) = 0 and
              BETA(K+L+1:N)  = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU,M)
            On entry, if JOBU = 'U', U must contain a matrix U1 (usually
            the orthogonal matrix returned by DGGSVP).
            On exit,
            if JOBU = 'I', U contains the orthogonal matrix U;
            if JOBU = 'U', U contains the product U1*U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,P)
            On entry, if JOBV = 'V', V must contain a matrix V1 (usually
            the orthogonal matrix returned by DGGSVP).
            On exit,
            if JOBV = 'I', V contains the orthogonal matrix V;
            if JOBV = 'V', V contains the product V1*V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if JOBQ = 'Q', Q must contain a matrix Q1 (usually
            the orthogonal matrix returned by DGGSVP).
            On exit,
            if JOBQ = 'I', Q contains the orthogonal matrix Q;
            if JOBQ = 'Q', Q contains the product Q1*Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="ncycle">
            <code>
            NCYCLE is INTEGER
            The number of cycles required for convergence.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            = 1:  the procedure does not converge after MAXIT cycles.
            </code>
            <code>
            l Parameters
            =============
            T   INTEGER
                MAXIT specifies the total loops that the iterative procedure
                may take. If after MAXIT cycles, the routine fails to
                converge, we return INFO = 1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On entry, it is assumed that matrices A and B have the following
            forms, which may be obtained by the preprocessing subroutine DGGSVP
            from a general M-by-N matrix A and P-by-N matrix B:
                         N-K-L  K    L
               A =    K ( 0    A12  A13 ) if M-K-L >= 0;
                      L ( 0     0   A23 )
                  M-K-L ( 0     0    0  )
                       N-K-L  K    L
               A =  K ( 0    A12  A13 ) if M-K-L &amp;lt; 0;
                  M-K ( 0     0   A23 )
                       N-K-L  K    L
               B =  L ( 0     0   B13 )
                  P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.
            On exit,
                   U**T *A*Q = D1*( 0 R ),    V**T *B*Q = D2*( 0 R ),
            where U, V and Q are orthogonal matrices.
            R is a nonsingular upper triangular matrix, and D1 and D2 are
            ``diagonal'' matrices, which are of the following structures:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 = L   ( 0  S )
                        P-L ( 0  0 )
                           N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 ) K
                        L (  0    0   R22 ) L
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                           K M-K K+L-M
                D1 =   K ( I  0    0   )
                     M-K ( 0  C    0   )
                             K M-K K+L-M
                D2 =   M-K ( 0  S    0   )
                     K+L-M ( 0  0    I   )
                       P-L ( 0  0    0   )
                           N-K-L  K   M-K  K+L-M
            ( 0 R ) =    K ( 0    R11  R12  R13  )
                      M-K ( 0     0   R22  R23  )
                    K+L-M ( 0     0    0   R33  )
            where
            C = diag( ALPHA(K+1), ... , ALPHA(M) ),
            S = diag( BETA(K+1),  ... , BETA(M) ),
            C**2 + S**2 = I.
            R = ( R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N) and R33 is stored
                (  0  R22 R23 )
            in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The computation of the orthogonal transformation matrices U, V or Q
            is optional.  These matrices may either be formed explicitly, or they
            may be postmultiplied into input matrices U1, V1, or Q1.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            DTGSJA essentially uses a variant of Kogbetliantz algorithm to reduce
            min(L,M-K)-by-L triangular (or trapezoidal) matrix A23 and L-by-L
            matrix B13 to the form:
                     U1**T *A13*Q1 = C1*R1; V1**T *B13*Q1 = S1*R1,
            where U1, V1 and Q1 are orthogonal matrix, and Z**T is the transpose
            of Z.  C1 and S1 are diagonal matrices satisfying
                          C1**2 + S1**2 = I,
            and R1 is an L-by-L nonsingular upper triangular matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            trapezoidal or triangular matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in DLANTR as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower trapezoidal.
            = 'U':  Upper trapezoidal
            = 'L':  Lower trapezoidal
            Note that A is triangular instead of trapezoidal if M = N.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A has unit diagonal.
            = 'N':  Non-unit diagonal
            = 'U':  Unit diagonal
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0, and if
            UPLO = 'U', M &amp;lt;= N.  When M = 0, DLANTR is set to zero.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0, and if
            UPLO = 'L', N &amp;lt;= M.  When N = 0, DLANTR is set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The trapezoidal matrix A (A is triangular if M = N).
            If UPLO = 'U', the leading m by n upper trapezoidal part of
            the array A contains the upper trapezoidal matrix, and the
            strictly lower triangular part of A is not referenced.
            If UPLO = 'L', the leading m by n lower trapezoidal part of
            the array A contains the lower trapezoidal matrix, and the
            strictly upper triangular part of A is not referenced.  Note
            that when DIAG = 'U', the diagonal elements of A are not
            referenced and are assumed to be one.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(M,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= M when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            DLANTR = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlauu2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**T;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**T * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the unblocked form of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlauum(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the product U * U**T or L**T * L, where the triangular
            factor U or L is stored in the upper or lower triangular part of
            the array A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the triangular factor stored in the array A
            is upper or lower triangular:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the triangular factor U or L.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L.
            On exit, if UPLO = 'U', the upper triangle of A is
            overwritten with the upper triangle of the product U * U**T;
            if UPLO = 'L', the lower triangle of A is overwritten with
            the lower triangle of the product L**T * L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U' or 'u' then the upper triangle of the result is stored,
            overwriting the factor U in A.
            If UPLO = 'L' or 'l' then the lower triangle of the result is stored,
            overwriting the factor L in A.
            This is the blocked form of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlasyf(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes a partial factorization of a real symmetric matrix A
            using the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The maximum number of columns of the matrix A that should be
            factored.  NB should be at least 2 to allow for 2-by-2 pivot
            blocks.
            </code>
            </param>
            <param name="kb">
            <code>
            KB is INTEGER
            The number of columns of A that were actually factored.
            KB is either NB-1 or NB, or N if N &amp;lt;= NB.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, A contains details of the partial factorization.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If UPLO = 'U', only the last KB elements of IPIV are set;
            if UPLO = 'L', only the first KB elements are set.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (LDW,NB)
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W.  LDW >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The partial
            factorization has the form:
            A  =  ( I  U12 ) ( A11  0  ) (  I       0    )  if UPLO = 'U', or:
                  ( 0  U22 ) (  0   D  ) ( U12**T U22**T )
            A  =  ( L11  0 ) (  D   0  ) ( L11**T L21**T )  if UPLO = 'L'
                  ( L21  I ) (  0  A22 ) (  0       I    )
            where the order of D is at most NB. The actual order is returned in
            the argument KB, and is either NB or NB-1, or N if N &amp;lt;= NB.
            DLASYF is an auxiliary routine called by DSYTRF. It uses blocked code
            (calling Level 3 BLAS) to update the submatrix A11 (if UPLO = 'U') or
            A22 (if UPLO = 'L').
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the  element of  largest absolute value  of a
            real symmetric matrix A.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in DLANSY as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is to be referenced.
            = 'U':  Upper triangular part of A is referenced
            = 'L':  Lower triangular part of A is referenced
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, DLANSY is
            set to zero.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The symmetric matrix A.  If UPLO = 'U', the leading n by n
            upper triangular part of A contains the upper triangular part
            of the matrix A, and the strictly lower triangular part of A
            is not referenced.  If UPLO = 'L', the leading n by n lower
            triangular part of A contains the lower triangular part of
            the matrix A, and the strictly upper triangular part of A is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(N,1).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I' or '1' or 'O'; otherwise,
            WORK is not referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            DLANSY = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed2(System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of non-deflated eigenvalues, and the order of the
            related secular equation. 0 &amp;lt;= K &amp;lt;=N.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The location of the last eigenvalue in the leading sub-matrix.
            min(1,N) &amp;lt;= N1 &amp;lt;= N/2.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, D contains the eigenvalues of the two submatrices to
            be combined.
            On exit, D contains the trailing (N-K) updated eigenvalues
            (those which were deflated) sorted into increasing order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ, N)
            On entry, Q contains the eigenvectors of two submatrices in
            the two square blocks with corners at (1,1), (N1,N1)
            and (N1+1, N1+1), (N,N).
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which separately sorts the two sub-problems
            in D into ascending order.  Note that elements in the second
            half of this permutation must first have N1 added to their
            values. Destroyed on exit.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            On entry, the off-diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined.
            On exit, RHO has been modified to the value required by
            DLAED3.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (N)
            On entry, Z contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).
            On exit, the contents of Z have been destroyed by the updating
            process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is DOUBLE PRECISION array, dimension (N)
            A copy of the first K eigenvalues which will be used by
            DLAED3 to form the secular equation.
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (N)
            The first k values of the final deflation-altered z-vector
            which will be passed to DLAED3.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is DOUBLE PRECISION array, dimension (N1**2+(N-N1)**2)
            A copy of the first K eigenvectors which will be used by
            DLAED3 in a matrix multiply (DGEMM) to solve for the new
            eigenvectors.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to sort the contents of DLAMDA into
            ascending order.
            </code>
            </param>
            <param name="indxc">
            <code>
            INDXC is INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups:  the first group contains non-zero
            elements only at and above N1, the second contains
            non-zero elements only below N1, and the third is dense.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            The permutation used to place deflated values of D at the end
            of the array.  INDXP(1:K) points to the nondeflated D-values
            and INDXP(K+1:N) points to the deflated eigenvalues.
            </code>
            </param>
            <param name="coltyp">
            <code>
            COLTYP is INTEGER array, dimension (N)
            During execution, a label which will indicate which of the
            following types a column in the Q2 matrix is:
            1 : non-zero in the upper half only;
            2 : dense;
            3 : non-zero in the lower half only;
            4 : deflated.
            On exit, COLTYP(i) is the number of columns of type i,
            for i=1 to 4 only.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny entry in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed5(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0@)">
            <summary>
            <para>
            Subroutine computes the I-th eigenvalue of a symmetric rank-one
            modification of a 2-by-2 diagonal matrix
                       diag( D )  +  RHO * Z * transpose(Z) .</para>
            </summary>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  I = 1 or I = 2.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (2)
            The original eigenvalues.  We assume D(1) &amp;lt; D(2).
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (2)
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is DOUBLE PRECISION array, dimension (2)
            The vector DELTA contains the information necessary
            to construct the eigenvectors.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dlam">
            <code>
            DLAM is DOUBLE PRECISION
            The computed lambda_I, the I-th updated eigenvalue.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The diagonal elements in the array D are assumed to satisfy
                       D(i) &amp;lt; D(j)  for  i &amp;lt; j .
            We also assume RHO > 0 and that the Euclidean norm of the vector
            Z is one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed4(System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},`0,`0@,System.Int32@)">
            <summary>
            <para>
            Subroutine computes the I-th updated eigenvalue of a symmetric
            rank-one modification to a diagonal matrix whose elements are
            given in the array d, and that
                       D(i) &amp;lt; D(j)  for  i &amp;lt; j
            and that RHO > 0.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The length of all arrays.
            </code>
            </param>
            <param name="i">
            <code>
            I is INTEGER
            The index of the eigenvalue to be computed.  1 &amp;lt;= I &amp;lt;= N.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The original eigenvalues.  It is assumed that they are in
            order, D(I) &amp;lt; D(J)  for I &amp;lt; J.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (N)
            The components of the updating vector.
            </code>
            </param>
            <param name="delta">
            <code>
            DELTA is DOUBLE PRECISION array, dimension (N)
            If N .GT. 2, DELTA contains (D(j) - lambda_I) in its  j-th
            component.  If N = 1, then DELTA(1) = 1. If N = 2, see DLAED5
            for detail. The vector DELTA contains the information necessary
            to construct the eigenvectors by DLAED3 and DLAED9.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The scalar in the symmetric updating formula.
            </code>
            </param>
            <param name="dlam">
            <code>
            DLAM is DOUBLE PRECISION
            The computed lambda_I, the I-th updated eigenvalue.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            > 0:  if INFO = 1, the updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is arranged by the calling routine, and is
            no loss in generality.  The rank-one modified system is thus
                       diag( D )  +  RHO * Z * Z_transpose.
            where we assume the Euclidean norm of Z is 1.
            The method consists of approximating the rational functions in the
            secular equation by simpler interpolating rational functions.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ren-Cang Li, Computer Science Division, University of California
                at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed3(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Finds the roots of the secular equation, as defined by the
            values in D, W, and RHO, between 1 and K.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved by
            DLAED4.  K >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (deflation may result in N>K).
            </code>
            </param>
            <param name="n1">
            <code>
            N1 is INTEGER
            The location of the last eigenvalue in the leading submatrix.
            min(1,N) &amp;lt;= N1 &amp;lt;= N/2.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            D(I) contains the updated eigenvalues for
            1 &amp;lt;= I &amp;lt;= K.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            Initially the first K columns are used as workspace.
            On output the columns 1 to K contain
            the updated eigenvectors.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation. May be changed on output by
            having lowest order bit set to zero on Cray X-MP, Cray Y-MP,
            Cray-2, or Cray C-90, as described above.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is DOUBLE PRECISION array, dimension (LDQ2, N)
            The first K columns of this matrix contain the non-deflated
            eigenvectors for the split problem.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to arrange the columns of the deflated
            Q matrix into three groups (see DLAED2).
            The rows of the eigenvectors found by DLAED4 must be likewise
            permuted before the matrix multiply can take place.
            </code>
            </param>
            <param name="ctot">
            <code>
            CTOT is INTEGER array, dimension (4)
            A count of the total number of the various types of columns
            in Q, as described in INDX.  The fourth column type is any
            column which has been deflated.
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector. Destroyed on
            output.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension (N1 + 1)*K
            Will contain the eigenvectors of the repaired matrix which
            will be multiplied by the previously accumulated eigenvectors
            to update the system.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to DLAED4 and then updates the eigenvectors by
            multiplying the matrix of eigenvectors of the pair of eigensystems
            being combined by the matrix of eigenvectors of the K-by-K system
            which is solved here.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed1(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            On entry, the permutation which separately sorts the two
            subproblems in D into ascending order.
            On exit, the permutation which will reintegrate the
            subproblems back into sorted order,
            i.e. D( INDXQ( I = 1, N ) ) will be in ascending order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The subdiagonal entry used to create the rank-1 modification.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            The location of the last eigenvalue in the leading sub-matrix.
            min(1,N) &amp;lt;= CUTPNT &amp;lt;= N/2.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (4*N + N**2)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and eigenvectors of a tridiagonal matrix.  DLAED7 handles
            the case in which eigenvalues only or eigenvalues and eigenvectors
            of a full symmetric matrix (which was reduced to tridiagonal form)
            are desired.
              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
               where Z = Q**T*u, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine DLAED2.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine DLAED4 (as called by DLAED3).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed8(System.Int32,System.Int32@,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0@,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@,Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Merges the two sets of eigenvalues together into a single
            sorted set.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of non-deflated eigenvalues, and the order of the
            related secular equation.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the eigenvalues of the two submatrices to be
            combined.  On exit, the trailing (N-K) updated eigenvalues
            (those which were deflated) sorted into increasing order.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            If ICOMPQ = 0, Q is not referenced.  Otherwise,
            on entry, Q contains the eigenvectors of the partially solved
            system which has been previously updated in matrix
            multiplies with other partially solved eigensystems.
            On exit, Q contains the trailing (N-K) updated eigenvectors
            (those which were deflated) in its last N-K columns.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which separately sorts the two sub-problems
            in D into ascending order.  Note that elements in the second
            half of this permutation must first have CUTPNT added to
            their values in order to be accurate.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            On entry, the off-diagonal element associated with the rank-1
            cut which originally split the two submatrices which are now
            being recombined.
            On exit, RHO has been modified to the value required by
            DLAED3.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            The location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (N)
            On entry, Z contains the updating vector (the last row of
            the first sub-eigenvector matrix and the first row of the
            second sub-eigenvector matrix).
            On exit, the contents of Z are destroyed by the updating
            process.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is DOUBLE PRECISION array, dimension (N)
            A copy of the first K eigenvalues which will be used by
            DLAED3 to form the secular equation.
            </code>
            </param>
            <param name="q2">
            <code>
            Q2 is DOUBLE PRECISION array, dimension (LDQ2,N)
            If ICOMPQ = 0, Q2 is not referenced.  Otherwise,
            a copy of the first K eigenvectors which will be used by
            DLAED7 in a matrix multiply (DGEMM) to update the new
            eigenvectors.
            </code>
            <code>
            LDQ2 is INTEGER
            The leading dimension of the array Q2.  LDQ2 >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (N)
            The first k values of the final deflation-altered z-vector and
            will be passed to DLAED3.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N)
            The permutations (from deflation and sorting) to be applied
            to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER
            The number of Givens rotations which took place in this
            subproblem.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension (2, N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="indxp">
            <code>
            INDXP is INTEGER array, dimension (N)
            The permutation used to place deflated values of D at the end
            of the array.  INDXP(1:K) points to the nondeflated D-values
            and INDXP(K+1:N) points to the deflated eigenvalues.
            </code>
            </param>
            <param name="indx">
            <code>
            INDX is INTEGER array, dimension (N)
            The permutation used to sort the contents of D into ascending
            order.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Then it tries to deflate the size of the problem.
            There are two ways in which deflation can occur:  when two or more
            eigenvalues are close together or if there is a tiny element in the
            Z vector.  For each such occurrence the order of the related secular
            equation problem is reduced by one.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed9(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},`0,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Finds the roots of the secular equation, as defined by the
            values in D, Z, and RHO, between KSTART and KSTOP.</para>
            </summary>
            <param name="k">
            <code>
            K is INTEGER
            The number of terms in the rational function to be solved by
            DLAED4.  K >= 0.
            </code>
            </param>
            <param name="kstart">
            <code>
            KSTART is INTEGER
            </code>
            </param>
            <param name="kstop">
            <code>
            KSTOP is INTEGER
            The updated eigenvalues Lambda(I), KSTART &amp;lt;= I &amp;lt;= KSTOP
            are to be computed.  1 &amp;lt;= KSTART &amp;lt;= KSTOP &amp;lt;= K.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows and columns in the Q matrix.
            N >= K (delation may result in N > K).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            D(I) contains the updated eigenvalues
            for KSTART &amp;lt;= I &amp;lt;= KSTOP.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max( 1, N ).
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The value of the parameter in the rank one update equation.
            RHO >= 0 required.
            </code>
            </param>
            <param name="dlamda">
            <code>
            DLAMDA is DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the old roots
            of the deflated updating problem.  These are the poles
            of the secular equation.
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (K)
            The first K elements of this array contain the components
            of the deflation-adjusted updating vector.
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension (LDS, K)
            Will contain the eigenvectors of the repaired matrix which
            will be stored for subsequent Z vector calculation and
            multiplied by the previously accumulated eigenvectors
            to update the system.
            </code>
            <code>
            LDS is INTEGER
            The leading dimension of S.  LDS >= max( 1, K ).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            It makes the
            appropriate calls to DLAED4 and then stores the new matrix of
            eigenvectors for use in calculating the next level of Z vectors.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaeda(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Z vector corresponding to the merge step in the
            CURLVLth step of the merge process with TLVLS steps for the CURPBMth
            problem.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= curlvl &amp;lt;= tlvls.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and incidentally the
            size of the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (N**2)
            Contains the square eigenblocks from previous levels, the
            starting positions for blocks are given by QPTR.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            Contains a list of pointers which indicate where in Q an
            eigenblock is stored.  SQRT( QPTR(i+1) - QPTR(i) ) indicates
            the size of the block.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (N)
            On output this vector contains the updating vector (the last
            row of the first sub-eigenvector matrix and the first row of
            the second sub-eigenvector matrix).
            </code>
            </param>
            <param name="ztemp">
            <code>
            ZTEMP is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed7(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{System.Int32},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the updated eigensystem of a diagonal
            matrix after modification by a rank-one symmetric matrix.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="tlvls">
            <code>
            TLVLS is INTEGER
            The total number of merging levels in the overall divide and
            conquer tree.
            </code>
            </param>
            <param name="curlvl">
            <code>
            CURLVL is INTEGER
            The current level in the overall merge routine,
            0 &amp;lt;= CURLVL &amp;lt;= TLVLS.
            </code>
            </param>
            <param name="curpbm">
            <code>
            CURPBM is INTEGER
            The current problem in the current level in the overall
            merge routine (counting from upper left to lower right).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the eigenvalues of the rank-1-perturbed matrix.
            On exit, the eigenvalues of the repaired matrix.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ, N)
            On entry, the eigenvectors of the rank-1-perturbed matrix.
            On exit, the eigenvectors of the repaired tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="indxq">
            <code>
            INDXQ is INTEGER array, dimension (N)
            The permutation which will reintegrate the subproblem just
            solved back into sorted order, i.e., D( INDXQ( I = 1, N ) )
            will be in ascending order.
            </code>
            </param>
            <param name="rho">
            <code>
            RHO is DOUBLE PRECISION
            The subdiagonal element used to create the rank-1
            modification.
            </code>
            </param>
            <param name="cutpnt">
            <code>
            CUTPNT is INTEGER
            Contains the location of the last eigenvalue in the leading
            sub-matrix.  min(1,N) &amp;lt;= CUTPNT &amp;lt;= N.
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is DOUBLE PRECISION array, dimension (N**2+1)
            Stores eigenvectors of submatrices encountered during
            divide and conquer, packed together. QPTR points to
            beginning of the submatrices.
            </code>
            </param>
            <param name="qptr">
            <code>
            QPTR is INTEGER array, dimension (N+2)
            List of indices pointing to beginning of submatrices stored
            in QSTORE. The submatrices are numbered starting at the
            bottom left of the divide and conquer tree, from left to
            right and bottom to top.
            </code>
            </param>
            <param name="prmptr">
            <code>
            PRMPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in PERM a
            level's permutation is stored.  PRMPTR(i+1) - PRMPTR(i)
            indicates the size of the permutation and also the size of
            the full, non-deflated problem.
            </code>
            </param>
            <param name="perm">
            <code>
            PERM is INTEGER array, dimension (N lg N)
            Contains the permutations (from deflation and sorting) to be
            applied to each eigenblock.
            </code>
            </param>
            <param name="givptr">
            <code>
            GIVPTR is INTEGER array, dimension (N lg N)
            Contains a list of pointers which indicate where in GIVCOL a
            level's Givens rotations are stored.  GIVPTR(i+1) - GIVPTR(i)
            indicates the number of Givens rotations.
            </code>
            </param>
            <param name="givcol">
            <code>
            GIVCOL is INTEGER array, dimension (2, N lg N)
            Each pair of numbers indicates a pair of columns to take place
            in a Givens rotation.
            </code>
            </param>
            <param name="givnum">
            <code>
            GIVNUM is DOUBLE PRECISION array, dimension (2, N lg N)
            Each number indicates the S value to be used in the
            corresponding Givens rotation.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N+2*QSIZ*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, an eigenvalue did not converge
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This
            routine is used only for the eigenproblem which requires all
            eigenvalues and optionally eigenvectors of a dense symmetric matrix
            that has been reduced to tridiagonal form.  DLAED1 handles
            the case in which all eigenvalues and eigenvectors of a symmetric
            tridiagonal matrix are desired.
              T = Q(in) ( D(in) + RHO * Z*Z**T ) Q**T(in) = Q(out) * D(out) * Q**T(out)
               where Z = Q**Tu, u is a vector of length N with ones in the
               CUTPNT and CUTPNT + 1 th elements and zeros elsewhere.
               The eigenvectors of the original matrix are stored in Q, and the
               eigenvalues are in D.  The algorithm consists of three stages:
                  The first stage consists of deflating the size of the problem
                  when there are multiple eigenvalues or if there is a zero in
                  the Z vector.  For each such occurence the dimension of the
                  secular equation problem is reduced by one.  This stage is
                  performed by the routine DLAED8.
                  The second stage consists of calculating the updated
                  eigenvalues. This is done by finding the roots of the secular
                  equation via the routine DLAED4 (as called by DLAED9).
                  This routine also calculates the eigenvectors of the current
                  problem.
                  The final stage consists of computing the updated eigenvectors
                  directly using the updated eigenvalues.  The eigenvectors for
                  the current problem are multiplied with the eigenvectors from
                  the overall problem.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlae2(`0,`0,`0,`0@,`0@)">
            <summary>
            <para>
            Computes the eigenvalues of a 2-by-2 symmetric matrix
               [  A   B  ]
               [  B   C  ].</para>
            </summary>
            <param name="a">
            <code>
            A is DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION
            The (1,2) and (2,1) elements of the 2-by-2 matrix.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="rt1">
            <code>
            RT1 is DOUBLE PRECISION
            The eigenvalue of larger absolute value.
            </code>
            </param>
            <param name="rt2">
            <code>
            RT2 is DOUBLE PRECISION
            The eigenvalue of smaller absolute value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, RT1 is the eigenvalue of larger absolute value, and RT2
            is the eigenvalue of smaller absolute value.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            RT1 is accurate to a few ulps barring over/underflow.
            RT2 may be inaccurate if there is massive cancellation in the
            determinant A*C-B*B; higher precision or correctly rounded or
            correctly truncated arithmetic would be needed to compute RT2
            accurately in all cases.
            Overflow is possible only if RT1 is within a factor of 5 of overflow.
            Underflow is harmless if the input data is 0 or exceeds
               underflow_threshold / macheps.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaev2(`0,`0,`0,`0@,`0@,`0@,`0@)">
            <summary>
            <para>
            Computes the eigendecomposition of a 2-by-2 symmetric matrix
               [  A   B  ]
               [  B   C  ].</para>
            </summary>
            <param name="a">
            <code>
            A is DOUBLE PRECISION
            The (1,1) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION
            The (1,2) element and the conjugate of the (2,1) element of
            the 2-by-2 matrix.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION
            The (2,2) element of the 2-by-2 matrix.
            </code>
            </param>
            <param name="rt1">
            <code>
            RT1 is DOUBLE PRECISION
            The eigenvalue of larger absolute value.
            </code>
            </param>
            <param name="rt2">
            <code>
            RT2 is DOUBLE PRECISION
            The eigenvalue of smaller absolute value.
            </code>
            </param>
            <param name="cs1">
            <code>
            CS1 is DOUBLE PRECISION
            </code>
            </param>
            <param name="sn1">
            <code>
            SN1 is DOUBLE PRECISION
            The vector (CS1, SN1) is a unit right eigenvector for RT1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            On return, RT1 is the eigenvalue of larger absolute value, RT2 is the
            eigenvalue of smaller absolute value, and (CS1,SN1) is the unit right
            eigenvector for RT1, giving the decomposition
               [ CS1  SN1 ] [  A   B  ] [ CS1 -SN1 ]  =  [ RT1  0  ]
               [-SN1  CS1 ] [  B   C  ] [ SN1  CS1 ]     [  0  RT2 ].
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            RT1 is accurate to a few ulps barring over/underflow.
            RT2 may be inaccurate if there is massive cancellation in the
            determinant A*C-B*B; higher precision or correctly rounded or
            correctly truncated arithmetic would be needed to compute RT2
            accurately in all cases.
            CS1 and SN1 are accurate to a few ulps barring over/underflow.
            Overflow is possible only if RT1 is within a factor of 5 of overflow.
            Underflow is harmless if the input data is 0 or exceeds
               underflow_threshold / macheps.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlaed0(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and corresponding eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="icompq">
            <code>
            ICOMPQ is INTEGER
            = 0:  Compute eigenvalues only.
            = 1:  Compute eigenvectors of original dense symmetric matrix
                  also.  On entry, Q contains the orthogonal matrix used
                  to reduce the original matrix to tridiagonal form.
            = 2:  Compute eigenvalues and eigenvectors of tridiagonal
                  matrix.
            </code>
            </param>
            <param name="qsiz">
            <code>
            QSIZ is INTEGER
            The dimension of the orthogonal matrix used to reduce
            the full matrix to tridiagonal form.  QSIZ >= N if ICOMPQ = 1.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the main diagonal of the tridiagonal matrix.
            On exit, its eigenvalues.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ, N)
            On entry, Q must contain an N-by-N orthogonal matrix.
            If ICOMPQ = 0    Q is not referenced.
            If ICOMPQ = 1    On entry, Q is a subset of the columns of the
                             orthogonal matrix used to reduce the full
                             matrix to tridiagonal form corresponding to
                             the subset of the full matrix which is being
                             decomposed at this time.
            If ICOMPQ = 2    On entry, Q will be the identity matrix.
                             On exit, Q contains the eigenvectors of the
                             tridiagonal matrix.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  If eigenvectors are
            desired, then  LDQ >= max(1,N).  In any case,  LDQ >= 1.
            </code>
            </param>
            <param name="qstore">
            <code>
            QSTORE is DOUBLE PRECISION array, dimension (LDQS, N)
            Referenced only when ICOMPQ = 1.  Used to store parts of
            the eigenvector matrix when the updating matrix multiplies
            take place.
            </code>
            </param>
            <param name="ldqs">
            <code>
            LDQS is INTEGER
            The leading dimension of the array QSTORE.  If ICOMPQ = 1,
            then  LDQS >= max(1,N).  In any case,  LDQS >= 1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array,
            If ICOMPQ = 0 or 1, the dimension of WORK must be at least
                        1 + 3*N + 2*N*lg N + 3*N**2
                        ( lg( N ) = smallest integer k
                                    such that 2^k >= N )
            If ICOMPQ = 2, the dimension of WORK must be at least
                        4*N + N**2.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array,
            If ICOMPQ = 0 or 1, the dimension of IWORK must be at least
                           6 + 6*N + 5*N*lg N.
                           ( lg( N ) = smallest integer k
                                       such that 2^k >= N )
            If ICOMPQ = 2, the dimension of IWORK must be at least
                           3 + 5*N.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlatrd(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0})">
            <summary>
            <para>
            Reduces NB rows and columns of a real symmetric matrix A to
            symmetric tridiagonal form by an orthogonal similarity
            transformation Q**T * A * Q, and returns the matrices V and W which are
            needed to apply the transformation to the unreduced part of A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U': Upper triangular
            = 'L': Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.
            </code>
            </param>
            <param name="nb">
            <code>
            NB is INTEGER
            The number of rows and columns to be reduced.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit:
            if UPLO = 'U', the last NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements above the diagonal
              with the array TAU, represent the orthogonal matrix Q as a
              product of elementary reflectors;
            if UPLO = 'L', the first NB columns have been reduced to
              tridiagonal form, with the diagonal elements overwriting
              the diagonal elements of A; the elements below the diagonal
              with the array TAU, represent the  orthogonal matrix Q as a
              product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= (1,N).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            If UPLO = 'U', E(n-nb:n-1) contains the superdiagonal
            elements of the last NB columns of the reduced matrix;
            if UPLO = 'L', E(1:nb) contains the subdiagonal elements of
            the first NB columns of the reduced matrix.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors, stored in
            TAU(n-nb:n-1) if UPLO = 'U', and in TAU(1:nb) if UPLO = 'L'.
            See Further Details.
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (LDW,NB)
            The n-by-nb matrix W required to update the unreduced part
            of A.
            </code>
            <code>
            LDW is INTEGER
            The leading dimension of the array W. LDW >= max(1,N).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If UPLO = 'U', DLATRD reduces the last NB rows and columns of a
            matrix, of which the upper triangle is supplied;
            if UPLO = 'L', DLATRD reduces the first NB rows and columns of a
            matrix, of which the lower triangle is supplied.
            This is an auxiliary routine called by DSYTRD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n) H(n-1) . . . H(n-nb+1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i:n) = 0 and v(i-1) = 1; v(1:i-1) is stored on exit in A(1:i-1,i),
            and tau in TAU(i-1).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(nb).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+1:n) is stored on exit in A(i+1:n,i),
            and tau in TAU(i).
            The elements of the vectors v together form the n-by-nb matrix V
            which is needed, with W, to apply the transformation to the unreduced
            part of the matrix, using a symmetric rank-2k update of the form:
            A := A - V*W**T - W*V**T.
            The contents of A on exit are illustrated by the following examples
            with n = 5 and nb = 2:
            if UPLO = 'U':                       if UPLO = 'L':
              (  a   a   a   v4  v5 )              (  d                  )
              (      a   a   v4  v5 )              (  1   d              )
              (          a   1   v5 )              (  v1  1   a          )
              (              d   1  )              (  v1  v2  a   a      )
              (                  d  )              (  v1  v2  a   a   a  )
            where d denotes a diagonal element of the reduced matrix, a denotes
            an element of the original matrix that is unchanged, and vi denotes
            an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularBandMatrixNorm(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0})">
            <summary>
            <para>
            Returns the value of the one norm,  or the Frobenius norm, or
            the  infinity norm,  or the element of  largest absolute value  of an
            n by n triangular band matrix A,  with ( k + 1 ) diagonals.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies the value to be returned in DLANTB as described
            above.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.  When N = 0, DLANTB is
            set to zero.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals of the matrix A if UPLO = 'L'.
            K >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first k+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(k+1+i-j,j) = A(i,j) for max(1,j-k)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)   = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+k).
            Note that when DIAG = 'U', the elements of the array AB
            corresponding to the diagonal elements of the matrix A are
            not referenced, but are assumed to be one.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= K+1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK)),
            where LWORK >= N when NORM = 'I'; otherwise, WORK is not
            referenced.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <code>
            DLANTB = ( max(abs(A(i,j))), NORM = 'M' or 'm'
                     (
                     ( norm1(A),         NORM = '1', 'O' or 'o'
                     (
                     ( normI(A),         NORM = 'I' or 'i'
                     (
                     ( normF(A),         NORM = 'F', 'f', 'E' or 'e'
            ere  norm1  denotes the  one norm of a matrix (maximum column sum),
            ormI  denotes the  infinity norm  of a matrix  (maximum row sum) and
            normF  denotes the  Frobenius norm of a matrix (square root of sum of
            squares).  Note that  max(abs(A(i,j)))  is not a consistent matrix norm.
            </code>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Izmax1(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Finds the index of the element whose real part has maximum
            absolute value.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vector CX.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX*16 array, dimension (N)
            The vector whose elements will be summed.
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive values of CX.  INCX >= 1.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Based on IZAMAX from Level 1 BLAS.
            The change is to use the 'genuine' absolute value.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Nick Higham for use with ZLACON.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dzsum1(System.Int32,Extreme.Collections.ArraySlice{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Takes the sum of the absolute values of a complex
            vector and returns a double precision result.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The number of elements in the vector CX.
            </code>
            </param>
            <param name="cx">
            <code>
            CX is COMPLEX*16 array, dimension (N)
            The vector whose elements will be summed.
            </code>
            <code>
            INCX is INTEGER
            The spacing between successive values of CX.  INCX > 0.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Based on DZASUM from the Level 1 BLAS.
            The change is to use the 'genuine' absolute value.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Nick Higham for use with ZLACON.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ilazlr(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Scans A for its last non-zero row.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Ilazlc(System.Int32,System.Int32,Extreme.Collections.Array2D{Extreme.Mathematics.Complex{`0}})">
            <summary>
            <para>
            Scans A for its last non-zero column.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.
            </code>
            </param>
            <param name="a">
            <code>
            A is COMPLEX*16 array, dimension (LDA,N)
            The m by n matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlapy3(`0,`0,`0)">
            <summary>
            <para>
            Returns sqrt(x**2+y**2+z**2), taking care not to cause
            unnecessary overflow.</para>
            </summary>
            <param name="x">
            <code>
            X is DOUBLE PRECISION
            </code>
            </param>
            <param name="y">
            <code>
            Y is DOUBLE PRECISION
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION
            X, Y and Z specify the values x, y and z.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dbdsqr(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the singular values and, optionally, the right and/or
            left singular vectors from the singular value decomposition (SVD) of
            a real N-by-N (upper or lower) bidiagonal matrix B using the implicit
            zero-shift QR algorithm.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  B is upper bidiagonal;
            = 'L':  B is lower bidiagonal.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix B.  N >= 0.
            </code>
            </param>
            <param name="ncvt">
            <code>
            NCVT is INTEGER
            The number of columns of the matrix VT. NCVT >= 0.
            </code>
            </param>
            <param name="nru">
            <code>
            NRU is INTEGER
            The number of rows of the matrix U. NRU >= 0.
            </code>
            </param>
            <param name="ncc">
            <code>
            NCC is INTEGER
            The number of columns of the matrix C. NCC >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B in decreasing
            order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the N-1 offdiagonal elements of the bidiagonal
            matrix B.
            On exit, if INFO = 0, E is destroyed; if INFO > 0, D and E
            will contain the diagonal and superdiagonal elements of a
            bidiagonal matrix orthogonally equivalent to the one given
            as input.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension (LDVT, NCVT)
            On entry, an N-by-NCVT matrix VT.
            On exit, VT is overwritten by P**T * VT.
            Not referenced if NCVT = 0.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.
            LDVT >= max(1,N) if NCVT > 0; LDVT >= 1 if NCVT = 0.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU, N)
            On entry, an NRU-by-N matrix U.
            On exit, U is overwritten by U * Q.
            Not referenced if NRU = 0.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= max(1,NRU).
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC, NCC)
            On entry, an N-by-NCC matrix C.
            On exit, C is overwritten by Q**T * C.
            Not referenced if NCC = 0.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C.
            LDC >= max(1,N) if NCC > 0; LDC >=1 if NCC = 0.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (4*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  If INFO = -i, the i-th argument had an illegal value
            > 0:
               if NCVT = NRU = NCC = 0,
                  = 1, a split was marked by a positive value in E
                  = 2, current block of Z not diagonalized after 30*N
                       iterations (in inner while loop)
                  = 3, termination criterion of outer while loop not met
                       (program created more than N unreduced blocks)
               else NCVT = NRU = NCC = 0,
                     the algorithm did not converge; D and E contain the
                     elements of a bidiagonal matrix which is orthogonally
                     similar to the input matrix B;  if INFO = i, i
                     elements of E have not converged to zero.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The SVD of B has the form
               B = Q * S * P**T
            where S is the diagonal matrix of singular values, Q is an orthogonal
            matrix of left singular vectors, and P is an orthogonal matrix of
            right singular vectors.  If left singular vectors are requested, this
            subroutine actually returns U*Q instead of Q, and, if right singular
            vectors are requested, this subroutine returns P**T*VT instead of
            P**T, for given real input matrices U and VT.  When U and VT are the
            orthogonal matrices that reduce a general matrix A to bidiagonal
            form:  A = U*B*VT, as computed by DGEBRD, then
               A = (U*Q) * S * (P**T*VT)
            is the SVD of A.  Optionally, the subroutine may also compute Q**T*C
            for a given real input matrix C.
            See "Computing  Small Singular Values of Bidiagonal Matrices With
            Guaranteed High Relative Accuracy," by J. Demmel and W. Kahan,
            LAPACK Working Note #3 (or SIAM J. Sci. Statist. Comput. vol. 11,
            no. 5, pp. 873-912, Sept 1990) and
            "Accurate singular values and differential qd algorithms," by
            B. Parlett and V. Fernando, Technical Report CPAM-554, Mathematics
            Department, University of California at Berkeley, July 1992
            for a detailed description of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dbdsdc(Extreme.Mathematics.MatrixTriangle,System.Char,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            N-by-N (upper or lower) bidiagonal matrix B:  B = U * S * VT,
            using a divide and conquer method, where S is a diagonal matrix
            with non-negative diagonal elements (the singular values of B), and
            U and VT are orthogonal matrices of left and right singular vectors,
            respectively.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  B is upper bidiagonal.
            = 'L':  B is lower bidiagonal.
            </code>
            </param>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            Specifies whether singular vectors are to be computed
            as follows:
            = 'N':  Compute singular values only;
            = 'P':  Compute singular values and compute singular
                    vectors in compact form;
            = 'I':  Compute singular values and singular vectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix B.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the bidiagonal matrix B.
            On exit, if INFO=0, the singular values of B.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the elements of E contain the offdiagonal
            elements of the bidiagonal matrix whose SVD is desired.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, U contains the left singular vectors
               of the bidiagonal matrix.
            For other values of COMPQ, U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1.
            If singular vectors are desired, then LDU >= max( 1, N ).
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension (LDVT,N)
            If  COMPQ = 'I', then:
               On exit, if INFO = 0, VT**T contains the right singular
               vectors of the bidiagonal matrix.
            For other values of COMPQ, VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1.
            If singular vectors are desired, then LDVT >= max( 1, N ).
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, Q contains all the DOUBLE PRECISION data in
               LDQ >= N*(11 + 2*SMLSIZ + 8*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, Q is not referenced.
            </code>
            </param>
            <param name="iq">
            <code>
            IQ is INTEGER array, dimension (LDIQ)
            If  COMPQ = 'P', then:
               On exit, if INFO = 0, Q and IQ contain the left
               and right singular vectors in a compact form,
               requiring O(N log N) space instead of 2*N**2.
               In particular, IQ contains all INTEGER data in
               LDIQ >= N*(3 + 3*INT(LOG_2(N/(SMLSIZ+1))))
               words of memory, where SMLSIZ is returned by ILAENV and
               is equal to the maximum size of the subproblems at the
               bottom of the computation tree (usually about 25).
            For other values of COMPQ, IQ is not referenced.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            If COMPQ = 'N' then LWORK >= (4 * N).
            If COMPQ = 'P' then LWORK >= (6 * N).
            If COMPQ = 'I' then LWORK >= (3 * N**2 + 4 * N).
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute a singular value.
                  The update process of divide and conquer failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            DBDSDC can be used to compute all singular values,
            and optionally, singular vectors or singular vectors in compact form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See DLASD3 for details.
            The code currently calls DLASDQ if singular values only are desired.
            However, it can be slightly modified to compute singular values
            using the divide and conquer method.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a general
            real matrix A, in either the 1-norm or the infinity-norm, using
            the LU factorization computed by DGETRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (4*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgetf2(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general m-by-n matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, U(k,k) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a general M-by-N matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix to be factored.
            On exit, the factors L and U from the factorization
            A = P*L*U; the unit diagonal elements of L are not stored.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero. The factorization
                  has been completed, but the factor U is exactly
                  singular, and division by zero will occur if it is used
                  to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = P * L * U
            where P is a permutation matrix, L is lower triangular with unit
            diagonal elements (lower trapezoidal if m > n), and U is upper
            triangular (upper trapezoidal if m &amp;lt; n).
            This is the right-looking Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A**T * X = B
            with a general N-by-N matrix A using the LU factorization computed
            by DGETRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T* X = B  (Transpose)
            = 'C':  A**T* X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The factors L and U from the factorization A = P*L*U
            as computed by DGETRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.LUInvert(System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a matrix using the LU factorization
            computed by DGETRF.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the factors L and U from the factorization
            A = P*L*U as computed by DGETRF.
            On exit, if INFO = 0, the inverse of the original matrix A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices from DGETRF; for 1&amp;lt;=i&amp;lt;=N, row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, then WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimal performance LWORK >= N*NB, where NB is
            the optimal blocksize returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, U(i,i) is exactly zero; the matrix is
                  singular and its inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This method inverts U and then computes inv(A) by solving the system
            inv(A)*L = inv(U) for inv(A).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgebak(System.Char,Extreme.Mathematics.MatrixOperationSide,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Forms the right or left eigenvectors of a real general matrix
            by backward transformation on the computed eigenvectors of the
            balanced matrix output by DGEBAL.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the type of backward transformation required:
            = 'N', do nothing, return immediately;
            = 'P', do backward transformation for permutation only;
            = 'S', do backward transformation for scaling only;
            = 'B', do backward transformations for both permutation and
                   scaling.
            JOB must be the same as the argument JOB supplied to DGEBAL.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  V contains right eigenvectors;
            = 'L':  V contains left eigenvectors.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of rows of the matrix V.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            The integers ILO and IHI determined by DGEBAL.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE PRECISION array, dimension (N)
            Details of the permutation and scaling factors, as returned
            by DGEBAL.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns of the matrix V.  M >= 0.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,M)
            On entry, the matrix of right or left eigenvectors to be
            transformed, as returned by DHSEIN or DTREVC.
            On exit, V is overwritten by the transformed eigenvectors.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgebal(System.Char,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@,System.Int32@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Balances a general real matrix A.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
            Specifies the operations to be performed on A:
            = 'N':  none:  simply set ILO = 1, IHI = N, SCALE(I) = 1.0
                    for i = 1,...,N;
            = 'P':  permute only;
            = 'S':  scale only;
            = 'B':  both permute and scale.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE array, dimension (LDA,N)
            On entry, the input matrix A.
            On exit,  A is overwritten by the balanced matrix.
            If JOB = 'N', A is not referenced.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI are set to integers such that on exit
            A(i,j) = 0 if i > j and j = 1,...,ILO-1 or I = IHI+1,...,N.
            If JOB = 'N' or 'S', ILO = 1 and IHI = N.
            </code>
            </param>
            <param name="scale">
            <code>
            SCALE is DOUBLE array, dimension (N)
            Details of the permutations and scaling factors applied to
            A.  If P(j) is the index of the row and column interchanged
            with row and column j and D(j) is the scaling factor
            applied to row and column j, then
            SCALE(j) = P(j)    for j = 1,...,ILO-1
                     = D(j)    for j = ILO,...,IHI
                     = P(j)    for j = IHI+1,...,N.
            The order in which the interchanges are made is N to IHI+1,
            then 1 to ILO-1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This involves, first,
            permuting A by a similarity transformation to isolate eigenvalues
            in the first 1 to ILO-1 and last IHI+1 to N elements on the
            diagonal; and second, applying a diagonal similarity transformation
            to rows and columns ILO to IHI to make the rows and columns as
            close in norm as possible.  Both steps are optional.
            Balancing may reduce the 1-norm of the matrix, and improve the
            accuracy of the computed eigenvalues and/or eigenvectors.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The permutations consist of row and column interchanges which put
            the matrix in the form
                       ( T1   X   Y  )
               P A P = (  0   B   Z  )
                       (  0   0   T2 )
            where T1 and T2 are upper triangular matrices whose eigenvalues lie
            along the diagonal.  The column indices ILO and IHI mark the starting
            and ending columns of the submatrix B. Balancing consists of applying
            a diagonal similarity transformation inv(D) * B * D to make the
            1-norms of each row of B and its corresponding column nearly equal.
            The output matrix is
               ( T1     X*D          Y    )
               (  0  inv(D)*B*D  inv(D)*Z ).
               (  0      0           T2   )
            Information about the permutations P and the diagonal matrix D is
            returned in the vector SCALE.
            This subroutine is based on the EISPACK routine BALANC.
            Modified by Tzu-Yi Chen, Computer Science Division, University of
              California at Berkeley, USA
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgehd2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Reduces a real general matrix A to upper Hessenberg form H by
            an orthogonal similarity transformation:  Q**T * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to DGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= max(1,N).
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the n by n general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgehrd(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a real general matrix A to upper Hessenberg form H by
            an orthogonal similarity transformation:  Q**T * A * Q = H .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            It is assumed that A is already upper triangular in rows
            and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
            set by a previous call to DGEBAL; otherwise they should be
            set to 1 and N respectively. See Further Details.
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N general matrix to be reduced.
            On exit, the upper triangle and the first subdiagonal of A
            are overwritten with the upper Hessenberg matrix H, and the
            elements below the first subdiagonal, with the array TAU,
            represent the orthogonal matrix Q as a product of elementary
            reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details). Elements 1:ILO-1 and IHI:N-1 of TAU are set to
            zero.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of (ihi-ilo) elementary
            reflectors
               Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0, v(i+1) = 1 and v(ihi+1:n) = 0; v(i+2:ihi) is stored on
            exit in A(i+2:ihi,i), and tau in TAU(i).
            The contents of A are illustrated by the following example, with
            n = 7, ilo = 2 and ihi = 6:
            on entry,                        on exit,
            ( a   a   a   a   a   a   a )    (  a   a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      a   h   h   h   h   a )
            (     a   a   a   a   a   a )    (      h   h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  h   h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  h   h   h   h )
            (     a   a   a   a   a   a )    (      v2  v3  v4  h   h   h )
            (                         a )    (                          a )
            where a denotes an element of the original matrix A, h denotes a
            modified element of the upper Hessenberg matrix H, and vi denotes an
            element of the vector defining H(i).
            This file is a slight modification of LAPACK-3.0's DGEHRD
            subroutine incorporating improvements proposed by Quintana-Orti and
            Van de Geijn (2006). (See DLAHR2.)
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgeev(System.Char,System.Char,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes for an N-by-N real nonsymmetric matrix A, the
            eigenvalues and, optionally, the left and/or right eigenvectors.</para>
            </summary>
            <param name="jobvl">
            <code>
            JOBVL is CHARACTER*1
            = 'N': left eigenvectors of A are not computed;
            = 'V': left eigenvectors of A are computed.
            </code>
            </param>
            <param name="jobvr">
            <code>
            JOBVR is CHARACTER*1
            = 'N': right eigenvectors of A are not computed;
            = 'V': right eigenvectors of A are computed.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the N-by-N matrix A.
            On exit, A has been overwritten.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION array, dimension (N)
            WR and WI contain the real and imaginary parts,
            respectively, of the computed eigenvalues.  Complex
            conjugate pairs of eigenvalues appear consecutively
            with the eigenvalue having the positive imaginary part
            first.
            </code>
            </param>
            <param name="vl">
            <code>
            VL is DOUBLE PRECISION array, dimension (LDVL,N)
            If JOBVL = 'V', the left eigenvectors u(j) are stored one
            after another in the columns of VL, in the same order
            as their eigenvalues.
            If JOBVL = 'N', VL is not referenced.
            If the j-th eigenvalue is real, then u(j) = VL(:,j),
            the j-th column of VL.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then u(j) = VL(:,j) + i*VL(:,j+1) and
            u(j+1) = VL(:,j) - i*VL(:,j+1).
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1; if
            JOBVL = 'V', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is DOUBLE PRECISION array, dimension (LDVR,N)
            If JOBVR = 'V', the right eigenvectors v(j) are stored one
            after another in the columns of VR, in the same order
            as their eigenvalues.
            If JOBVR = 'N', VR is not referenced.
            If the j-th eigenvalue is real, then v(j) = VR(:,j),
            the j-th column of VR.
            If the j-th and (j+1)-st eigenvalues form a complex
            conjugate pair, then v(j) = VR(:,j) + i*VR(:,j+1) and
            v(j+1) = VR(:,j) - i*VR(:,j+1).
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1; if
            JOBVR = 'V', LDVR >= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,3*N), and
            if JOBVL = 'V' or JOBVR = 'V', LWORK >= 4*N.  For good
            performance, LWORK must generally be larger.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = i, the QR algorithm failed to compute all the
                  eigenvalues, and no eigenvectors have been computed;
                  elements i+1:N of WR and WI contain eigenvalues which
                  have converged.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The right eigenvector v(j) of A satisfies
                             A * v(j) = lambda(j) * v(j)
            where lambda(j) is its eigenvalue.
            The left eigenvector u(j) of A satisfies
                          u(j)**H * A = lambda(j) * u(j)**H
            where u(j)**H denotes the conjugate-transpose of u(j).
            The computed eigenvectors are normalized to have Euclidean norm
            equal to 1 and largest component real.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgeqr2(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real m by n matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(m,n) by n upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization of a real M-by-N matrix A:
            A = Q * R.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and above the diagonal of the array
            contain the min(M,N)-by-N upper trapezoidal matrix R (R is
            upper triangular if m >= n); the elements below the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of min(m,n) elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.QRDecompose(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes a QR factorization with column pivoting of a
            matrix A:  A*P = Q*R  using Level 3 BLAS.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper trapezoidal matrix R; the elements below
            the diagonal, together with the array TAU, represent the
            orthogonal matrix Q as a product of min(M,N) elementary
            reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(J).ne.0, the J-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(J)=0,
            the J-th column of A is a free column.
            On exit, if JPVT(J)=K, then the J-th column of A*P was the
            the K-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO=0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 3*N+1.
            For optimal performance LWORK >= 2*N+( N+1 )*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real/complex vector
            with v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in
            A(i+1:m,i), and tau in TAU(i).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
               G. Quintana-Orti, Depto. de Informatica, Universidad Jaime I, Spain
               X. Sun, Computer Science Dept., Duke University, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgebd2(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Reduces a real general m by n matrix A to upper or lower
            bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is DOUBLE PRECISION array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (max(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit.
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
            u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgebrd(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a general real M-by-N matrix A to upper or lower
            bidiagonal form B by an orthogonal transformation: Q**T * A * P = B.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows in the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns in the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N general matrix to be reduced.
            On exit,
            if m >= n, the diagonal and the first superdiagonal are
              overwritten with the upper bidiagonal matrix B; the
              elements below the diagonal, with the array TAUQ, represent
              the orthogonal matrix Q as a product of elementary
              reflectors, and the elements above the first superdiagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors;
            if m &amp;lt; n, the diagonal and the first subdiagonal are
              overwritten with the lower bidiagonal matrix B; the
              elements below the first subdiagonal, with the array TAUQ,
              represent the orthogonal matrix Q as a product of
              elementary reflectors, and the elements above the diagonal,
              with the array TAUP, represent the orthogonal matrix P as
              a product of elementary reflectors.
            See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (min(M,N))
            The diagonal elements of the bidiagonal matrix B:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (min(M,N)-1)
            The off-diagonal elements of the bidiagonal matrix B:
            if m >= n, E(i) = A(i,i+1) for i = 1,2,...,n-1;
            if m &amp;lt; n, E(i) = A(i+1,i) for i = 1,2,...,m-1.
            </code>
            </param>
            <param name="tauq">
            <code>
            TAUQ is DOUBLE PRECISION array dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix Q. See Further Details.
            </code>
            </param>
            <param name="taup">
            <code>
            TAUP is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors which
            represent the orthogonal matrix P. See Further Details.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of the array WORK.  LWORK >= max(1,M,N).
            For optimum performance LWORK >= (M+N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If m >= n, B is upper bidiagonal; if m &amp;lt; n, B is lower bidiagonal.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrices Q and P are represented as products of elementary
            reflectors:
            If m >= n,
               Q = H(1) H(2) . . . H(n)  and  P = G(1) G(2) . . . G(n-1)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i-1) = 0, v(i) = 1, and v(i+1:m) is stored on exit in A(i+1:m,i);
            u(1:i) = 0, u(i+1) = 1, and u(i+2:n) is stored on exit in A(i,i+2:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            If m &amp;lt; n,
               Q = H(1) H(2) . . . H(m-1)  and  P = G(1) G(2) . . . G(m)
            Each H(i) and G(i) has the form:
               H(i) = I - tauq * v * v**T  and G(i) = I - taup * u * u**T
            where tauq and taup are real scalars, and v and u are real vectors;
            v(1:i) = 0, v(i+1) = 1, and v(i+2:m) is stored on exit in A(i+2:m,i);
            u(1:i-1) = 0, u(i) = 1, and u(i+1:n) is stored on exit in A(i,i+1:n);
            tauq is stored in TAUQ(i) and taup in TAUP(i).
            The contents of A on exit are illustrated by the following examples:
            m = 6 and n = 5 (m > n):          m = 5 and n = 6 (m &amp;lt; n):
              (  d   e   u1  u1  u1 )           (  d   u1  u1  u1  u1  u1 )
              (  v1  d   e   u2  u2 )           (  e   d   u2  u2  u2  u2 )
              (  v1  v2  d   e   u3 )           (  v1  e   d   u3  u3  u3 )
              (  v1  v2  v3  d   e  )           (  v1  v2  e   d   u4  u4 )
              (  v1  v2  v3  v4  d  )           (  v1  v2  v3  e   d   u5 )
              (  v1  v2  v3  v4  v5 )
            where d and e denote diagonal and off-diagonal elements of B, vi
            denotes an element of the vector defining H(i), and ui an element of
            the vector defining G(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgelq2(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a real m by n matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m by min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgelqf(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes an LQ factorization of a real M-by-N matrix A:
            A = L * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the elements on and below the diagonal of the array
            contain the m-by-min(m,n) lower trapezoidal matrix L (L is
            lower triangular if m &amp;lt;= n); the elements above the diagonal,
            with the array TAU, represent the orthogonal matrix Q as a
            product of elementary reflectors (see Further Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(k) . . . H(2) H(1), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:n) is stored on exit in A(i,i+1:n),
            and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgesdd(System.Char,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the singular value decomposition (SVD) of a real
            M-by-N matrix A, optionally computing the left and right singular
            vectors.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            Specifies options for computing all or part of the matrix U:
            = 'A':  all M columns of U and all N rows of V**T are
                    returned in the arrays U and VT;
            = 'S':  the first min(M,N) columns of U and the first
                    min(M,N) rows of V**T are returned in the arrays U
                    and VT;
            = 'O':  If M >= N, the first N columns of U are overwritten
                    on the array A and all rows of V**T are returned in
                    the array VT;
                    otherwise, all columns of U are returned in the
                    array U and the first M rows of V**T are overwritten
                    in the array A;
            = 'N':  no columns of U or rows of V**T are computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the input matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the input matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit,
            if JOBZ = 'O',  A is overwritten with the first N columns
                            of U (the left singular vectors, stored
                            columnwise) if M >= N;
                            A is overwritten with the first M rows
                            of V**T (the right singular vectors, stored
                            rowwise) otherwise.
            if JOBZ .ne. 'O', the contents of A are destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="s">
            <code>
            S is DOUBLE PRECISION array, dimension (min(M,N))
            The singular values of A, sorted so that S(i) >= S(i+1).
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU,UCOL)
            UCOL = M if JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N;
            UCOL = min(M,N) if JOBZ = 'S'.
            If JOBZ = 'A' or JOBZ = 'O' and M &amp;lt; N, U contains the M-by-M
            orthogonal matrix U;
            if JOBZ = 'S', U contains the first min(M,N) columns of U
            (the left singular vectors, stored columnwise);
            if JOBZ = 'O' and M >= N, or JOBZ = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U.  LDU >= 1; if
            JOBZ = 'S' or 'A' or JOBZ = 'O' and M &amp;lt; N, LDU >= M.
            </code>
            </param>
            <param name="vt">
            <code>
            VT is DOUBLE PRECISION array, dimension (LDVT,N)
            If JOBZ = 'A' or JOBZ = 'O' and M >= N, VT contains the
            N-by-N orthogonal matrix V**T;
            if JOBZ = 'S', VT contains the first min(M,N) rows of
            V**T (the right singular vectors, stored rowwise);
            if JOBZ = 'O' and M &amp;lt; N, or JOBZ = 'N', VT is not referenced.
            </code>
            <code>
            LDVT is INTEGER
            The leading dimension of the array VT.  LDVT >= 1; if
            JOBZ = 'A' or JOBZ = 'O' and M >= N, LDVT >= N;
            if JOBZ = 'S', LDVT >= min(M,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK;
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= 1.
            If JOBZ = 'N',
              LWORK >= 3*min(M,N) + max(max(M,N),7*min(M,N)).
            If JOBZ = 'O',
              LWORK >= 3*min(M,N) +
                       max(max(M,N),5*min(M,N)*min(M,N)+4*min(M,N)).
            If JOBZ = 'S' or 'A'
              LWORK >= 3*min(M,N) +
                       max(max(M,N),4*min(M,N)*min(M,N)+3*min(M,N)+max(M,N)).
            For good performance, LWORK should generally be larger.
            If LWORK = -1 but other input arguments are legal, WORK(1)
            returns the optimal LWORK.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (8*min(M,N))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  DBDSDC did not converge, updating process failed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If singular vectors are desired, it uses a
            divide-and-conquer algorithm.
            The SVD is written
                 A = U * SIGMA * transpose(V)
            where SIGMA is an M-by-N matrix which is zero except for its
            min(m,n) diagonal elements, U is an M-by-M orthogonal matrix, and
            V is an N-by-N orthogonal matrix.  The diagonal elements of SIGMA
            are the singular values of A; they are real and non-negative, and
            are returned in descending order.  The first min(m,n) columns of
            U and V are the left and right singular vectors of A.
            Note that the routine returns VT = V**T, not V.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgeqpf(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Routine is deprecated and has been replaced by routine DGEQP3.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A. N >= 0
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, the upper triangle of the array contains the
            min(M,N)-by-N upper triangular matrix R; the elements
            below the diagonal, together with the array TAU,
            represent the orthogonal matrix Q as a product of
            min(m,n) elementary reflectors.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="jpvt">
            <code>
            JPVT is INTEGER array, dimension (N)
            On entry, if JPVT(i) .ne. 0, the i-th column of A is permuted
            to the front of A*P (a leading column); if JPVT(i) = 0,
            the i-th column of A is a free column.
            On exit, if JPVT(i) = k, then the i-th column of A*P
            was the k-th column of A.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            DGEQPF computes a QR factorization with column pivoting of a
            real M-by-N matrix A: A*P = Q*R.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(n)
            Each H(i) has the form
               H = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i-1) = 0 and v(i) = 1; v(i+1:m) is stored on exit in A(i+1:m,i).
            The matrix P is represented in jpvt as follows: If
               jpvt(j) = i
            then the jth column of P is the ith canonical unit vector.
            Partial column norm updating strategy modified by
              Z. Drmac and Z. Bujanovic, Dept. of Mathematics,
              University of Zagreb, Croatia.
            -- April 2011                                                      --
            For more details see LAPACK Working Note 176.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgerq2(System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes an RQ factorization of a real m by n matrix A:
            A = R * Q.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the m by n matrix A.
            On exit, if m &amp;lt;= n, the upper triangle of the subarray
            A(1:m,n-m+1:n) contains the m by m upper triangular matrix R;
            if m >= n, the elements on and above the (m-n)-th subdiagonal
            contain the m by n upper trapezoidal matrix R; the remaining
            elements, with the array TAU, represent the orthogonal matrix
            Q as a product of elementary reflectors (see Further
            Details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(M,N))
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The matrix Q is represented as a product of elementary reflectors
               Q = H(1) H(2) . . . H(k), where k = min(m,n).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(n-k+i+1:n) = 0 and v(n-k+i) = 1; v(1:n-k+i-1) is stored on exit in
            A(m-k+i,1:n-k+i-1), and tau in TAU(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUEstimateCondition(Extreme.Mathematics.MatrixNorm,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a real
            general band matrix A, in either the 1-norm or the infinity-norm,
            using the LU factorization computed by DGBTRF.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            If NORM = '1' or 'O', the 1-norm of the original matrix A.
            If NORM = 'I', the infinity-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dgbtf2(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U, because of fill-in resulting from the row
            interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUDecompose(System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes an LU factorization of a real m-by-n band matrix A
            using partial pivoting with row interchanges.</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            On entry, the matrix A in band storage, in rows KL+1 to
            2*KL+KU+1; rows 1 to KL of the array need not be set.
            The j-th column of A is stored in the j-th column of the
            array AB as follows:
            AB(kl+ku+1+i-j,j) = A(i,j) for max(1,j-ku)&amp;lt;=i&amp;lt;=min(m,j+kl)
            On exit, details of the factorization: U is stored as an
            upper triangular band matrix with KL+KU superdiagonals in
            rows 1 to KL+KU+1, and the multipliers used during the
            factorization are stored in rows KL+KU+2 to 2*KL+KU+1.
            See below for further details.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (min(M,N))
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= min(M,N), row i of the
            matrix was interchanged with row IPIV(i).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = +i, U(i,i) is exactly zero. The factorization
                 has been completed, but the factor U is exactly
                 singular, and division by zero will occur if it is used
                 to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            M = N = 6, KL = 2, KU = 1:
            On entry:                       On exit:
                *    *    *    +    +    +       *    *    *   u14  u25  u36
                *    *    +    +    +    +       *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
               a21  a32  a43  a54  a65   *      m21  m32  m43  m54  m65   *
               a31  a42  a53  a64   *    *      m31  m42  m53  m64   *    *
            Array elements marked * are not used by the routine; elements marked
            + need not be set on entry, but are required by the routine to store
            elements of U because of fill-in resulting from the row interchanges.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandLUSolve(Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations
               A * X = B  or  A**T * X = B
            with a general band matrix A using the LU factorization computed
            by DGBTRF.</para>
            </summary>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations.
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T* X = B  (Transpose)
            = 'C':  A**T* X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kl">
            <code>
            KL is INTEGER
            The number of subdiagonals within the band of A.  KL >= 0.
            </code>
            </param>
            <param name="ku">
            <code>
            KU is INTEGER
            The number of superdiagonals within the band of A.  KU >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            Details of the LU factorization of the band matrix A, as
            computed by DGBTRF.  U is stored as an upper triangular band
            matrix with KL+KU superdiagonals in rows 1 to KL+KU+1, and
            the multipliers used during the factorization are stored in
            rows KL+KU+2 to 2*KL+KU+1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= 2*KL+KU+1.
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            The pivot indices; for 1 &amp;lt;= i &amp;lt;= N, row i of the matrix was
            interchanged with row IPIV(i).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dggsvp(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},`0,`0,System.Int32@,System.Int32@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes orthogonal matrices U, V and Q such that
                               N-K-L  K    L
             U**T*A*Q =     K ( 0    A12  A13 )  if M-K-L >= 0;
                            L ( 0     0   A23 )
                        M-K-L ( 0     0    0  )
                             N-K-L  K    L
                    =     K ( 0    A12  A13 )  if M-K-L &amp;lt; 0;
                        M-K ( 0     0   A23 )
                             N-K-L  K    L
             V**T*B*Q =   L ( 0     0   B13 )
                        P-L ( 0     0    0  )
            where the K-by-K matrix A12 and L-by-L matrix B13 are nonsingular
            upper triangular; A23 is L-by-L upper triangular if M-K-L >= 0,
            otherwise A23 is (M-K)-by-L upper trapezoidal.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Orthogonal matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Orthogonal matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Orthogonal matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular (or trapezoidal) matrix
            described in the Purpose section.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix described in
            the Purpose section.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="tola">
            <code>
            TOLA is DOUBLE PRECISION
            </code>
            </param>
            <param name="tolb">
            <code>
            TOLB is DOUBLE PRECISION
            TOLA and TOLB are the thresholds to determine the effective
            numerical rank of matrix B and a subblock of A. Generally,
            they are set to
               TOLA = MAX(M,N)*norm(A)*MACHEPS,
               TOLB = MAX(P,N)*norm(B)*MACHEPS.
            The size of TOLA and TOLB may affect the size of backward
            errors of the decomposition.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose section.
            K + L = effective numerical rank of (A**T,B**T)**T.
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU,M)
            If JOBU = 'U', U contains the orthogonal matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,P)
            If JOBV = 'V', V contains the orthogonal matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the orthogonal matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (max(3*N,M,P))
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            K+L = the effective
            numerical rank of the (M+P)-by-N matrix (A**T,B**T)**T.
            This decomposition is the preprocessing step for computing the
            Generalized Singular Value Decomposition (GSVD), see subroutine
            DGGSVD.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
             The subroutine uses LAPACK subroutine DGEQPF for the QR factorization
             with column pivoting to detect the effective numerical rank of the
             a matrix. It may be replaced by a better rank determination strategy.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dggsvd(System.Char,System.Char,System.Char,System.Int32,System.Int32,System.Int32,System.Int32@,System.Int32@,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the generalized singular value decomposition (GSVD)
            of an M-by-N real matrix A and P-by-N real matrix B:
                  U**T*A*Q = D1*( 0 R ),    V**T*B*Q = D2*( 0 R )
            where U, V and Q are orthogonal matrices.</para>
            </summary>
            <param name="jobu">
            <code>
            JOBU is CHARACTER*1
            = 'U':  Orthogonal matrix U is computed;
            = 'N':  U is not computed.
            </code>
            </param>
            <param name="jobv">
            <code>
            JOBV is CHARACTER*1
            = 'V':  Orthogonal matrix V is computed;
            = 'N':  V is not computed.
            </code>
            </param>
            <param name="jobq">
            <code>
            JOBQ is CHARACTER*1
            = 'Q':  Orthogonal matrix Q is computed;
            = 'N':  Q is not computed.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix A.  M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrices A and B.  N >= 0.
            </code>
            </param>
            <param name="p">
            <code>
            P is INTEGER
            The number of rows of the matrix B.  P >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            </code>
            </param>
            <param name="l">
            <code>
            L is INTEGER
            On exit, K and L specify the dimension of the subblocks
            described in Purpose.
            K + L = effective numerical rank of (A**T,B**T)**T.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the M-by-N matrix A.
            On exit, A contains the triangular matrix R, or part of R.
            See Purpose for details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,N)
            On entry, the P-by-N matrix B.
            On exit, B contains the triangular matrix R if M-K-L &amp;lt; 0.
            See Purpose for details.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B. LDB >= max(1,P).
            </code>
            </param>
            <param name="alpha">
            <code>
            ALPHA is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="beta">
            <code>
            BETA is DOUBLE PRECISION array, dimension (N)
            On exit, ALPHA and BETA contain the generalized singular
            value pairs of A and B;
              ALPHA(1:K) = 1,
              BETA(1:K)  = 0,
            and if M-K-L >= 0,
              ALPHA(K+1:K+L) = C,
              BETA(K+1:K+L)  = S,
            or if M-K-L &amp;lt; 0,
              ALPHA(K+1:M)=C, ALPHA(M+1:K+L)=0
              BETA(K+1:M) =S, BETA(M+1:K+L) =1
            and
              ALPHA(K+L+1:N) = 0
              BETA(K+L+1:N)  = 0
            </code>
            </param>
            <param name="u">
            <code>
            U is DOUBLE PRECISION array, dimension (LDU,M)
            If JOBU = 'U', U contains the M-by-M orthogonal matrix U.
            If JOBU = 'N', U is not referenced.
            </code>
            <code>
            LDU is INTEGER
            The leading dimension of the array U. LDU >= max(1,M) if
            JOBU = 'U'; LDU >= 1 otherwise.
            </code>
            </param>
            <param name="v">
            <code>
            V is DOUBLE PRECISION array, dimension (LDV,P)
            If JOBV = 'V', V contains the P-by-P orthogonal matrix V.
            If JOBV = 'N', V is not referenced.
            </code>
            <code>
            LDV is INTEGER
            The leading dimension of the array V. LDV >= max(1,P) if
            JOBV = 'V'; LDV >= 1 otherwise.
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            If JOBQ = 'Q', Q contains the N-by-N orthogonal matrix Q.
            If JOBQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q. LDQ >= max(1,N) if
            JOBQ = 'Q'; LDQ >= 1 otherwise.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array,
                        dimension (max(3*N,M,P)+N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            On exit, IWORK stores the sorting information. More
            precisely, the following loop will sort ALPHA
               for I = K+1, min(M,K+L)
                   swap ALPHA(I) and ALPHA(IWORK(I))
               endfor
            such that ALPHA(1) >= ALPHA(2) >= ... >= ALPHA(N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  if INFO = 1, the Jacobi-type procedure failed to
                  converge.  For further details, see subroutine DTGSJA.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Let K+L = the effective numerical rank of the matrix (A**T,B**T)**T,
            then R is a K+L-by-K+L nonsingular upper triangular matrix, D1 and
            D2 are M-by-(K+L) and P-by-(K+L) "diagonal" matrices and of the
            following structures, respectively:
            If M-K-L >= 0,
                                K  L
                   D1 =     K ( I  0 )
                            L ( 0  C )
                        M-K-L ( 0  0 )
                              K  L
                   D2 =   L ( 0  S )
                        P-L ( 0  0 )
                            N-K-L  K    L
              ( 0 R ) = K (  0   R11  R12 )
                        L (  0    0   R22 )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(K+L) ),
              S = diag( BETA(K+1),  ... , BETA(K+L) ),
              C**2 + S**2 = I.
              R is stored in A(1:K+L,N-K-L+1:N) on exit.
            If M-K-L &amp;lt; 0,
                              K M-K K+L-M
                   D1 =   K ( I  0    0   )
                        M-K ( 0  C    0   )
                                K M-K K+L-M
                   D2 =   M-K ( 0  S    0  )
                        K+L-M ( 0  0    I  )
                          P-L ( 0  0    0  )
                               N-K-L  K   M-K  K+L-M
              ( 0 R ) =     K ( 0    R11  R12  R13  )
                          M-K ( 0     0   R22  R23  )
                        K+L-M ( 0     0    0   R33  )
            where
              C = diag( ALPHA(K+1), ... , ALPHA(M) ),
              S = diag( BETA(K+1),  ... , BETA(M) ),
              C**2 + S**2 = I.
              (R11 R12 R13 ) is stored in A(1:M, N-K-L+1:N), and R33 is stored
              ( 0  R22 R23 )
              in B(M-K+1:L,N+M-K-L+1:N) on exit.
            The routine computes C, S, R, and optionally the orthogonal
            transformation matrices U, V and Q.
            In particular, if B is an N-by-N nonsingular matrix, then the GSVD of
            A and B implicitly gives the SVD of A*inv(B):
                                 A*inv(B) = U*(D1*inv(D2))*V**T.
            If ( A**T,B**T)**T  has orthonormal columns, then the GSVD of A and B is
            also equal to the CS decomposition of A and B. Furthermore, the GSVD
            can be used to derive the solution of the eigenvalue problem:
                                 A**T*A x = lambda* B**T*B x.
            In some literature, the GSVD of A and B is presented in the form
                             U**T*A*X = ( 0 D1 ),   V**T*B*X = ( 0 D2 )
            where U and V are orthogonal and X is nonsingular, D1 and D2 are
            ``diagonal''.  The former GSVD form can be converted to the latter
            form by taking the nonsingular matrix X as
                                 X = Q*( I   0    )
                                       ( 0 inv(R) ).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                Ming Gu and Huan Ren, Computer Science Division, University of
                California at Berkeley, USA
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlamch(System.Char)">
            <summary>
            <para>
            Determines T precision machine parameters.</para>
            </summary>
            <param name="cmach">
            <pre>
            Specifies the value to be returned by DLAMCH:
            = 'E' or 'e',   DLAMCH := eps
            = 'S' or 's ,   DLAMCH := sfmin
            = 'B' or 'b',   DLAMCH := base
            = 'P' or 'p',   DLAMCH := eps*base
            = 'N' or 'n',   DLAMCH := t
            = 'R' or 'r',   DLAMCH := rnd
            = 'M' or 'm',   DLAMCH := emin
            = 'U' or 'u',   DLAMCH := rmin
            = 'L' or 'l',   DLAMCH := emax
            = 'O' or 'o',   DLAMCH := rmax
            where
            eps   = relative machine precision
            sfmin = safe minimum, such that 1/sfmin does not overflow
            base  = base of the machine
            prec  = eps*base
            t     = number of (base) digits in the mantissa
            rnd   = 1.0 when rounding occurs in addition, 0.0 otherwise
            emin  = minimum exponent before (gradual) underflow
            rmin  = underflow threshold - base**(emin-1)
            emax  = largest exponent before overflow
            rmax  = overflow threshold  - (base**emax)*(1-eps)
            </pre>
            </param>
            <remarks>
            <para>
            <pre>
            </pre>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dlamc3(`0,`0)">
            <summary>
            </summary>
            <param name="a">
            <pre>
            A is a DOUBLE PRECISION
            </pre>
            </param>
            <param name="b">
            <pre>
            B is a DOUBLE PRECISION
            The values A and B.
            </pre>
            </param>
            <remarks>
            <pre>
            DLAMC3  is intended to force  A  and  B  to be stored prior to doing
            the addition of  A  and  B ,  for use in situations where optimizers
            might hold one of these in a register.
            </pre>
            <para>Authors: 
             LAPACK is a software package provided by Univ. of Tennessee, Univ. of California Berkeley, Univ. of Colorado Denver and NAG Ltd..</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorm2r(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by DGEQRF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.QROrthogonalMultiply(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQRF in the first k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by DGEQRF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormhr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            If SIDE = 'L', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= M, if M > 0, and
            ILO = 1 and IHI = 0, if M = 0;
            if SIDE = 'R', then 1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0, and
            ILO = 1 and IHI = 0, if N = 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by DGEHRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            IHI-ILO elementary reflectors, as returned by DGEHRD:
            Q = H(ilo) H(ilo+1) . . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorg2r(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Generates an m by n real matrix Q with orthonormal columns,
            which is defined as the first n columns of a product of k elementary
            reflectors of order m
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by DGEQRF in the first k columns of its array
            argument A.
            On exit, the m-by-n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by DGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorgqr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N real matrix Q with orthonormal columns,
            which is defined as the first N columns of a product of K elementary
            reflectors of order M
                  Q  =  H(1) H(2) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. M >= N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th column must contain the vector which
            defines the elementary reflector H(i), for i = 1,2,...,k, as
            returned by DGEQRF in the first k columns of its array
            argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,N).
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by DGEQRF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorghr(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates a real orthogonal matrix Q which is defined as the
            product of IHI-ILO elementary reflectors of order N, as returned by
            DGEHRD:
            Q = H(ilo) H(ilo+1) .</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix Q. N >= 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
            ILO and IHI must have the same values as in the previous call
            of DGEHRD. Q is equal to the unit matrix except in the
            submatrix Q(ilo+1:ihi,ilo+1:ihi).
            1 &amp;lt;= ILO &amp;lt;= IHI &amp;lt;= N, if N > 0; ILO=1 and IHI=0, if N=0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by DGEHRD.
            On exit, the N-by-N orthogonal matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEHRD.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= IHI-ILO.
            For optimum performance LWORK >= (IHI-ILO)*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(ihi-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorgl2(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Generates an m by n real matrix Q with orthonormal rows,
            which is defined as the first m rows of a product of k elementary
            reflectors of order n
                  Q  =  H(k) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by DGELQF in the first k rows of its array argument A.
            On exit, the m-by-n matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (M)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorglq(System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates an M-by-N real matrix Q with orthonormal rows,
            which is defined as the first M rows of a product of K elementary
            reflectors of order N
                  Q  =  H(k) .</para>
            </summary>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q. N >= M.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines the
            matrix Q. M >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the i-th row must contain the vector which defines
            the elementary reflector H(i), for i = 1,2,...,k, as returned
            by DGELQF in the first k rows of its array argument A.
            On exit, the M-by-N matrix Q.
            </code>
            <code>
            LDA is INTEGER
            The first dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,M).
            For optimum performance LWORK >= M*NB, where NB is
            the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument has an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGELQF.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorgbr(System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Generates one of the real orthogonal matrices Q or P**T
            determined by DGEBRD when reducing a real matrix A to bidiagonal
            form: A = Q * B * P**T.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            Specifies whether the matrix Q or the matrix P**T is
            required, as defined in the transformation applied by DGEBRD:
            = 'Q':  generate Q;
            = 'P':  generate P**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix Q or P**T to be returned.
            M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix Q or P**T to be returned.
            N >= 0.
            If VECT = 'Q', M >= N >= min(M,K);
            if VECT = 'P', N >= M >= min(N,K).
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original M-by-K
            matrix reduced by DGEBRD.
            If VECT = 'P', the number of rows in the original K-by-N
            matrix reduced by DGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the vectors which define the elementary reflectors,
            as returned by DGEBRD.
            On exit, the M-by-N matrix Q or P**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,M).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension
                                  (min(M,K)) if VECT = 'Q'
                                  (min(N,K)) if VECT = 'P'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i), which determines Q or P**T, as
            returned by DGEBRD in its array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK. LWORK >= max(1,min(M,N)).
            For optimum performance LWORK >= min(M,N)*NB, where NB
            is the optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and P**T are defined as products of
            elementary reflectors H(i) or G(i) respectively.
            If VECT = 'Q', A is assumed to have been an M-by-K matrix, and Q
            is of order M:
            if m >= k, Q = H(1) H(2) . . . H(k) and DORGBR returns the first n
            columns of Q, where m >= n >= k;
            if m &amp;lt; k, Q = H(1) H(2) . . . H(m-1) and DORGBR returns Q as an
            M-by-M matrix.
            If VECT = 'P', A is assumed to have been a K-by-N matrix, and P**T
            is of order N:
            if k &amp;lt; n, P**T = G(k) . . . G(2) G(1) and DORGBR returns the first m
            rows of P**T, where n >= m >= k;
            if k >= n, P**T = G(n-1) . . . G(2) G(1) and DORGBR returns P**T as
            an N-by-N matrix.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  April 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorml2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGELQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormlq(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGELQF in the first k rows of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGELQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGELQF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormbr(System.Char,Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            VECT = 'Q', DORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            If VECT = 'P', DORMBR overwrites the general real M-by-N matrix C
            with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      P * C          C * P
            TRANS = 'T':      P**T * C       C * P**T
            Here Q and P**T are the orthogonal matrices determined by DGEBRD when
            reducing a real matrix A to bidiagonal form: A = Q * B * P**T.</para>
            </summary>
            <param name="vect">
            <code>
            VECT is CHARACTER*1
            = 'Q': apply Q or Q**T;
            = 'P': apply P or P**T.
            </code>
            </param>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q, Q**T, P or P**T from the Left;
            = 'R': apply Q, Q**T, P or P**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q  or P;
            = 'T':  Transpose, apply Q**T or P**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            If VECT = 'Q', the number of columns in the original
            matrix reduced by DGEBRD.
            If VECT = 'P', the number of rows in the original
            matrix reduced by DGEBRD.
            K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                  (LDA,min(nq,K)) if VECT = 'Q'
                                  (LDA,nq)        if VECT = 'P'
            The vectors which define the elementary reflectors H(i) and
            G(i), whose products determine the matrices Q and P, as
            returned by DGEBRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If VECT = 'Q', LDA >= max(1,nq);
            if VECT = 'P', LDA >= max(1,min(nq,K)).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (min(nq,K))
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i) or G(i) which determines Q or P, as returned
            by DGEBRD in the array argument TAUQ or TAUP.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q
            or P*C or P**T*C or C*P or C*P**T.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q and
            P**T are defined as products of elementary reflectors H(i) and G(i)
            respectively.
            Let nq = m if SIDE = 'L' and nq = n if SIDE = 'R'. Thus nq is the
            order of the orthogonal matrix Q or P**T that is applied.
            If VECT = 'Q', A is assumed to have been an NQ-by-K matrix:
            if nq >= k, Q = H(1) H(2) . . . H(k);
            if nq &amp;lt; k, Q = H(1) H(2) . . . H(nq-1).
            If VECT = 'P', A is assumed to have been a K-by-NQ matrix:
            if k &amp;lt; nq, P = G(1) G(2) . . . G(k);
            if k >= nq, P = G(1) G(2) . . . G(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormr2(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T* C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(1) H(2) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q' (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L',
                                 (LDA,N) if SIDE = 'R'
            The i-th row must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGERQF in the last k rows of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A. LDA >= max(1,K).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGERQF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(k)
            as returned by DGERQF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dorm2l(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Overwrites the general real m by n matrix C with
                  Q * C  if SIDE = 'L' and TRANS = 'N', or
                  Q**T * C  if SIDE = 'L' and TRANS = 'T', or
                  C * Q  if SIDE = 'R' and TRANS = 'N', or
                  C * Q**T if SIDE = 'R' and TRANS = 'T',
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left
            = 'R': apply Q or Q**T from the Right
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N': apply Q  (No transpose)
            = 'T': apply Q**T (Transpose)
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            A is modified by the routine but restored on exit.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the m by n matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension
                                     (N) if SIDE = 'L',
                                     (M) if SIDE = 'R'
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGEQLF. Q is of order m if SIDE = 'L' and of order n
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormql(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix defined as the product of k
            elementary reflectors
                  Q = H(k) .</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="k">
            <code>
            K is INTEGER
            The number of elementary reflectors whose product defines
            the matrix Q.
            If SIDE = 'L', M >= K >= 0;
            if SIDE = 'R', N >= K >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,K)
            The i-th column must contain the vector which defines the
            elementary reflector H(i), for i = 1,2,...,k, as returned by
            DGEQLF in the last k columns of its array argument A.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            If SIDE = 'L', LDA >= max(1,M);
            if SIDE = 'R', LDA >= max(1,N).
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (K)
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DGEQLF.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            . . H(2) H(1)
            as returned by DGEQLF. Q is of order M if SIDE = 'L' and of order N
            if SIDE = 'R'.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dormtr(Extreme.Mathematics.MatrixOperationSide,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Overwrites the general real M-by-N matrix C with
                            SIDE = 'L'     SIDE = 'R'
            TRANS = 'N':      Q * C          C * Q
            TRANS = 'T':      Q**T * C       C * Q**T
            where Q is a real orthogonal matrix of order nq, with nq = m if
            SIDE = 'L' and nq = n if SIDE = 'R'.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'L': apply Q or Q**T from the Left;
            = 'R': apply Q or Q**T from the Right.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U': Upper triangle of A contains elementary reflectors
                   from DSYTRD;
            = 'L': Lower triangle of A contains elementary reflectors
                   from DSYTRD.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            = 'N':  No transpose, apply Q;
            = 'T':  Transpose, apply Q**T.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of rows of the matrix C. M >= 0.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The number of columns of the matrix C. N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension
                                 (LDA,M) if SIDE = 'L'
                                 (LDA,N) if SIDE = 'R'
            The vectors which define the elementary reflectors, as
            returned by DSYTRD.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.
            LDA >= max(1,M) if SIDE = 'L'; LDA >= max(1,N) if SIDE = 'R'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension
                                 (M-1) if SIDE = 'L'
                                 (N-1) if SIDE = 'R'
            TAU(i) must contain the scalar factor of the elementary
            reflector H(i), as returned by DSYTRD.
            </code>
            </param>
            <param name="c">
            <code>
            C is DOUBLE PRECISION array, dimension (LDC,N)
            On entry, the M-by-N matrix C.
            On exit, C is overwritten by Q*C or Q**T*C or C*Q**T or C*Q.
            </code>
            <code>
            LDC is INTEGER
            The leading dimension of the array C. LDC >= max(1,M).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If SIDE = 'L', LWORK >= max(1,N);
            if SIDE = 'R', LWORK >= max(1,M).
            For optimum performance LWORK >= N*NB if SIDE = 'L', and
            LWORK >= M*NB if SIDE = 'R', where NB is the optimal
            blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Q is defined as the product of
            nq-1 elementary reflectors, as returned by DSYTRD:
            if UPLO = 'U', Q = H(nq-1) . . . H(2) H(1);
            if UPLO = 'L', Q = H(1) H(2) . . . H(nq-1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite band matrix using the
            Cholesky factorization A = U**T*U or A = L*L**T computed by DPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm (or infinity-norm) of the symmetric band matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dpbtf2(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of super-diagonals of the matrix A if UPLO = 'U',
            or the number of sub-diagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**T*U or A = L*L**T of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U ,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix, U**T is the transpose of U, and
            L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite band matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            On entry, the upper or lower triangle of the symmetric band
            matrix A, stored in the first KD+1 rows of the array.  The
            j-th column of A is stored in the j-th column of the array AB
            as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            On exit, if INFO = 0, the triangular factor U or L from the
            Cholesky factorization A = U**T*U or A = L*L**T of the band
            matrix A, in the same storage format as A.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The band storage scheme is illustrated by the following example, when
            N = 6, KD = 2, and UPLO = 'U':
            On entry:                       On exit:
                *    *   a13  a24  a35  a46      *    *   u13  u24  u35  u46
                *   a12  a23  a34  a45  a56      *   u12  u23  u34  u45  u56
               a11  a22  a33  a44  a55  a66     u11  u22  u33  u44  u55  u66
            Similarly, if UPLO = 'L' the format of A is as follows:
            On entry:                       On exit:
               a11  a22  a33  a44  a55  a66     l11  l22  l33  l44  l55  l66
               a21  a32  a43  a54  a65   *      l21  l32  l43  l54  l65   *
               a31  a42  a53  a64   *    *      l31  l42  l53  l64   *    *
            Array elements marked * are not used by the routine.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
             Peter Mayes and Giuseppe Radicati, IBM ECSEC, Rome, March 23, 1989
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.BandCholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite band matrix A using the Cholesky factorization
            A = U**T*U or A = L*L**T computed by DPBTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangular factor stored in AB;
            = 'L':  Lower triangular factor stored in AB.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals of the matrix A if UPLO = 'U',
            or the number of subdiagonals if UPLO = 'L'.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T of the band matrix A, stored in the
            first KD+1 rows of the array.  The j-th column of U or L is
            stored in the j-th column of the array AB as follows:
            if UPLO ='U', AB(kd+1+i-j,j) = U(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO ='L', AB(1+i-j,j)    = L(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dpotf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n by n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T *U  or A = L*L**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, the leading minor of order k is not
                 positive definite, and the factorization could not be
                 completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U ,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},`0,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric positive definite matrix using the
            Cholesky factorization A = U**T*U or A = L*L**T computed by DPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T, as computed by DPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm (or infinity-norm) of the symmetric matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the Cholesky factorization of a real symmetric
            positive definite matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if INFO = 0, the factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the leading minor of order i is not
                  positive definite, and the factorization could not be
                  completed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The factorization has the form
               A = U**T * U,  if UPLO = 'U', or
               A = L  * L**T,  if UPLO = 'L',
            where U is an upper triangular matrix and L is lower triangular.
            This is the block version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskyInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric positive definite
            matrix A using the Cholesky factorization A = U**T*U or A = L*L**T
            computed by DPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular factor U or L from the Cholesky
            factorization A = U**T*U or A = L*L**T, as computed by
            DPOTRF.
            On exit, the upper or lower triangle of the (symmetric)
            inverse of A, overwriting the input factor U or L.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the (i,i) element of the factor U or L is
                  zero, and the inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.CholeskySolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a symmetric
            positive definite matrix A using the Cholesky factorization
            A = U**T*U or A = L*L**T computed by DPOTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The triangular factor U or L from the Cholesky factorization
            A = U**T*U or A = L*L**T, as computed by DPOTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsytf2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method:
               A = U*D*U**T  or  A = L*D*L**T
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, U**T is the transpose of U, and D is symmetric and
            block diagonal with 1-by-1 and 2-by-2 diagonal blocks.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            > 0: if INFO = k, D(k,k) is exactly zero.  The factorization
                 has been completed, but the block diagonal matrix D is
                 exactly singular, and division by zero will occur if it
                 is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the unblocked version of the algorithm, calling Level 2 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**T, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**T, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            <code>
            09-29-06 - patch from
              Bobby Cheng, MathWorks
              Replace l.204 and l.372
                   IF( MAX( ABSAKK, COLMAX ).EQ.ZERO ) THEN
              by
                   IF( (MAX( ABSAKK, COLMAX ).EQ.ZERO) .OR. DISNAN(ABSAKK) ) THEN
            01-01-96 - Based on modifications by
              J. Lewis, Boeing Computer Services Company
              A. Petitet, Computer Science Dept., Univ. of Tenn., Knoxville, USA
            1-96 - Based on modifications by J. Lewis, Boeing Computer Services
                   Company
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricDecompose(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the factorization of a real symmetric matrix A using
            the Bunch-Kaufman diagonal pivoting method.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, the block diagonal matrix D and the multipliers used
            to obtain the factor U or L (see below for further details).
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D.
            If IPIV(k) > 0, then rows and columns k and IPIV(k) were
            interchanged and D(k,k) is a 1-by-1 diagonal block.
            If UPLO = 'U' and IPIV(k) = IPIV(k-1) &amp;lt; 0, then rows and
            columns k-1 and -IPIV(k) were interchanged and D(k-1:k,k-1:k)
            is a 2-by-2 diagonal block.  If UPLO = 'L' and IPIV(k) =
            IPIV(k+1) &amp;lt; 0, then rows and columns k+1 and -IPIV(k) were
            interchanged and D(k:k+1,k:k+1) is a 2-by-2 diagonal block.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The length of WORK.  LWORK >=1.  For best performance
            LWORK >= N*NB, where NB is the block size returned by ILAENV.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, D(i,i) is exactly zero.  The factorization
                  has been completed, but the block diagonal matrix D is
                  exactly singular, and division by zero will occur if it
                  is used to solve a system of equations.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The form of the
            factorization is
               A = U*D*U**T  or  A = L*D*L**T
            where U (or L) is a product of permutation and unit upper (lower)
            triangular matrices, and D is symmetric and block diagonal with
            1-by-1 and 2-by-2 diagonal blocks.
            This is the blocked version of the algorithm, calling Level 3 BLAS.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', then A = U*D*U**T, where
               U = P(n)*U(n)* ... *P(k)U(k)* ...,
            i.e., U is a product of terms P(k)*U(k), where k decreases from n to
            1 in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and U(k) is a unit upper triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    v    0   )   k-s
               U(k) =  (   0    I    0   )   s
                       (   0    0    I   )   n-k
                          k-s   s   n-k
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(1:k-1,k).
            If s = 2, the upper triangle of D(k) overwrites A(k-1,k-1), A(k-1,k),
            and A(k,k), and v overwrites A(1:k-2,k-1:k).
            If UPLO = 'L', then A = L*D*L**T, where
               L = P(1)*L(1)* ... *P(k)*L(k)* ...,
            i.e., L is a product of terms P(k)*L(k), where k increases from 1 to
            n in steps of 1 or 2, and D is a block diagonal matrix with 1-by-1
            and 2-by-2 diagonal blocks D(k).  P(k) is a permutation matrix as
            defined by IPIV(k), and L(k) is a unit lower triangular matrix, such
            that if the diagonal block D(k) is of order s (s = 1 or 2), then
                       (   I    0     0   )  k-1
               L(k) =  (   0    I     0   )  s
                       (   0    v     I   )  n-k-s+1
                          k-1   s  n-k-s+1
            If s = 1, D(k) overwrites A(k,k), and v overwrites A(k+1:n,k).
            If s = 2, the lower triangle of D(k) overwrites A(k,k), A(k+1,k),
            and A(k+1,k+1), and v overwrites A(k+2:n,k:k+1).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricSolve(Extreme.Mathematics.MatrixTriangle,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a system of linear equations A*X = B with a real
            symmetric matrix A using the factorization A = U*D*U**T or
            A = L*D*L**T computed by DSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricInvert(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real symmetric indefinite matrix
            A using the factorization A = U*D*U**T or A = L*D*L**T computed by
            DSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the block diagonal matrix D and the multipliers
            used to obtain the factor U or L as computed by DSYTRF.
            On exit, if INFO = 0, the (symmetric) inverse of the original
            matrix.  If UPLO = 'U', the upper triangular part of the
            inverse is formed and the part of A below the diagonal is not
            referenced; if UPLO = 'L' the lower triangular part of the
            inverse is formed and the part of A above the diagonal is
            not referenced.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, D(i,i) = 0; the matrix is singular and its
                 inverse could not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.SymmetricEstimateCondition(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{System.Int32},`0,`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number (in the
            1-norm) of a real symmetric matrix A using the factorization
            A = U*D*U**T or A = L*D*L**T computed by DSYTRF.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the details of the factorization are stored
            as an upper or lower triangular matrix.
            = 'U':  Upper triangular, form is A = U*D*U**T;
            = 'L':  Lower triangular, form is A = L*D*L**T.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The block diagonal matrix D and the multipliers used to
            obtain the factor U or L as computed by DSYTRF.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="ipiv">
            <code>
            IPIV is INTEGER array, dimension (N)
            Details of the interchanges and the block structure of D
            as determined by DSYTRF.
            </code>
            </param>
            <param name="anorm">
            <code>
            ANORM is DOUBLE PRECISION
            The 1-norm of the original matrix A.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(ANORM * AINVNM), where AINVNM is an
            estimate of the 1-norm of inv(A) computed in this routine.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (2*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            An estimate is obtained for norm(inv(A)), and the reciprocal of the
            condition number is computed as RCOND = 1 / (ANORM * norm(inv(A))).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsytd2(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Reduces a real symmetric matrix A to symmetric tridiagonal
            form T by an orthogonal similarity transformation: Q**T * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the upper or lower triangular part of the
            symmetric matrix A is stored:
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            n-by-n upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n-by-n lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the orthogonal
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the orthogonal matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsytrd(Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Reduces a real symmetric matrix A to real symmetric
            tridiagonal form T by an orthogonal similarity transformation:
            Q**T * A * Q = T.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the leading
            N-by-N upper triangular part of A contains the upper
            triangular part of the matrix A, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of A contains the lower
            triangular part of the matrix A, and the strictly upper
            triangular part of A is not referenced.
            On exit, if UPLO = 'U', the diagonal and first superdiagonal
            of A are overwritten by the corresponding elements of the
            tridiagonal matrix T, and the elements above the first
            superdiagonal, with the array TAU, represent the orthogonal
            matrix Q as a product of elementary reflectors; if UPLO
            = 'L', the diagonal and first subdiagonal of A are over-
            written by the corresponding elements of the tridiagonal
            matrix T, and the elements below the first subdiagonal, with
            the array TAU, represent the orthogonal matrix Q as a product
            of elementary reflectors. See Further Details.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            The diagonal elements of the tridiagonal matrix T:
            D(i) = A(i,i).
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            The off-diagonal elements of the tridiagonal matrix T:
            E(i) = A(i,i+1) if UPLO = 'U', E(i) = A(i+1,i) if UPLO = 'L'.
            </code>
            </param>
            <param name="tau">
            <code>
            TAU is DOUBLE PRECISION array, dimension (N-1)
            The scalar factors of the elementary reflectors (see Further
            Details).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (MAX(1,LWORK))
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.  LWORK >= 1.
            For optimum performance LWORK >= N*NB, where NB is the
            optimal blocksize.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            If UPLO = 'U', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(n-1) . . . H(2) H(1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(i+1:n) = 0 and v(i) = 1; v(1:i-1) is stored on exit in
            A(1:i-1,i+1), and tau in TAU(i).
            If UPLO = 'L', the matrix Q is represented as a product of elementary
            reflectors
               Q = H(1) H(2) . . . H(n-1).
            Each H(i) has the form
               H(i) = I - tau * v * v**T
            where tau is a real scalar, and v is a real vector with
            v(1:i) = 0 and v(i+1) = 1; v(i+2:n) is stored on exit in A(i+2:n,i),
            and tau in TAU(i).
            The contents of A on exit are illustrated by the following examples
            with n = 5:
            if UPLO = 'U':                       if UPLO = 'L':
              (  d   e   v2  v3  v4 )              (  d                  )
              (      d   e   v3  v4 )              (  e   d              )
              (          d   e   v4 )              (  v1  e   d          )
              (              d   e  )              (  v1  v2  e   d      )
              (                  d  )              (  v1  v2  v3  e   d  )
            where d and e denote diagonal and off-diagonal elements of T, and vi
            denotes an element of the vector defining H(i).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsyevd(System.Char,Extreme.Mathematics.MatrixTriangle,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            real symmetric matrix A.</para>
            </summary>
            <param name="jobz">
            <code>
            JOBZ is CHARACTER*1
            = 'N':  Compute eigenvalues only;
            = 'V':  Compute eigenvalues and eigenvectors.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  Upper triangle of A is stored;
            = 'L':  Lower triangle of A is stored.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA, N)
            On entry, the symmetric matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of A contains the
            upper triangular part of the matrix A.  If UPLO = 'L',
            the leading N-by-N lower triangular part of A contains
            the lower triangular part of the matrix A.
            On exit, if JOBZ = 'V', then if INFO = 0, A contains the
            orthonormal eigenvectors of the matrix A.
            If JOBZ = 'N', then on exit the lower triangle (if UPLO='L')
            or the upper triangle (if UPLO='U') of A, including the
            diagonal, is destroyed.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="w">
            <code>
            W is DOUBLE PRECISION array, dimension (N)
            If INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If N &amp;lt;= 1,               LWORK must be at least 1.
            If JOBZ = 'N' and N > 1, LWORK must be at least 2*N+1.
            If JOBZ = 'V' and N > 1, LWORK must be at least
                                                  1 + 6*N + 2*N**2.
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal sizes of the WORK and IWORK
            arrays, returns these values as the first entries of the WORK
            and IWORK arrays, and no error message related to LWORK or
            LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If N &amp;lt;= 1,                LIWORK must be at least 1.
            If JOBZ  = 'N' and N > 1, LIWORK must be at least 1.
            If JOBZ  = 'V' and N > 1, LIWORK must be at least 3 + 5*N.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal sizes of the WORK and
            IWORK arrays, returns these values as the first entries of
            the WORK and IWORK arrays, and no error message related to
            LWORK or LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i and JOBZ = 'N', then the algorithm failed
                  to converge; i off-diagonal elements of an intermediate
                  tridiagonal form did not converge to zero;
                  if INFO = i and JOBZ = 'V', then the algorithm failed
                  to compute an eigenvalue while working on the submatrix
                  lying in rows and columns INFO/(N+1) through
                  mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            If eigenvectors are desired, it uses a
            divide and conquer algorithm.
            The divide and conquer algorithm makes very mild assumptions about
            floating point arithmetic. It will work on machines with a guard
            digit in add/subtract, or on those binary machines without guard
            digits which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or
            Cray-2. It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.
            Because of large use of BLAS of level 3, DSYEVD needs N**2 more
            workspace than DSYEVX.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee \n
             Modified description of INFO. Sven, 16 Feb 05. \n
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsteqr(System.Char,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the implicit QL or QR method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'V':  Compute eigenvalues and eigenvectors of the original
                    symmetric matrix.  On entry, Z must contain the
                    orthogonal matrix used to reduce the original matrix
                    to tridiagonal form.
            = 'I':  Compute eigenvalues and eigenvectors of the
                    tridiagonal matrix.  Z is initialized to the identity
                    matrix.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ, N)
            On entry, if  COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if  COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1, and if
            eigenvectors are desired, then  LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (max(1,2*N-2))
            If COMPZ = 'N', then WORK is not referenced.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm has failed to find all the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero; on exit, D
                  and E contain the elements of a symmetric tridiagonal
                  matrix which is orthogonally similar to the original
                  matrix.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band symmetric matrix can also be found
            if DSYTRD or DSPTRD or DSBTRD has been used to reduce this matrix to
            tridiagonal form.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dsterf(System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues of a symmetric tridiagonal matrix
            using the Pal-Walker-Kahan variant of the QL or QR algorithm.</para>
            </summary>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the n diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the (n-1) subdiagonal elements of the tridiagonal
            matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  the algorithm failed to find all of the eigenvalues in
                  a total of 30*N iterations; if INFO = i, then i
                  elements of E have not converged to zero.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dstedc(System.Char,System.Int32,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,Extreme.Collections.Array1D{System.Int32},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes all eigenvalues and, optionally, eigenvectors of a
            symmetric tridiagonal matrix using the divide and conquer method.</para>
            </summary>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
            = 'N':  Compute eigenvalues only.
            = 'I':  Compute eigenvectors of tridiagonal matrix also.
            = 'V':  Compute eigenvectors of original dense symmetric
                    matrix also.  On entry, Z contains the orthogonal
                    matrix used to reduce the original matrix to
                    tridiagonal form.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The dimension of the symmetric tridiagonal matrix.  N >= 0.
            </code>
            </param>
            <param name="d">
            <code>
            D is DOUBLE PRECISION array, dimension (N)
            On entry, the diagonal elements of the tridiagonal matrix.
            On exit, if INFO = 0, the eigenvalues in ascending order.
            </code>
            </param>
            <param name="e">
            <code>
            E is DOUBLE PRECISION array, dimension (N-1)
            On entry, the subdiagonal elements of the tridiagonal matrix.
            On exit, E has been destroyed.
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,N)
            On entry, if COMPZ = 'V', then Z contains the orthogonal
            matrix used in the reduction to tridiagonal form.
            On exit, if INFO = 0, then if COMPZ = 'V', Z contains the
            orthonormal eigenvectors of the original symmetric matrix,
            and if COMPZ = 'I', Z contains the orthonormal eigenvectors
            of the symmetric tridiagonal matrix.
            If  COMPZ = 'N', then Z is not referenced.
            </code>
            <code>
            LDZ is INTEGER
            The leading dimension of the array Z.  LDZ >= 1.
            If eigenvectors are desired, then LDZ >= max(1,N).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array,
                                           dimension (LWORK)
            On exit, if INFO = 0, WORK(1) returns the optimal LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
            The dimension of the array WORK.
            If COMPZ = 'N' or N &amp;lt;= 1 then LWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LWORK must be at least
                           ( 1 + 3*N + 2*N*lg N + 4*N**2 ),
                           where lg( N ) = smallest integer k such
                           that 2**k >= N.
            If COMPZ = 'I' and N > 1 then LWORK must be at least
                           ( 1 + 4*N + N**2 ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LWORK need
            only be max(1,2*(N-1)).
            If LWORK = -1, then a workspace query is assumed; the routine
            only calculates the optimal size of the WORK array, returns
            this value as the first entry of the WORK array, and no error
            message related to LWORK is issued by XERBLA.
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (MAX(1,LIWORK))
            On exit, if INFO = 0, IWORK(1) returns the optimal LIWORK.
            </code>
            </param>
            <param name="liwork">
            <code>
            LIWORK is INTEGER
            The dimension of the array IWORK.
            If COMPZ = 'N' or N &amp;lt;= 1 then LIWORK must be at least 1.
            If COMPZ = 'V' and N > 1 then LIWORK must be at least
                           ( 6 + 6*N + 5*N*lg N ).
            If COMPZ = 'I' and N > 1 then LIWORK must be at least
                           ( 3 + 5*N ).
            Note that for COMPZ = 'I' or 'V', then if N is less than or
            equal to the minimum divide size, usually 25, then LIWORK
            need only be 1.
            If LIWORK = -1, then a workspace query is assumed; the
            routine only calculates the optimal size of the IWORK array,
            returns this value as the first entry of the IWORK array, and
            no error message related to LIWORK is issued by XERBLA.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit.
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value.
            > 0:  The algorithm failed to compute an eigenvalue while
                  working on the submatrix lying in rows and columns
                  INFO/(N+1) through mod(INFO,N+1).
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The eigenvectors of a full or band real symmetric matrix can also be
            found if DSYTRD or DSPTRD or DSBTRD has been used to reduce this
            matrix to tridiagonal form.
            This code makes very mild assumptions about floating point
            arithmetic. It will work on machines with a guard digit in
            add/subtract, or on those binary machines without guard digits
            which subtract like the Cray X-MP, Cray Y-MP, Cray C-90, or Cray-2.
            It could conceivably fail on hexadecimal or decimal machines
            without guard digits, but we know of none.  See DLAED3 for details.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
            Jeff Rutter, Computer Science Division, University of California
            at Berkeley, USA \n
             Modified by Francoise Tisseur, University of Tennessee
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtrti2(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            Specifies whether the matrix A is upper or lower triangular.
            = 'U':  Upper triangular
            = 'L':  Lower triangular
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            Specifies whether or not the matrix A is unit triangular.
            = 'N':  Non-unit triangular
            = 'U':  Unit triangular
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading n by n upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading n by n lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -k, the k-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 2 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  September 2012</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularInvert(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Computes the inverse of a real upper or lower triangular
            matrix A.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            On entry, the triangular matrix A.  If UPLO = 'U', the
            leading N-by-N upper triangular part of the array A contains
            the upper triangular matrix, and the strictly lower
            triangular part of A is not referenced.  If UPLO = 'L', the
            leading N-by-N lower triangular part of the array A contains
            the lower triangular matrix, and the strictly upper
            triangular part of A is not referenced.  If DIAG = 'U', the
            diagonal elements of A are also not referenced and are
            assumed to be 1.
            On exit, the (triangular) inverse of the original matrix, in
            the same storage format.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0: successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, A(i,i) is exactly zero.  The triangular
                 matrix is singular and its inverse can not be computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            This is the Level 3 BLAS version of the algorithm.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtrexc(System.Char,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@,System.Int32@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Reorders the real Schur factorization of a real matrix
            A = Q*T*Q**T, so that the diagonal block of T with row index IFST is
            moved to row ILST.</para>
            </summary>
            <param name="compq">
            <code>
            COMPQ is CHARACTER*1
            = 'V':  update the matrix Q of Schur vectors;
            = 'N':  do not update Q.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,N)
            On entry, the upper quasi-triangular matrix T, in Schur
            Schur canonical form.
            On exit, the reordered upper quasi-triangular matrix, again
            in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="q">
            <code>
            Q is DOUBLE PRECISION array, dimension (LDQ,N)
            On entry, if COMPQ = 'V', the matrix Q of Schur vectors.
            On exit, if COMPQ = 'V', Q has been postmultiplied by the
            orthogonal transformation matrix Z which reorders T.
            If COMPQ = 'N', Q is not referenced.
            </code>
            <code>
            LDQ is INTEGER
            The leading dimension of the array Q.  LDQ >= max(1,N).
            </code>
            </param>
            <param name="ifst">
            <code>
            IFST is INTEGER
            </code>
            </param>
            <param name="ilst">
            <code>
            ILST is INTEGER
            Specify the reordering of the diagonal blocks of T.
            The block with row index IFST is moved to row ILST, by a
            sequence of transpositions between adjacent blocks.
            On exit, if IFST pointed on entry to the second row of a
            2-by-2 block, it is changed to point to the first row; ILST
            always points to the first row of the block in its final
            position (which may differ from its input value by +1 or -1).
            1 &amp;lt;= IFST &amp;lt;= N; 1 &amp;lt;= ILST &amp;lt;= N.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            = 1:  two adjacent blocks were too close to swap (the problem
                  is very ill-conditioned); T may have been partially
                  reordered, and ILST points to the first row of the
                  current position of the block being moved.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The real Schur form T is reordered by an orthogonal similarity
            transformation Z**T*T*Z, and optionally the matrix Q of Schur vectors
            is updated by postmultiplying it with Z.
            T must be in Schur canonical form (as returned by DHSEQR), that is,
            block upper triangular with 1-by-1 and 2-by-2 diagonal blocks; each
            2-by-2 diagonal block has its diagonal elements equal and its
            off-diagonal elements of opposite sign.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtrevc(Extreme.Mathematics.MatrixOperationSide,System.Char,Extreme.Collections.Array1D{System.Boolean},System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32,System.Int32@,Extreme.Collections.Array1D{`0},System.Int32@)">
            <summary>
            <para>
            Computes some or all of the right and/or left eigenvectors of
            a real upper quasi-triangular matrix T.</para>
            </summary>
            <param name="side">
            <code>
            SIDE is CHARACTER*1
            = 'R':  compute right eigenvectors only;
            = 'L':  compute left eigenvectors only;
            = 'B':  compute both right and left eigenvectors.
            </code>
            </param>
            <param name="howmny">
            <code>
            HOWMNY is CHARACTER*1
            = 'A':  compute all right and/or left eigenvectors;
            = 'B':  compute all right and/or left eigenvectors,
                    backtransformed by the matrices in VR and/or VL;
            = 'S':  compute selected right and/or left eigenvectors,
                    as indicated by the logical array SELECT.
            </code>
            </param>
            <param name="select">
            <code>
            SELECT is LOGICAL array, dimension (N)
            If HOWMNY = 'S', SELECT specifies the eigenvectors to be
            computed.
            If w(j) is a real eigenvalue, the corresponding real
            eigenvector is computed if SELECT(j) is .TRUE..
            If w(j) and w(j+1) are the real and imaginary parts of a
            complex eigenvalue, the corresponding complex eigenvector is
            computed if either SELECT(j) or SELECT(j+1) is .TRUE., and
            on exit SELECT(j) is set to .TRUE. and SELECT(j+1) is set to
            .FALSE..
            Not referenced if HOWMNY = 'A' or 'B'.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix T. N >= 0.
            </code>
            </param>
            <param name="t">
            <code>
            T is DOUBLE PRECISION array, dimension (LDT,N)
            The upper quasi-triangular matrix T in Schur canonical form.
            </code>
            <code>
            LDT is INTEGER
            The leading dimension of the array T. LDT >= max(1,N).
            </code>
            </param>
            <param name="vl">
            <code>
            VL is DOUBLE PRECISION array, dimension (LDVL,MM)
            On entry, if SIDE = 'L' or 'B' and HOWMNY = 'B', VL must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by DHSEQR).
            On exit, if SIDE = 'L' or 'B', VL contains:
            if HOWMNY = 'A', the matrix Y of left eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*Y;
            if HOWMNY = 'S', the left eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VL, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part, and the second the imaginary part.
            Not referenced if SIDE = 'R'.
            </code>
            <code>
            LDVL is INTEGER
            The leading dimension of the array VL.  LDVL >= 1, and if
            SIDE = 'L' or 'B', LDVL >= N.
            </code>
            </param>
            <param name="vr">
            <code>
            VR is DOUBLE PRECISION array, dimension (LDVR,MM)
            On entry, if SIDE = 'R' or 'B' and HOWMNY = 'B', VR must
            contain an N-by-N matrix Q (usually the orthogonal matrix Q
            of Schur vectors returned by DHSEQR).
            On exit, if SIDE = 'R' or 'B', VR contains:
            if HOWMNY = 'A', the matrix X of right eigenvectors of T;
            if HOWMNY = 'B', the matrix Q*X;
            if HOWMNY = 'S', the right eigenvectors of T specified by
                             SELECT, stored consecutively in the columns
                             of VR, in the same order as their
                             eigenvalues.
            A complex eigenvector corresponding to a complex eigenvalue
            is stored in two consecutive columns, the first holding the
            real part and the second the imaginary part.
            Not referenced if SIDE = 'L'.
            </code>
            <code>
            LDVR is INTEGER
            The leading dimension of the array VR.  LDVR >= 1, and if
            SIDE = 'R' or 'B', LDVR >= N.
            </code>
            </param>
            <param name="mm">
            <code>
            MM is INTEGER
            The number of columns in the arrays VL and/or VR. MM >= M.
            </code>
            </param>
            <param name="m">
            <code>
            M is INTEGER
            The number of columns in the arrays VL and/or VR actually
            used to store the eigenvectors.
            If HOWMNY = 'A' or 'B', M is set to N.
            Each selected real eigenvector occupies one column and each
            selected complex eigenvector occupies two columns.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            Matrices of this type are produced by the Schur factorization of
            a real general matrix:  A = Q*T*Q**T, as computed by DHSEQR.
            The right eigenvector x and the left eigenvector y of T corresponding
            to an eigenvalue w are defined by:
               T*x = w*x,     (y**T)*T = w*(y**T)
            where y**T denotes the transpose of y.
            The eigenvalues are not input to this routine, but are read directly
            from the diagonal blocks of T.
            This routine returns the matrices X and/or Y of right and left
            eigenvectors of T, or the products Q*X and/or Q*Y, where Q is an
            input matrix.  If Q is the orthogonal factor that reduces a matrix
            A to Schur form T, then Q*X and Q*Y are the matrices of right and
            left eigenvectors of A.
            </code>
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            The algorithm used in this program is basically backward (forward)
            substitution, with scaling to make the the code robust against
            possible overflow.
            Each eigenvector is normalized so that the element of largest
            magnitude has magnitude 1; here the magnitude of a complex number
            (x,y) is taken to be |x| + |y|.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularEstimateCondition(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,Extreme.Collections.Array2D{`0},`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.TriangularSolve(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A**T * X = B,
            where A is a triangular matrix of order N, and B is an N-by-NRHS
            matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form of the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="a">
            <code>
            A is DOUBLE PRECISION array, dimension (LDA,N)
            The triangular matrix A.  If UPLO = 'U', the leading N-by-N
            upper triangular part of the array A contains the upper
            triangular matrix, and the strictly lower triangular part of
            A is not referenced.  If UPLO = 'L', the leading N-by-N lower
            triangular part of the array A contains the lower triangular
            matrix, and the strictly upper triangular part of A is not
            referenced.  If DIAG = 'U', the diagonal elements of A are
            also not referenced and are assumed to be 1.
            </code>
            <code>
            LDA is INTEGER
            The leading dimension of the array A.  LDA >= max(1,N).
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0: if INFO = -i, the i-th argument had an illegal value
            > 0: if INFO = i, the i-th diagonal element of A is zero,
                 indicating that the matrix is singular and the solutions
                 X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtbcon(Extreme.Mathematics.MatrixNorm,Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},`0@,Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{System.Int32},System.Int32@)">
            <summary>
            <para>
            Estimates the reciprocal of the condition number of a
            triangular band matrix A, in either the 1-norm or the infinity-norm.</para>
            </summary>
            <param name="norm">
            <code>
            NORM is CHARACTER*1
            Specifies whether the 1-norm condition number or the
            infinity-norm condition number is required:
            = '1' or 'O':  1-norm;
            = 'I':         Infinity-norm.
            </code>
            </param>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of the array. The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="rcond">
            <code>
            RCOND is DOUBLE PRECISION
            The reciprocal of the condition number of the matrix A,
            computed as RCOND = 1/(norm(A) * norm(inv(A))).
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (3*N)
            </code>
            </param>
            <param name="iwork">
            <code>
            IWORK is INTEGER array, dimension (N)
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            </code>
            </param>
            <remarks>
            <para>
            <code>
            The norm of A is computed and an estimate is obtained for
            norm(inv(A)), then the reciprocal of the condition number is
            computed as
               RCOND = 1 / ( norm(A) * norm(inv(A)) ).
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dtbtrs(Extreme.Mathematics.MatrixTriangle,Extreme.Mathematics.TransposeOperation,Extreme.Mathematics.MatrixDiagonal,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array2D{`0},System.Int32@)">
            <summary>
            <para>
            Solves a triangular system of the form
               A * X = B  or  A**T * X = B,
            where A is a triangular band matrix of order N, and B is an
            N-by NRHS matrix.</para>
            </summary>
            <param name="uplo">
            <code>
            UPLO is CHARACTER*1
            = 'U':  A is upper triangular;
            = 'L':  A is lower triangular.
            </code>
            </param>
            <param name="trans">
            <code>
            TRANS is CHARACTER*1
            Specifies the form the system of equations:
            = 'N':  A * X = B  (No transpose)
            = 'T':  A**T * X = B  (Transpose)
            = 'C':  A**H * X = B  (Conjugate transpose = Transpose)
            </code>
            </param>
            <param name="diag">
            <code>
            DIAG is CHARACTER*1
            = 'N':  A is non-unit triangular;
            = 'U':  A is unit triangular.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
            The order of the matrix A.  N >= 0.
            </code>
            </param>
            <param name="kd">
            <code>
            KD is INTEGER
            The number of superdiagonals or subdiagonals of the
            triangular band matrix A.  KD >= 0.
            </code>
            </param>
            <param name="nrhs">
            <code>
            NRHS is INTEGER
            The number of right hand sides, i.e., the number of columns
            of the matrix B.  NRHS >= 0.
            </code>
            </param>
            <param name="ab">
            <code>
            AB is DOUBLE PRECISION array, dimension (LDAB,N)
            The upper or lower triangular band matrix A, stored in the
            first kd+1 rows of AB.  The j-th column of A is stored
            in the j-th column of the array AB as follows:
            if UPLO = 'U', AB(kd+1+i-j,j) = A(i,j) for max(1,j-kd)&amp;lt;=i&amp;lt;=j;
            if UPLO = 'L', AB(1+i-j,j)    = A(i,j) for j&amp;lt;=i&amp;lt;=min(n,j+kd).
            If DIAG = 'U', the diagonal elements of A are not referenced
            and are assumed to be 1.
            </code>
            <code>
            LDAB is INTEGER
            The leading dimension of the array AB.  LDAB >= KD+1.
            </code>
            </param>
            <param name="b">
            <code>
            B is DOUBLE PRECISION array, dimension (LDB,NRHS)
            On entry, the right hand side matrix B.
            On exit, if INFO = 0, the solution matrix X.
            </code>
            <code>
            LDB is INTEGER
            The leading dimension of the array B.  LDB >= max(1,N).
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
            = 0:  successful exit
            &amp;lt; 0:  if INFO = -i, the i-th argument had an illegal value
            > 0:  if INFO = i, the i-th diagonal element of A is zero,
                  indicating that the matrix is singular and the
                  solutions X have not been computed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
            A check is made to verify that A is nonsingular.
            </code>
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.LinearAlgebra.Implementation.Generic.GenericLapack`1.Dhseqr(System.Char,System.Char,System.Int32,System.Int32,System.Int32,Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array1D{`0},Extreme.Collections.Array2D{`0},Extreme.Collections.Array1D{`0},System.Int32,System.Int32@)">
            <summary>
            <para>
            Computes the eigenvalues of a Hessenberg matrix H
               and, optionally, the matrices T and Z from the Schur decomposition
               H = Z T Z**T, where T is an upper quasi-triangular matrix (the
               Schur form), and Z is the orthogonal matrix of Schur vectors.</para>
            </summary>
            <param name="job">
            <code>
            JOB is CHARACTER*1
             = 'E':  compute eigenvalues only;
             = 'S':  compute eigenvalues and the Schur form T.
            </code>
            </param>
            <param name="compz">
            <code>
            COMPZ is CHARACTER*1
             = 'N':  no Schur vectors are computed;
             = 'I':  Z is initialized to the unit matrix and the matrix Z
                     of Schur vectors of H is returned;
             = 'V':  Z must contain an orthogonal matrix Q on entry, and
                     the product Q*Z is returned.
            </code>
            </param>
            <param name="n">
            <code>
            N is INTEGER
             The order of the matrix H.  N .GE. 0.
            </code>
            </param>
            <param name="ilo">
            <code>
            ILO is INTEGER
            </code>
            </param>
            <param name="ihi">
            <code>
            IHI is INTEGER
             It is assumed that H is already upper triangular in rows
             and columns 1:ILO-1 and IHI+1:N. ILO and IHI are normally
             set by a previous call to DGEBAL, and then passed to ZGEHRD
             when the matrix output by DGEBAL is reduced to Hessenberg
             form. Otherwise ILO and IHI should be set to 1 and N
             respectively.  If N.GT.0, then 1.LE.ILO.LE.IHI.LE.N.
             If N = 0, then ILO = 1 and IHI = 0.
            </code>
            </param>
            <param name="h">
            <code>
            H is DOUBLE PRECISION array, dimension (LDH,N)
             On entry, the upper Hessenberg matrix H.
             On exit, if INFO = 0 and JOB = 'S', then H contains the
             upper quasi-triangular matrix T from the Schur decomposition
             (the Schur form); 2-by-2 diagonal blocks (corresponding to
             complex conjugate pairs of eigenvalues) are returned in
             standard form, with H(i,i) = H(i+1,i+1) and
             H(i+1,i)*H(i,i+1).LT.0. If INFO = 0 and JOB = 'E', the
             contents of H are unspecified on exit.  (The output value of
             H when INFO.GT.0 is given under the description of INFO
             below.)
             Unlike earlier versions of DHSEQR, this subroutine may
             explicitly H(i,j) = 0 for i.GT.j and j = 1, 2, ... ILO-1
             or j = IHI+1, IHI+2, ... N.
            </code>
            <code>
            LDH is INTEGER
             The leading dimension of the array H. LDH .GE. max(1,N).
            </code>
            </param>
            <param name="wr">
            <code>
            WR is DOUBLE PRECISION array, dimension (N)
            </code>
            </param>
            <param name="wi">
            <code>
            WI is DOUBLE PRECISION array, dimension (N)
             The real and imaginary parts, respectively, of the computed
             eigenvalues. If two eigenvalues are computed as a complex
             conjugate pair, they are stored in consecutive elements of
             WR and WI, say the i-th and (i+1)th, with WI(i) .GT. 0 and
             WI(i+1) .LT. 0. If JOB = 'S', the eigenvalues are stored in
             the same order as on the diagonal of the Schur form returned
             in H, with WR(i) = H(i,i) and, if H(i:i+1,i:i+1) is a 2-by-2
             diagonal block, WI(i) = sqrt(-H(i+1,i)*H(i,i+1)) and
             WI(i+1) = -WI(i).
            </code>
            </param>
            <param name="z">
            <code>
            Z is DOUBLE PRECISION array, dimension (LDZ,N)
             If COMPZ = 'N', Z is not referenced.
             If COMPZ = 'I', on entry Z need not be set and on exit,
             if INFO = 0, Z contains the orthogonal matrix Z of the Schur
             vectors of H.  If COMPZ = 'V', on entry Z must contain an
             N-by-N matrix Q, which is assumed to be equal to the unit
             matrix except for the submatrix Z(ILO:IHI,ILO:IHI). On exit,
             if INFO = 0, Z contains Q*Z.
             Normally Q is the orthogonal matrix generated by DORGHR
             after the call to DGEHRD which formed the Hessenberg matrix
             H. (The output value of Z when INFO.GT.0 is given under
             the description of INFO below.)
            </code>
            <code>
            LDZ is INTEGER
             The leading dimension of the array Z.  if COMPZ = 'I' or
             COMPZ = 'V', then LDZ.GE.MAX(1,N).  Otherwize, LDZ.GE.1.
            </code>
            </param>
            <param name="work">
            <code>
            WORK is DOUBLE PRECISION array, dimension (LWORK)
             On exit, if INFO = 0, WORK(1) returns an estimate of
             the optimal value for LWORK.
            </code>
            </param>
            <param name="lwork">
            <code>
            LWORK is INTEGER
             The dimension of the array WORK.  LWORK .GE. max(1,N)
             is sufficient and delivers very good and sometimes
             optimal performance.  However, LWORK as large as 11*N
             may be required for optimal performance.  A workspace
             query is recommended to determine the optimal workspace
             size.
             If LWORK = -1, then DHSEQR does a workspace query.
             In this case, DHSEQR checks the input parameters and
             estimates the optimal workspace size for the given
             values of N, ILO and IHI.  The estimate is returned
             in WORK(1).  No error message related to LWORK is
             issued by XERBLA.  Neither H nor Z are accessed.
            </code>
            </param>
            <param name="info">
            <code>
            INFO is INTEGER
               =  0:  successful exit
             .LT. 0:  if INFO = -i, the i-th argument had an illegal
                      value
             .GT. 0:  if INFO = i, DHSEQR failed to compute all of
                  the eigenvalues.  Elements 1:ilo-1 and i+1:n of WR
                  and WI contain those eigenvalues which have been
                  successfully computed.  (Failures are rare.)
                  If INFO .GT. 0 and JOB = 'E', then on exit, the
                  remaining unconverged eigenvalues are the eigen-
                  values of the upper Hessenberg matrix rows and
                  columns ILO through INFO of the final, output
                  value of H.
                  If INFO .GT. 0 and JOB   = 'S', then on exit
             (*)  (initial value of H)*U  = U*(final value of H)
                  where U is an orthogonal matrix.  The final
                  value of H is upper Hessenberg and quasi-triangular
                  in rows and columns INFO+1 through IHI.
                  If INFO .GT. 0 and COMPZ = 'V', then on exit
                    (final value of Z)  =  (initial value of Z)*U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'I', then on exit
                        (final value of Z)  = U
                  where U is the orthogonal matrix in (*) (regard-
                  less of the value of JOB.)
                  If INFO .GT. 0 and COMPZ = 'N', then Z is not
                  accessed.
            </code>
            </param>
            <remarks>
            <para>
            <code>
               Optionally Z may be postmultiplied into an input orthogonal
               matrix Q so that this routine can give the Schur factorization
               of a matrix A which has been reduced to the Hessenberg form H
               by the orthogonal matrix Q:  A = Q*H*Q**T = (QZ)*T*(QZ)**T.
            </code>
            </para>
            <h4> Contributors:</h4>
            <para>
                  Karen Braman and Ralph Byers, Department of Mathematics,
                  University of Kansas, USA
            </para>
            <h4> Further Details:</h4>
            <para>
            <code>
            Default values supplied by
            ILAENV(ISPEC,'DHSEQR',JOB(:1)//COMPZ(:1),N,ILO,IHI,LWORK).
            It is suggested that these defaults be adjusted in order
            to attain best performance in each particular
            computational environment.
            ISPEC=12: The DLAHQR vs DLAQR0 crossover point.
                      Default: 75. (Must be at least 11.)
            ISPEC=13: Recommended deflation window size.
                      This depends on ILO, IHI and NS.  NS is the
                      number of simultaneous shifts returned
                      by ILAENV(ISPEC=15).  (See ISPEC=15 below.)
                      The default for (IHI-ILO+1).LE.500 is NS.
                      The default for (IHI-ILO+1).GT.500 is 3*NS/2.
            ISPEC=14: Nibble crossover point. (See IPARMQ for
                      details.)  Default: 14% of deflation window
                      size.
            ISPEC=15: Number of simultaneous shifts in a multishift
                      QR iteration.
                      If IHI-ILO+1 is ...
                      greater than      ...but less    ... the
                      or equal to ...      than        default is
                           1               30          NS =   2(+)
                          30               60          NS =   4(+)
                          60              150          NS =  10(+)
                         150              590          NS =  **
                         590             3000          NS =  64
                        3000             6000          NS = 128
                        6000             infinity      NS = 256
                  (+)  By default some or all matrices of this order
                       are passed to the implicit double shift routine
                       DLAHQR and this parameter is ignored.  See
                       ISPEC=12 above and comments in IPARMQ for
                       details.
                 (**)  The asterisks (**) indicate an ad-hoc
                       function of N increasing from 10 to 64.
            ISPEC=16: Select structured matrix multiply.
                      If the number of simultaneous shifts (specified
                      by ISPEC=15) is less than 14, then the default
                      for ISPEC=16 is 0.  Otherwise the default for
                      ISPEC=16 is 2.
            </code>
            </para>
            <h4> References:</h4>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part I: Maintaining Well Focused Shifts, and Level 3
                  Performance, SIAM Journal of Matrix Analysis, volume 23, pages
                  929--947, 2002.
            </para>
            <para>
                  K. Braman, R. Byers and R. Mathias, The Multi-Shift QR
                  Algorithm Part II: Aggressive Early Deflation, SIAM Journal
                  of Matrix Analysis, volume 23, pages 948--973, 2002.
            </para>
            <para>Authors: 
             Univ. of Tennessee,
             Univ. of California Berkeley,
             Univ. of Colorado Denver,
             NAG Ltd.</para>
            <para>Date:  November 2011</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.Generic.GenericImplementations.RegisterGenericProvider(Extreme.ProviderManager)">
            <summary>
            Registers the provider of generic implementations of linear
            algebra functions.
            </summary>
            <param name="providerManager"></param>
        </member>
        <member name="T:Extreme.Mathematics.Generic.ManagedCoreProvider`1">
            <summary>
            Represents a managed provider for the core linear algebra and FFT functionality 
            for an element type.
            </summary>
            <remarks>
            <para>
            The classes in the <see cref="N:Extreme.Mathematics.LinearAlgebra"/>
            namespace use the standard Basic Linear Algebra Subroutines
            (BLAS) whenever possible. The Extreme Optimization Mathematics Library
            for .NET provides two implementations. One is in 100% managed code.
            The other calls a native, highly optimized, processor-specific kernel.</para>
            <para>This class exposes properties that allow
            you to specify the BLAS objects that are to be used by
            the classes in this namespace.</para>
            <para>You can select the managed implementation by calling the <see cref="M:Extreme.Mathematics.CoreImplementations`1.UseManaged"/>
            method. To select the native implementation, call the <see cref="M:Extreme.Mathematics.CoreImplementations`1.UseNative"/> method.
            The native kernel is used by default. This is the fastest option,
            especially for larger matrices, but also has a larger memory footprint.</para>
            </remarks>
        </member>
        <member name="M:Extreme.Mathematics.Generic.ManagedCoreProvider`1.GetAllImplementations``1">
            <summary>
            Returns a sequence of all implementations of the specified type
            supported by the provider.
            </summary>
            <typeparam name="U">The type of the implementation.</typeparam>
            <returns>A sequence of all implementations of type <typeparamref name="U"/>
            supported by the provider.</returns>
        </member>
        <member name="M:Extreme.Mathematics.Generic.ManagedCoreProvider`1.#ctor">
            <summary>
            Constructs a new <see cref="T:Extreme.Mathematics.ManagedCoreProvider"/>.
            </summary>
        </member>
        <member name="M:Extreme.Mathematics.Generic.ManagedCoreProvider`1.WithMaxDegreeOfParallelism(System.Int32)">
            <summary>
            Returns a provider with the specified maximum degree of parallelism.
            </summary>
            <param name="maxDegreeOfParallelism">The maximum degree of parallelism.</param>
            <returns>A <see cref="T:Extreme.Mathematics.ManagedCoreProvider"/> with the specified
            maximum degree of parallelism.</returns>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.LinearAlgebraOperations">
            <summary>
            Gets the implementation of the 
            BLAS for T-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.LinearAlgebraOperations`1"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.LinearAlgebraOperations`1"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.DecompositionOperations">
            <summary>
            Gets the LAPACK implementation
            for T-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.GenericDecompositionOperations`1"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.DecompositionOperations`2"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.SparseLinearAlgebra">
            <summary>
            Gets the implementation of the sparse
            BLAS for T-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperations`1"/>.
            </para>
            </remarks>
            <value>A class that inherits from <see cref="T:Extreme.Mathematics.LinearAlgebra.Implementation.SparseLinearAlgebraOperations`1"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.Fft">
            <summary>
            Gets or sets the current FFT provider implementation
            for T-precision arguments.
            </summary>
            <remarks>
            <para>The default value of this property is
            an instance of <see cref="T:Extreme.Mathematics.SignalProcessing.FftProvider`1"/>.
            </para>
            </remarks>
            <value>A class that inherits from 
            <see cref="T:Extreme.Mathematics.SignalProcessing.FftProvider`1"/>.</value>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.ArrayFunctions">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.ComplexArrayFunctions">
            <inheritdoc/>
        </member>
        <member name="P:Extreme.Mathematics.Generic.ManagedCoreProvider`1.HasSharedDegreeOfParallelism">
            <summary>
            Indicates whether the degree of parallelism is a property that is shared
            across instances.
            </summary>
        </member>
    </members>
</doc>
